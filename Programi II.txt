/*
Zadatak 2. Koristeci rekurziju, napisati program koji korisniku omogucava da unese željeni tekst. Uslov za završetak programa 
je da uneseni tekst sadrži najmanje jednu tacku (.). Nakon unosa, program treba obrnutim redoslijedom ispisati sve 
znakove koji su uneseni do prvog znaka tacke.
*/

#include <iostream> 
using namespace std;  

void prikaziUnazad()
{ 
	char znak; 
	cin >> znak;
	if (znak != '.')
	{
		prikaziUnazad(); 
		cout << znak;
	} 
	else
		cout << "\nObrnutim redosljedom ste unijeli: ";
}
void main()
{
	cout << "\t\t::REKURZIJA::\n\n";
		cout << "Unesite vas tekst: "; 
		prikaziUnazad();
		cout << "\n\nMAIN::POSLIJE poziva rekurzivne funkcije\n\n";
		system("pause");
}
__________________________________________________________________________________

/*
Zadatak 3. Koristeci rekurziju, napisati program koji od korisnika traži da unese neko slovo. 
Nakon unosa, program treba da ispiše sva slova koja se nalaze izmedu unesenog i
slova 'A'. Pored oznake slova, program treba da ispiše i njima pripadajuci ASCII kod. Takoder, potrebno je ispisati 
odgovarajucu poruku u slucaju da korisnik unese znak koji ima ASCII vrijednost manju od slova 'A'.

Napomene:  ? Kada se kaže manje ili vece slovo, naravno, misli se na vrijednost ASCII koda koji je asociran sa odredenim slovom.
? ASCII kod za malo slovo a je 97, a za veliko slovo A je 65.
*/

#include <iostream> 
using namespace std;  

void rekurzija(char);

void main()
{
	char slovo;
	cout << "Unesite neko slovo" << endl;
	cin >> slovo;
	while ((slovo < char(65) || slovo > char(122)) || (slovo > char(90) && slovo < char(97)))
	{
		cout << "Pomnovite unos" << endl;
		cin >> slovo;
	}
	rekurzija(slovo);
	system("pause");
}
void rekurzija(char s)
{
	if (s < char(65))
		return;
	else
		rekurzija(int(s)-1);
	if ((s>char(64) && s<char(91)) || (s>char(97) && s<char(123)))
		cout << s << "  : a ASCII kod za njega je: " << int(s) << endl;
}
____________________________________________________________________________________

/*
Zadatak 3. Koristeci rekurziju, napisati program koji od korisnika traži da unese neko slovo. 
Nakon unosa, program treba da ispiše sva slova koja se nalaze izmedu unesenog i
slova 'A'. Pored oznake slova, program treba da ispiše i njima pripadajuci ASCII kod. Takoder, potrebno je ispisati 
odgovarajucu poruku u slucaju da korisnik unese znak koji ima ASCII vrijednost manju od slova 'A'.

Napomene:  ? Kada se kaže manje ili vece slovo, naravno, misli se na vrijednost ASCII koda koji je asociran sa odredenim slovom.
? ASCII kod za malo slovo a je 97, a za veliko slovo A je 65.
*/

#include <iostream> 
using namespace std;  

void rekurzija(char);

void main()
{
	char slovo;
	cout << "Unesite neko slovo" << endl;
	cin >> slovo;
	while ((slovo < char(65) || slovo > char(122)) || (slovo > char(90) && slovo < char(97)))
	{
		cout << "Pomnovite unos" << endl;
		cin >> slovo;
	}
	rekurzija(slovo);
	system("pause");
}
void rekurzija(char s)
{
	if (s >= char(65))
	{
		rekurzija(int(s) - 1);
		if ((s > char(64) && s<char(91)) || (s>char(97) && s<char(123)))
			cout << s << "  : a ASCII kod za njega je: " << int(s) << endl;
	}
	else
		cout << "Ispis slova" << endl;
}

__________________________________________________________________


#include <iostream>
using namespace std;

struct kruznica
{
	float x;
	float y;
	float poluprecnik;
};
void main()
{
	kruznica k1, k2, k3, k4;
	k1.x = 1;
	k1.y = 1;
	k2.x = -1;
	k2.y = 1;
	k3.x = -1;
	k3.y = -1;
	k4.x = 1;
	k4.y = -1;
	cout << "Unesite vrijednost poluprecnika kruznice k1" << endl;
	cin >> k1.poluprecnik;
	k2.poluprecnik = k1.poluprecnik;
	k3.poluprecnik = 2 * k2.poluprecnik;
	k4.poluprecnik = k2.poluprecnik + k3.poluprecnik;
	cout << "-	Kružnica iz drugog kvadranta sa centrom O( ";
	cout << k1.x <<" , " <<k1.y ;
	cout << " ) ima isti poluprecnik kao \nkružnica O( ";
	cout << k2.x <<" , "<< k2.y; 
	cout << " ) iz prvog kvadranta koji iznosi r= ";
	cout << k1.poluprecnik << endl;
	system("pause");

}

___________________________________________________________________________


/*
Koristeci prethodnu strukturu trougao i kruznica:
a.	kreirajte objekat T1 ( ) cije cete koordinate tacaka A, B i C ucitati sa tastature
b.	kreirajte kružnicu K1, ciji se centar nalazi u tacki A trougla T1 ( )
c.	vrijednost poluprecnika kružnice K1 ucitajte sa tastature
d.	kreirajte kružnicu K3 sa istim osobinama kao kružnica K1, tj. K1 iskopirajte u novi K3
e.	povecajte poluprecnik kružnice K3 za 10%
f.	kreirajte kružnicu K2 koja se nalazi na tacki B sa istim poluprecnikom kao kod K3

*/
#include <iostream>
using namespace std;

struct kruznica
{
	float x;
	float y;
	float poluprecnik;
};
struct trougao
{
	float a_x;
	float a_y;
	float b_x;
	float b_y;
	float c_x, c_y;
};
void main()
{
	trougao T1;
	cout << "Unesite x koordinatu za tacku A "<< endl;
	cin >> T1.a_x;
	cout << "Unesite y koordinatu za tacku A" << endl;
	cin >> T1.a_y;
	cout << "Unesite x koordinatu za tacku B " << endl;
	cin >> T1.b_x;
	cout << "Unesite y koordinatu za tacku B" << endl;
	cin >> T1.b_y;
	cout << "Unesite x koordinatu za tacku C " << endl;
	cin >> T1.c_x;
	cout << "Unesite y koordinatu za tacku C" << endl;
	cin >> T1.c_y;
	kruznica K1;
	K1.x = T1.a_x;
	K1.y = T1.a_y;

	cout << "Unesite poluprecnik kruznice K1" << endl;
	cin >> K1.poluprecnik;

	kruznica K3;
	K3 = K1;

	K3.poluprecnik = K3.poluprecnik*1.1;
	cout << K3.poluprecnik;
	kruznica K2;
	K2.x = T1.b_x;
	K2.y = T1.b_y;
	K2.poluprecnik = K3.poluprecnik;



	system("pause");

}

_________________________________________________________________


/*
Napravite funkciju void infoKruznica, ciji je ulazni parametar podatak tipa kruznica. Funkcija treba ispisati osobine
kružnice u  sljedecem obliku:

## infoKruznica
centar O(1.4, 2.5)
poluprecnik r = 12

Zatim, iskoristite ovu funkciju da bi ispisali osobine kružnice K1 i K2 iz zadatka br. 2.


*/
#include <iostream>
using namespace std;

struct kruznica
{
	float x;
	float y;
	float poluprecnik;
};
void infoKruznica(kruznica);

void main()
{
	kruznica K1;
	K1.x = 1.4;
	K1.y = 2.5;
	K1.poluprecnik = 12;
	infoKruznica(K1);

	system("pause");

}
void infoKruznica(kruznica kr)
{
	cout << "## infoKruznica" << endl;
	cout << "centar O ( " << kr.x << " , " << kr.y << " )" << endl;
	cout << "poluprecnik r = " << kr.poluprecnik << endl;
}
_______________________________________________________________________


/* 
Zadatak 4
Napišite program u kojem cete deklarirari niz od 5 cijelobrojnih elemenata te uz pomoc:
? funkcije: void unos (int *, int); omoguciti unos elemenata niza; ? funkcije: void ispis (int *, int); 
omoguciti ispis elemenata niza; ? funkcije: int * najveci (int *, int); vratiti adresu najveceg elementa u nizu;
obavezno provjerite je li funkcija vratila korektnu adresu. */

#include<iostream>
using namespace std;

void unos(int *niz, int velicina)
{
	for (int i = 0; i < velicina; i++)
	{
		cin >> *(niz+i);
	}
}
void ispis(int *niz, int velicina)
{
	for (int i = 0; i < velicina; i++)
	{
		cout << *(niz + i) << endl;
	}
}
int * najveci(int *niz, int velicina)
{
	int najveci = niz[0];
	for (int i = 1; i < velicina; i++)
	{
		if (niz[i]>najveci)
			najveci = niz[i];
	}
	return &najveci;
}


void main()
{
	const int velicina = 5;
	int niz[velicina];
	unos(niz, velicina);
	ispis(niz, velicina);
	int *naj = 0;
	naj = najveci(niz, velicina);
	cout << naj << endl;
	cout << *naj << endl;


	system("pause");
}

______________________________________________________________________


/* 
Zadatak 1:
Poštujuci sve faze procesa programiranje, napisati program koji izracunava sumu svih brojeva u interval od 2 do n  koji 
su stepeni broja 2. Granicna vrijednost n se unosi na pocetku glavnog programa, pri cemu je potrebno voditi racuna da se
podrži što veca granicna vrijednost. Kreirati pomocnu funkciju DaLiJeStepen2 za provjeru da li je proslijedeni broj stepen 
broja 2 (stepeni broja 2 su: 2, 4, 8, 16, 32…). Izracun i ispis sume uraditi u glavnom programu.
Unesite gornju granicu intervala: 64
Suma brojeva koji se mogu napisati kao stepen broja 2 u intervalu [2, 64] je: 126
*/

#include <iostream> 
using namespace std;  

bool DaLiJeStepen2(int);

void main()
{
	int n, suma = 0;
	cout << "Unesite jedan broj: " << endl;
	cin >> n;
	int broj = n;
	bool rez = false;
	rez = DaLiJeStepen2(n);
	if (rez)
	{
		while (n > 1)
		{
			suma += n;
			n /= 2;
		}
		cout << "Suma od 2 do " << broj << "je: " << suma << endl;
	}

	system("pause");
}
bool DaLiJeStepen2(int n)
{
	bool pomocna = false;
	int brojac = 0;

	while (n > 1)
	{
		if (n % 2 != 0)
			brojac++;
		n /= 2;
	}
	if (brojac == 0)
	{
		pomocna = true;
		cout << "broj je stepen broja 2" << endl;
	}
	return pomocna;
}

________________________________________________________________________


/*Napišite program u kojem cete :
Napišite program u kojem cete deklarirari niz od 5 cijelobrojnih elemenata te uz pomoc:
a)	funkcije: void unos (int *, int); omoguciti unos elemenata niza;
b)	funkcije: void ispis (int *, int); omoguciti ispis elemenata niza;
c)	funkcije: int* najveci (int *, int); vratiti adresu najveceg elementa u nizu; obavezno provjerite je li funkcija
vratila korektnu adresu.
d)	funkcije: int* arit_sredina (int *, int); vratiti aritmeticku sredinu elemenata u nizu


*/

#include <iostream>
using namespace std;

void unos(int * niz, int velicina)
{
	for (int i = 0; i < velicina; i++){
		cin >> niz[i];
	}
}
void ispis(int * niz, int velicina){
	for (int i = 0; i < velicina; i++){
		cout << niz[i] << endl;
	}
}
	
int* najveci(int *niz, int velicina){
	int *Najveci = &niz[0];
	for (int i = 0; i < velicina; i++){
		if (*Najveci < niz[i])
			Najveci = &niz[i];
	}
	return Najveci;
}
int* arit_sredina(int *niz, int vrijednost){
	int artimeticka = 0;
	for (int i = 0; i < vrijednost; i++)
	{
		artimeticka += niz[i];
	}
	artimeticka /= vrijednost;
	return &artimeticka;
}

void main()
{
	const int velicina = 5;
	int niz[velicina];
	unos(niz, velicina);
	ispis(niz, velicina);
	int *pok = najveci(niz, velicina);
	cout << *pok << endl;
	int *artimeticka = arit_sredina(niz, velicina);
	cout << *artimeticka << endl;

	system("pause");

}

_______________________________________________________________________



#include <iostream>
using namespace  std;

void f1(float a, float b, float c, float& r1, float& r2, bool& greska)
{
	float D = b*b - (4 * a*c);

	if (D >= 0 && a!=0){
		r1 = -b + sqrt(D) / (2 * a);
		r1 = -b - sqrt(D) / (2 * a);
	}
	else
	{
		greska = true;
	}
}

void main()
{
	float a, b, c, r1, r2;
	bool greska = false;
	cout << "Unesite a,b,c: " << endl;
	cin >> a >> b >> c;
	f1(a, b, c, r1, r2, greska);

	if (greska)
		cout << "Greska" << endl;
	else
		cout << "RJ1: " << r1 << "RJ2: " << r2 << endl;

	system("pause");
}

___________________________________________________________________

/*
Deklarišite niz A tipa int velicine 5. Ispišite adrese elemenata niza koristeci operator '+' bez upotrebe adresnog 
operatora '&'. Koristite for-petlju. Zatim, ispišite razliku izmedu adrese elementa sa indeksom 4 i adrese elementa
sa indeksom 1 koristeci operator '-' i operator '&'.
*/

#include <iostream> 
using namespace std;


void main()
{
	int A[5];
	for (int i = 0; i < 5; i++)
	{
		cout << A + i << endl;
	}
	cout << &A[0] - &A[4] << endl;
	system("pause");
}

__________________________________________________________________________________

/*
Deklarišite tri varijable (a, b, c) i inicijaluzujte ih - deklarišite niz pokazivaca velicine 100 - neka prva tri
elementa niza pokazuju na varijable a, b, c - ispišite vrijednosti varijabli a, b, c  koristeci prva tri elementa niza
*/

#include <iostream> 
using namespace std;


void main()
{
	int a, b, c;
	a = 5;
	b = 6;
	c = 7;
	int* niz[100];
	niz[0] = &a;
	niz[1] = &b;
	niz[2] = &c;
	for (int i = 0; i < 3; i++)
	{
		cout << *(niz[i]) << endl;
	}
	
	system("pause");
}

___________________________________________________________________________

/*
Napišite program u kojem ce: 
• Korisnik odrediti velicinu x. 
• Alocirati dinamicke nizove A velicine x 
• Alocirati dinamicke nizove B velicine x 
• Korisnik treba unijeti elemente nizova A i B. 
o koristite funkciju ucitaj iz prethodnog zadatka. 
• Alocirati dinamicke nizove C velicine x 
• Sabrati elemente nizova A i B, te rezultat smjestiti u niz C 
o koristite funkciji saberi. 
• Ispisati elemente niza C  
o koristite funkcije ispis iz prethodnog zadatka.
*/

#include <iostream> 
using namespace std;

void ucitaj(int* p, int x)
{
	for (int i = 0; i < x; i++)
	{
		cout << "Unesite " << i << " elemenat niza: " << endl;
		cin >> p[i];
	}

}

void saberi(int* pA, int* pB, int* pC, int x)
{
	for (int i = 0; i < x; i++)
	{
		pC[i] = pA[i] + pB[i];
	}
}

void ispis(int* pC, int x)
{
	for (int i = 0; i < x; i++)
	{
		cout << pC[i] << endl;
	}
}

void main()
{
	int x;
	cin >> x;
	int* pokA = new int[x];
	int* pokB = new int[x];

	ucitaj(pokA, x);
	ucitaj(pokB, x);
	int* pokC = new int[x];
	saberi(pokA, pokB, pokC, x);
	ispis(pokC, x);

	system("pause");
}

_________________________________________________________________________


/*
Napišite program u kojem cete: 
• Kreirati dinamicki niz od onoliko cjelobrojnih elemenata koliko želi korisnik; 
• Omoguciti inicijalizaciju clanova niza unosom s tastature;
• Utvrditi koliko elemenata niza je manje od 0; 
• Kreirati novi niz ciji ce elementi biti elementi prvog niza koji zadovoljavaju prethodni uvjet (manji su od 0); 
• Koristite funkcije.
*/

#include <iostream> 
using namespace std;

int inicijalizacija(int* pA, int* pB, int x)
{
	int brojac = 0;
	for (int i = 0; i < x; i++)
	{
		if (pA[i] < 0){
			pB[brojac] = pA[i];
			brojac++;
		}

	}
	return brojac;
}

void main()
{
	int x;
	cout << "Unesite velicinu niza" << endl;
	cin >> x;
	int* pA = new int[x];
	int brojac = 0;
	for (int i = 0; i < x; i++)
	{
		cin >> pA[i];
	}
	int* pB = new int[brojac];
	int br=inicijalizacija(pA, pB, x);
	for (int i = 0; i < br; i++)
	{
		cout << pB[i] << endl;
	}

	system("pause");
}

_____________________________________________________________________

Postovanje profesore,

Ovdje sam proslijedio funkciji niz pokazivaca (M), broj redova tj, velicinu niza M, i broj kolona tj, koliki ce mi nizovi biti R1,R2,R3. Funkcija prima (pravi)pokazivac X na pokazivac M, i onda pomocu dvostruke for petlje unosimo clanove nizova R1,R2,R3. Pomocu pokazivaca X koji  pokazuje na niz pokazivaca M, preko prvih uglatih zagrada pristupamo nizu M(i njegovom indeksu pomocu "i"),a pomocu drugih uglatih zagrada pristupamo onoj adresi koja se nalazi u nizu na poziciji "i". I pomocu "j" unosimo clanove nizova R1,R2,R3.

Jesam li dobro ovo obrazlozio, ili sam pogrijesio?


#include <iostream> 
using namespace std;

void ucitaj(int** X, int r, int k)    //int*X=M;
{
for (int i = 0; i < r; i++)
{
for (int j = 0; j < k; j++)
{
cin >> X[i][j];
}
}
}
void ispis(int** M, int r, int k)
{
for (int i = 0; i < r; i++)
{
for (int j = 0; j < k; j++)
{
cout << "  " << M[i][j] << "  ";
}
cout << endl;
}
}

void main()
{
const int redova = 3;
const int kolona = 4;
int R1[kolona], R2[kolona], R3[kolona];
int* M [redova];
M[0] = R1;
M[1] = R2;
M[2] = R3;
ucitaj(M, redova, kolona);
ispis(M, redova, kolona);

system("pause");
}

_________________________________________________________________


	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < k; j++)
		{
			cin >> X[i][j];
		}
	}
}
void ispis(int** X, int r, int k)
{
	for (int i = 0; i < r; i++)
	{
		for (int j = 0; j < k; j++)
		{
			cout << "  " << X[i][j] << "  ";
		}
		cout << endl;
	}
}
int suma(int** X, int r, int k)
{
	int s = 0;
	for (int i = 0; i < r; i++) 
	{ 
		for (int j = 0; j < k; j++)
			s += X[i][j];
	} 
	return s;
}
float prosjek(int** X, int r, int k)
{ 
	return suma(X, r, k)/ float(r*k);
}

void main()
{
	int redova, kolona;
	cout << "Unesite koliko redova i kolona zelite u matricu" << endl;
	cin >> redova >> kolona;
	int** matrica = new int*[redova];
	for (int i = 0; i < redova; i++)
	{
		matrica[i] = new int[kolona];
	}
	ucitaj(matrica, redova, kolona);
	ispis(matrica, redova, kolona);
	cout << suma(matrica, redova, kolona);
	cout << prosjek(matrica, redova, kolona);

	
	system("pause");
}

________________________________________________________________

/*
Zadatak 20 – Provjera znanja   **
Napravite program slijedeci navedene zahtjeve. Svi zahtjevi su povezani i predstavljaju jedan cijeli program.
Preporuka je da od koraka g svaku promjenu pokazivaca p1 i p2 skicirate.
a) deklarišite niz N tipa integer dužine 15 u statickoj memoriji 
b) deklarišite pokazivace p1 i p2 na integer(e) u jednoj liniji koda 
c) alocirajte niz u dinamickom memoriji dužine 19, i neka p1 pokazuje taj niz 
d) alocirajte niz u dinamickom memoriji dužine 12, i neka p2 pokazuje taj niz 
e) zamijenite pokazivace, neka p1 pokazuje na niz dužine 12, a p2 na niz dužine 19 
f) reciklirajte niz dužine 12 i ucinite da njegov pokazivac (p1) bude ,,bezopasan''
g) neka p1 pokazuje na elemenat niza sa indeksom 5 na koji pokazuje p2, kao na slici:
h) dodijelite neku (proizvoljnu) vrijednost elementu sa indeksom 5 dereferenciranjem p1 (pomocu operatora '*') 
i) udodijelite neku vrijednost element sa indeksom 5 dereferenciranjem njegove  izracunate adrese 
izrazom p2+5  (pomocu operatora '*') 
j) dodijelite neku vrijednost elementu sa indeksom 2  dereferenciranjem njegove izracunate 
adrese preko p2 (pomocu operatora '*')
k) dodijelite neku vrijednost elementu sa indeksom 2  dereferenciranjem njegove
izracunate adrese preko p1 (pomocu operatora '*')
l) ispišite vrijednost elementa sa indeksom 5 dereferenciranjem pokazivaca p1 (pomocu operatora '[ ]')
m) ispišite vrijednost elementa sa indeksom 5 dereferenciranjem pokazivaca p2 (pomocu operatora '[ ]') 
n) ispišite vrijednost elementa sa indeksom 2 dereferenciranjem pokazivaca p2 (pomocu operatora '[ ]') 
o) ispišite vrijednost elementa sa indeksom 2 dereferenciranjem pokazivaca p1 (pomocu operatora '[ ]')

p) reciklirajte dinamicki niz dužine 19
q) neka p1 pokazuje na prvi elemenat niza N (elemenat sa indeksom 0)
r) dodijelite neku vrijednost elementu sa indeksom 2  dereferenciranjem njegove 
izracunate adrese preko p1 (pomocu operatora '*') 
s) dodijelite neku vrijednost elementu sa indeksom 2  dereferenciranjem njegove
izracunate adrese preko N (pomocu operatora '*')
t) ispišite vrijednost elementa sa indeksom 2 dereferenciranjem pokazivaca p1 (pomocu operatora '[ ]')
u) ispišite vrijednost elementa sa indeksom 2 dereferenciranjem pokazivaca N  (pomocu operatora '[ ]')
*/

#include <iostream> 
using namespace std;

void main()
{
	const int velicina = 15;
	int niz[velicina];
	int* p1, *p2;
	p1 = new int[19];
	p2 = new int[12];
	int*ptemp = p1;
	p1 = p2;
	p2 = ptemp;
	delete[] p1;
	p1 = NULL;
	p1 = &p2[5];
	*p1 = 105;
	*(p2 + 5) = 111;
	*(p2 + 2) = 100;
	*(p1 - 3) = 99;
	cout << p1[0] << endl;
	cout << p2[5] << endl;
	cout << p2[2] << endl;
	cout << p1[0-3] << endl;
	delete[] p2;
	int N[10];
	p1 = N;
	*(p1 + 2) = 100;
	*(N + 2) = 200;
	cout << p1[2] << endl;
	cout << N[2] << endl;




	system("pause");
}

_____________________________________________________________________


/*
Zadatak 1: Napišite program u kojem cete: o Omoguciti korisniku da unese vrijednost N (broj clanova niza);
o Alocirati niz operacijom new (clanovi niza su tipa double);
o Omoguciti inicijalizaciju clanova niza unosom vrijednosti s tastature (koristiti funkciju);
o Izracunati i ispisati prosjecnu vrijednost elemenata niza (koristiti funkciju);
o Dealocirati memorijski blok upotrijebljen za kreiranje niza.
*/

#include <iostream> 
using namespace std;

void unos(double *pok,int v)
{
	for (int i = 0; i < v; i++)
	{
		cin >> pok[i];
	}
}
double prosjek(double *pok, int v)
{
	double suma = 0;
	for (int i = 0; i < v; i++)
	{
		suma += pok[i];
	}
	return suma / v;
}

void main()
{
	int N;
	cout << "Unesite broj clanova niza" << endl;
	cin >> N;
	double *pokazivac = new double[N];
	unos(pokazivac,N);
	cout << "Prosjek clanova niza je: " << prosjek(pokazivac, N) << endl;
	delete[] pokazivac;
	pokazivac = NULL;

	system("pause");
}

____________________________________________________________________

/*
Zadatak 4: Napišite program za zbrajanje dviju matrica (matrice A i matrice B)koji ce:
? omoguciti unos željene velicine matrica (broj redova i kolona),
? omoguciti unos vrijednosti elemenata matrica s tastature,
? kreirati trecu matricu ciji ce  elementi biti suma odgovarajucih elemenata matrica A i B, 
? dealocirajte dinamicki kreirane objekte, 
? koristite funkcije.
*/

#include <iostream> 
#include<iomanip>
using namespace std;

int redova, kolona;

void unos(int** matrica)
{
	for (int i = 0; i < redova; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			cout << i << "." << j << ". ";
			cin >> *(*(matrica + i) + j);
		}
	}
}
void suma_svih(int**matrica1,int** matrica2, int** matrica3)
{
	for (int i = 0; i < redova; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			matrica3[i][j] = matrica1[i][j] + matrica2[i][j];
		}
	}
}
void ispis(int** matrica)
{
	for (int i = 0; i < redova; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			cout << setw(3) << matrica[i][j] << setw(3);
		}
		cout << endl;
	}
}

void main()
{
	cout << "Unesite redove i kolone prve matrice" << endl;
	cin >> redova >> kolona;

	int** matrica1 = new int*[redova];
	for (int i = 0; i < redova; i++)
	{
		matrica1[i] = new int[kolona];
	}

	int** matrica2 = new int*[redova];
	for (int i = 0; i < redova; i++)
	{
		matrica2[i] = new int[kolona];
	}

	unos(matrica1);
	unos(matrica2);

	int** matrica3 = new int*[redova];
	for (int i = 0; i < redova; i++)
	{
		matrica3[i] = new int[kolona];
	}
	suma_svih(matrica1, matrica2, matrica3);
	ispis(matrica3);
	
	for (int i = 0; i < redova; i++)
	{
		delete[]matrica1[i];
		delete[]matrica2[i];
		delete[]matrica3[i];
	}
	delete[]matrica1;
	delete[]matrica2;
	delete[]matrica3;
	matrica1 = NULL;
	matrica2 = NULL;
	matrica3 = NULL;

	system("pause");
}

__________________________________________________________________________

	/*
	najbolji = NULL;
	int najbolja_ocjena = 0;
	int uslov = 0;
	char* pravi_predmet = NULL;
	for (int i = 0; i < niz[uslov].BrojacPolozenih; i++)
	{
		pravi_predmet = strstr(niz[uslov].PolozeniPredmeti[i].Naziv, NazivPredmeta);
		if (pravi_predmet == NULL)
			continue;
		else
		{
			if (niz[uslov].PolozeniPredmeti->Ocjena > najbolja_ocjena)
				najbolji = niz+uslov;
		}
	}
}

*/

________________________________________________________________________________


#include <iostream>
using namespace std;

void main()
{
	char* A = new char[20];
	cout << "Unesite Ime i Prezime" << endl;
	cin.getline(A,20);
	char B[20];
	cout << "Unesite mjesto stanovanja" << endl;
	cin.getline(B, 20);
	char* C = new char[40];
	strcpy_s(C,40, A);
	strcat_s(C,40, ", ");
	strcat_s(C,40, B);
	cout << C << endl;

	delete[] A;
	delete[] C;

	system("pause");
}

_________________________________________________________________


/*
Implementirajte funkciju dodaj_str koja ce prvom stringu dodati drugi string.
*/
#include <iostream>
using namespace std;

char* dodjeli_str(char* str1)
{
	char* x = new char[strlen(str1) + 1];
	strcpy_s(x, strlen(x), str1);
	return x;
}

void dodaj_str(char* str1,char* str2)
{
	int d1 = strlen(str1);
	int d2 = strlen(str2);
	char* W = new char[d1 + d2 + 1];
	strcpy_s(W, d1 + 1, str1);
	strcat_s(W,d1+d2+1, str2);
	cout << W << endl;
	delete[] W;
}
void main() 
{	
	 char* str1 = dodjeli_str("Prvi niz. ");
	 dodaj_str(str1, "Ovo je drugi niz");
	cout << str1 << endl; //ispis: "Prvi niz. Ovo je drugi niz." 
	delete [] str1;
	system("pause");
}

_______________________________________________________________________

#include <iostream>
using namespace std;  
char crt[] = "\n--------------------------------------------------\n";

void OslobodiMemoriju(char * &tekst) 
{ 
	//dealocirati tekst 
	delete[] tekst;
} 
void Informacije(char * tekst) 
{ 
	int razmaci = 0, brojevi = 0, velika = 0, mala = 0, interpunkcijski = 0; 
	int velicina = strlen(tekst);
	for (int i = 0; i <velicina ; i++)
	{
		if (isspace(tekst[i]))
			razmaci++;
		else if (isdigit (tekst[i]))
			brojevi++;
		else if (isupper(tekst[i]))
			velika++;
		else if (islower(tekst[i]))
			mala++;
		else if (ispunct(tekst[i]))
			interpunkcijski++;
	}
	cout << crt << "\t\t::INFO::" << crt; 
	cout << crt << "Tekst: " << tekst << crt; 
	cout << "Niz ima " << strlen(tekst) << " karaktera." << crt;
	cout << "Razmaka: \t\t\t" << razmaci << endl;
	cout << "Brojeva: \t\t\t" << brojevi << endl;
	cout << "Velikih slova: \t\t\t" << velika << endl;
	cout << "Malih slova: \t\t\t" << mala << endl;
	cout << "Interpunkcijskih znakova: \t" << interpunkcijski;
	cout << crt << "Info: Informacije prikazane...." << crt;
}   
void DodajTekst(char * &tekst) 
{ 
	//stari tekst + razmak + novi tekst 
	int velicina = strlen(tekst);
	char* novi = new char[500 - velicina+1];
	cout << "Unesite novi tekxt i zavrsite sa znakom # " << endl;
	cin.get(novi, 500 - velicina+1, '#');
	cin.ignore(100,'\n');
	strcat_s(tekst, 500 - velicina + 1, " ");
	strcat_s(tekst, 500 - velicina + 1, novi);
	OslobodiMemoriju(novi);

}  
	void Pretraga(char * tekst) 
	{
		char *pretraga = new char[20];
		cout << "Unesite rijec kako bi mogli pretraziti" << endl;
		cin.getline(pretraga,20);
		cin.ignore();
		char* pok=strstr(tekst, pretraga);
		if (pok == NULL)
			cout << "Trazena rijec ne postoji u tekstu" << endl;
		else{
			cout << "Trazena rijec postoji u tekstu" << endl;
			cout << "Nakjon unesene rijeci postoji sljedeci tekst "<<pok << endl;

		}
		OslobodiMemoriju(pretraga);


	}  
	void UnosTeksta(char *& tekst)
	{
		tekst = new char[500];
		
		cout << "Unesite text. Zavrsavate sa znakom # " << endl;
		cin.get(tekst, 500, '#');
		cin.ignore();
	}  
		int PrikaziMeni()
		{
				int izbor = 1; 
				do
				{ 
				cout << crt << "\t\t::MENI::" << crt; 
				cout << "1. Unos novog teksta" << endl;
				cout << "2. Dodavanje teksta" << endl; 
				cout << "3. Informacije o tekstu" << endl;
				cout << "4. Pretraga" << endl;  
				cout << "5. Zatvori editor" << endl; 
				cout << "Unesite vas izbor: "; 
				cin >> izbor;  
				cin.ignore(); 
				system("cls");
				} while (izbor < 1 || izbor>5); 
				return izbor;
			}
		void main() 
			{
				int izbor = 0;  
				char * tekst = NULL;
				do 
				{ 
					cout << crt << "\t\t::TEKST EDITOR::"; 
					izbor = PrikaziMeni();  
					switch (izbor)
					{
					case 1:		UnosTeksta(tekst); break; 
					case 2:    DodajTekst(tekst); break;  
					case 3:    Informacije(tekst); break;  
					case 4:    Pretraga(tekst); break;
					}   
					system("pause>0");
					system("cls");
				} while (izbor != 5); 
				if (tekst != NULL)
					OslobodiMemoriju(tekst);
				cout << crt;
			}

__________________________________________________________

#include <iostream>
using namespace std;  

void unos(int**matrica, int red, int kolona)
{
	for (int i = 0; i < red; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			cin >> matrica[i][j];
		}
	}
}
void ispis(int**matrica, int red, int kolona)
{
	for (int i = 0; i < red; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			cout << matrica[i][j];
		}
		cout << endl;
	}
}

	
void main()
{
	int red, kolona;
	cout << "Unesite koliko redova i kolona" << endl;
	cin >> red >> kolona;

	int **matrica1 = new int*[red];
	for (int i = 0; i < red; i++)
	{
		matrica1[i] = new int[kolona];
	}
	


	int** matrica2 = new int*[red];
	for (int i = 0; i < red; i++)
	{
		matrica2[i] = new int[kolona];
	}

	unos(matrica1, red, kolona);
	ispis(matrica1, red, kolona);

	unos(matrica2, red, kolona);
	ispis(matrica2, red, kolona);

	for (int i = 0; i < red; i++)
	{
		delete[] matrica1[i];
		delete[] matrica2[i];
	}
	delete[] matrica1;
	delete[] matrica2;
	matrica1 = NULL;
	matrica2 = NULL;


	system("pause");
}

_______________________________________________________________________

/*
• kreirajte dinamicki niz objekata tipa radnik od onoliko clanova koliko želi korisnik;
struct radnik
{
int ib;
char ime[10];
char prezime[10];
double dohodak[12];
int staz;
char spol[10];
};
• kreirati funkciju za unos obilježja za sve objekte: void unos(radnik *, int);
• kreirati funkciju za ispis obilježja jednog objekta: void ispis(radnik *);
• kreirati funkciju koja ce prebrojati koliko radnika su žene:   int prebroji_zene(radnik *, int);
• kreirati novi niz u dinamickoj memoriji;
• kreirati funkciju u kojoj cete kopirati sve žene u novonapravljeni niz kopirati sve žene:
void kopiraj_zene(radnik *, radnik *, int);
• kreirati funkciju koja ce pronaci i vratiti radnika s najdužim prezimenom:   radnik * najduze_ime(radnik *, int);
• kreirati funkciju koja ce vršiti pretragu radnika po imenu, te ispisati sva obilježja radnika za koje je utvrdeno da
imaju traženo ime:   void pretraga_po_imenu(radnik *, char *, int);
• kreirati funkciju koja ce izracunati godišnje prihode za izabranog radnika:   double prihodi(radnik *, int, int);
radnika se bira preko IB-a radnika, a prihodi se racunaju tako da sve zbroje dohoci za 12 mjeseci + 6% za svaku godinu staža;
*/
#include <iostream>
using namespace std;  

struct radnik
{
	int ib;
	char ime[10];
	char prezime[10];
	double dohodak[12];
	int staz;
	char spol[10];
};
void unosdohodak(double* niz, int velicina)
{
	for (int i = 0; i < velicina; i++)
	{
		cout << "Mjesec: " << i + 1;
		cin >> niz[i];
	}
}
	
void unos(radnik * niz, int velicina)
{
	for (int i= 0; i < velicina; i++)
	{
		cout << i << "radnik: ib: ";
		cin >> niz[i].ib;
		cin.ignore();
		cout << i << "radnik: ime: ";
		cin.getline(niz[i].ime, 10);
		cout << i << "radnik: prezime: ";
		cin.getline(niz[i].prezime, 10);
		unosdohodak(niz[i].dohodak, 12);
		cout << i << "radnik: staz: ";
		cin >> niz[i].staz;
		cin.ignore();
		cout << i << "radnik: spol: ";
		cin.getline(niz[i].spol, 10);
	}
}
int prebroji_zene(radnik *niz, int velicina)
{
	int brojac = 0;
	for (int i = 0; i < velicina; i++)
	{
		if(strcmp(niz[i].spol,"zensko")==0)
			brojac++;
	}
	return brojac;
}
void ispis(radnik* radnik)
{
	cout << "radnik: ib: ";
	cout << radnik->ib << endl;
	cout <<"radnik: ime: ";
	cout << radnik->ime << endl;
	cout <<"radnik: prezime: ";
	cout << radnik->prezime << endl;
	cout << "Mjesecni dohodak: " << endl;
	for (int i = 0; i < 12; i++)
	{
		cout << i + 1 << " Mjesec: ";
		cout << radnik->dohodak[i] << endl;
	}
	cout <<"radnik: staz: ";
	cout << radnik->staz << endl;
	cout <<"radnik: spol: ";
	cout << radnik->spol << endl;
}
void kopiraj_zene(radnik *niz, radnik *noviniz, int velicina)
{
	int brojac = 0;
	for (int i = 0; i < velicina; i++)
	{
		if (strcmp(niz[i].spol,"zensko") == 0)
		{
			noviniz[brojac] = niz[i];
			brojac++;
		}
	}
}
radnik * najduze_ime(radnik *niz, int velicina)
{
	radnik* najduzi = niz+0;
	for (int i = 1; i < velicina; i++)
	{
		if (strlen(niz[i].prezime) > strlen(najduzi->prezime))
			najduzi = niz + i;
	}
	return najduzi;
}
void pretraga_po_imenu(radnik *niz, char *ime, int velicina)
{
	for (int i = 0; i < velicina; i++)
	{
		if (strcmp(niz[i].ime, ime) == 0)
			ispis(niz+i);
	}
}
double prihodi(radnik *niz, int ident, int velicina)
{
	double suma = 0;
	int rbradnika;
	for (int i = 0; i < velicina; i++)
	{
		if (ident == niz[i].ib)
			rbradnika = i;
			for (int j = 0; j < 12; j++)
			{
				suma += niz[i].dohodak[j] + niz[i].dohodak[j] * 0.06;
			}
	}
	return suma;
}
void main()
{
	int velicina;
	cout << "Unesite koliko zelite radnika" << endl;
	cin >> velicina;
	radnik* radnici = new radnik[velicina];
	unos(radnici, velicina);
	cout << "Unesite kojeg radnika zelite da iuspisete: " << endl;
	int radnikizniza;
	cin >> radnikizniza;
	ispis(&radnici[radnikizniza]);
	cout << "Zena u nizu ima: " << prebroji_zene(radnici, velicina) << endl;
	int brojzena = prebroji_zene(radnici, velicina);

	radnik* noviniz = new radnik[brojzena];
	cout << "Najduze prezime" << endl;
	radnik* najduzeprezime = najduze_ime(radnici, velicina);
	ispis(najduzeprezime);
	cout << "Unesite ime kako bi pretrazili i ispisali sve podatke o toj osobi" << endl;
	char* ime=new char[10];
	cin.ignore();
	cin.getline(ime, 10);
	pretraga_po_imenu(radnici, ime, velicina);
	cout << endl;
	cout << "Unesite IB radnika kako bi izracunali godisnji prihod" << endl;
	int identifikator;
	cin >> identifikator;
	double prihodiradnika;
	prihodiradnika = prihodi(radnici, identifikator, velicina);
	cout << "godisnji prohodi radnika sa ib-eom"<<identifikator<<" su: " << prihodiradnika << endl;

	system("pause");
}

_______________________________________________________________________________________


#include<iostream>
#include<iomanip>
using namespace std;
struct ucenik{
	char ime_prezime[15];
	int jmbg[13];
	int ocjene[7];
	char spol;
	void unos();
	void ispis();
};
void ucenik::unos()
{
	
		cout << "Ime i Prezime: ";
		cin.ignore();
		cin.getline(ime_prezime,15);
		for (int j = 0; j < 13; j++)
		{
			cout << "JMBG: " << j+1;
			cin >>jmbg[j];
		}
		for (int j = 0; j < 7; j++)
		{
			cout << "Ocjena:" << j + 1;
			cin >>ocjene[j];
		}
		cin.ignore();
		cout << "prvo slovo spola: ";
		cin >> spol;
}
void ucenik::ispis()
{
	cout << "Ime i prezime: ";
	cout << ime_prezime << endl;
	cout << "JMBG: ";
	for (int i = 0; i < 13; i++)
	{
		cout << jmbg[i];
	}
	cout << endl;
	cout << "Ocjene: " << endl;
	for (int i = 0; i < 7; i++)
	{
		cout << setw(2) << ocjene[i] << setw(2);
	}
	cout << endl;
	cout << "Spol: ";
	cout << spol << endl;
}

float prosjecna(int* neko)
{
	float suma = 0;
	for (int i = 0; i < 7; i++)
	{
		suma += neko[i];
	}
	suma /= 7;
	return suma;
}

ucenik* maxprosjecna(ucenik* niz, int velicina)
{
	ucenik*najbolji = &niz[0];
	float maximprosjecna;
	float pom = 0;
	for (int i = 0; i < velicina; i++)
	{
		maximprosjecna = prosjecna(niz[i].ocjene);
		if (maximprosjecna > pom)
		{
			pom = maximprosjecna;
			najbolji = &niz[i];
		}
	}
	return najbolji;
}

ucenik* minprosjecna(ucenik* niz, int velicina)
{
	ucenik*najgori = &niz[0];
	int minprosjecna;
	float pom = 10;
	for (int i = 0; i < velicina; i++)
	float pom = 0;
	for (int i = 0; i < velicina; i++)
	{
		minprosjecna = prosjecna(niz[i].ocjene);
		if (minprosjecna < pom)
		{
			pom = minprosjecna;
			najgori = &niz[i];
		}
	}
	return najgori;
}


int broj_1(ucenik*niz, int velicina)
{
	int brojac = 0;
	for (int i = 0; i < velicina; i++)
	{
		if (niz[i].spol == 'z' || niz[i].spol == 'Z')
			brojac++;
	}
	return brojac;
}


int broj_2(int zena, int velicina)
{
	int muskih = velicina - zena;
	return muskih;
}


void main()
{
	int velicina;
	cout << "Unesite koliko ucenika zelite unijeti" << endl;
	cin >> velicina;
	ucenik* pok = new ucenik[velicina];
	for (int i = 0; i < velicina; i++)
	{
		pok[i].unos();
	}
	cout << endl;
	cout << "Ucenik sa najboljim prosjekom ocjena" << endl;
	ucenik* najucenik = maxprosjecna(pok, velicina);
	najucenik->ispis();
	cout << "Ucenik sa najlosijim prosjekom ocjena:" << endl;
	cout << endl;
	ucenik* najlosijiucenik = minprosjecna(pok, velicina);
	najlosijiucenik->ispis();
	cout << endl;
	cout << "Zena ima:";
	int zena = broj_1(pok, velicina);
	cout << zena << endl;
	int muskaraca = broj_2(zena, velicina);
	cout << "Muskaraca ima: " << muskaraca << endl;
	system("pause");
}

____________________________________________________________


#include <iostream>
using namespace std;

char crt[]="\n===============================================\n";  

struct Student{
	int _brojIndeksa;
	char _imePrezime[30];
}; 
//prefiks 'e' smo dodali kao znak za clanove enumeracije 
enum TipPodatka{ eStudent, eInteger, eBool, eFloat };  
struct Struktura{
	//na osnovu vrijednosti atributa _Tip znamo koji od atributa unije je 
	//inicijalizovan, te samim tim eliminisemo mogucnost pojave/koristenja 
	//neocekivanih vrijedosti  
	TipPodatka _Tip; 
	union{ 
		int _Integer;
		bool _Bool; 
		float _Float;
		Student _Student;
	};
}; 
	
		void Ispis(const Struktura & objekat)
		{ 
			//na osnovu vrijednosti atributa _Tip ispisujemo vrijednost odgovarajuceg
			//atributa unije  
			switch(objekat._Tip)
			{
			case eBool: 
				cout<<"Bool atribut: "<<objekat._Bool<<endl; break; 
			case eInteger: 
				cout<<"Integer atribut: "<<objekat._Integer<<endl; break;
			case eFloat:
				cout<<"Float atribut: "<<objekat._Float<<endl; break;
			case eStudent: 
				cout<<"Indeks: "<<objekat._Student._brojIndeksa; 
				cout<<" Ime: "<<objekat._Student._imePrezime<<endl;   break; 
			}
		}
		void Unos(Struktura & objekat)
		{ 
			TipPodatka tip; 
			int unos; 
			do{   
				cout<<"Odaberite tip podatka (1.Student,2.Integer,3.Bool,4.Float): "; 
				cin>>unos;
				--unos; 
				// Pitanje: zasto smo umanjili unos? Sta trebamo napraviti da 
				//bismo eliminisali potrebu umanjivanja unosa?  
				tip = (TipPodatka)unos;
			}while(tip!=eStudent && tip!=eInteger && tip!=eBool && tip!=eFloat);
		objekat._Tip = tip;
		//nakon ispravnog unosa, inicijalizujemo atribut _Tip tj.
		//oznacavamo koji atribut unije koristimo. Nakon toga, vrsimo unos vrijednosti 
		//Pitanje: Zasto nismo izvrsili casting? 
		switch(objekat._Tip)
		{ 
		case eBool: 
			cout<<"Bool unos (0.False, 1.True): ";  
			cin>>objekat._Bool; 
			break;
		case eInteger: 
			cout<<"Integer unos: ";  
			cin>>objekat._Integer; 
			break; 
		case eFloat: 
			cout<<"Float unos: "; 
			cin>>objekat._Float; 
			break;
		case eStudent: 
			cout<<"Student\nBroj indeksa: ";
			cin>>objekat._Student._brojIndeksa;
			cin.ignore();
			cout<<"Ime i prezime: ";
			cin.getline(objekat._Student._imePrezime,30); 
			break; 
		}
		} 
		void main()
		{ 
			Struktura objekat; 
			int brojac=4; //testirajte sve tipove clanove enumeracije
			do{
				Unos(objekat); 
				Ispis(objekat);
			}while(--brojac>0);
		}

________________________________________________________________________



#include <iostream>
#include <fstream>
using namespace std;

char * crt ="\n========================================\n"; 
enum NacinStudiranja{ REDOVAN, DL };
enum GodinaStudija{ PRVA = 1, DRUGA, TRECA, CETVRTA };
enum Odgovori{ TACNO, NETACNO };
const int pitanjaBroj = 20;
struct Student
{
	int _brojIndeksa;
	char _imePrezime[30];
	bool _radioTest; 
	NacinStudiranja _nacin;
	GodinaStudija _godina; 
	Odgovori _odgovori[pitanjaBroj];
};

void PrikaziPitanje(char* pitanje)
{
	
	cout << crt << pitanje << crt;

}
void unosTacnihOdgovora(int &odgovor)
{
	int unos;

			cout << "Unesite tacan odgovor na pitanje(1.TACNO, 2. NETACNO)" << endl;
			cin >> unos;
			odgovor = --unos;
}
Odgovori GetTacanOdgovor(int odgovoriNaPitanja)
{
	
			if (odgovoriNaPitanja == 0)
				return TACNO;
			return NETACNO;
}
int GetUspjehStudenta(Odgovori odgovori[],int pitanjaBroj, int odgovoriNaPitanja[])
{ 
	int brojacTacnih = 0; 
	for (int i = 0; i < pitanjaBroj; i++)
		if (odgovori[i] == (Odgovori)GetTacanOdgovor(odgovoriNaPitanja[i]))
			brojacTacnih++;  
	return brojacTacnih;
}
void PokreniTest(Student & student,char **pitanja, int pitanjaBroj)
{
	int unos; 
	Odgovori temp;
	for (int i = 0; i<pitanjaBroj; i++)
	{
		do{ 
			PrikaziPitanje(pitanja[i]); 
			cout << "Odgovor (1.Tacno,2.Netacno): ";
			cin >> unos; 
			unos--; 
			temp = (Odgovori)unos; 
		} 
		while (temp != TACNO && temp != NETACNO);
		student._odgovori[i] = temp;
	} 
	student._radioTest = true;
}
void UnosPodataka(Student * niz, int max)
{
	int unos;
	for (int i = 0; i<max; i++)
	{
		cout << crt << "\t::STUDENT " << i + 1 << "::" << crt; 
		cout << "Unesite ime i prezime: "; 
		cin.getline(niz[i]._imePrezime, 30); 
		cout << "Unesite broj indeksa: "; 
		cin >> niz[i]._brojIndeksa; 
		cout << "Nacin studiranja (1.Redovan, 2.DL): ";
		cin >> unos; 
		niz[i]._nacin = (NacinStudiranja)--unos; 
		cout << "Nacin godinu studija (1,2,3,4): ";  
		cin >> unos;  
		niz[i]._godina = (GodinaStudija)unos;   
		cin.ignore();  
		niz[i]._radioTest = false;//tek smo kreirali studenta  
		//tako da je sigurno da test nije radjen  
	}
}  
		void Pretraga(Student * niz, int max)
		{ 
			//definisati funkciju(e) koja(e) ce omoguciti pretragu po: 
			//1. godini studija 
			//2. nacinu studiranja 
			//3. rezultatima ostvarenim na testu 
			//Nove funkcionalnosti dodati u funkciju PrikaziMeni 
		}
		int PrikaziMeni()
		{  
			int izbor;
			do{ 
				cout<<crt<<"\t::MENI::"<<crt; 
				cout<<"1. Pokreni test"<<endl; 
				cout<<"2. Prikazi rezultate"<<endl; 
				cout << "3. Dodavanje novih pitanja(samo admin)" << endl;
				cout << "4. Kraj rada" << endl;
				cout << "5. ponovi test(samo admin)" << crt;
				cout<<"Unesite izbor: ";  
				cin>>izbor;
			}while(izbor<1 || izbor>6); 
			return izbor;
		} 
		int PrikaziStudente(Student * niz, int max)
		{  
			int rb; 
			do{  
				for(int i=0;i<max;i++)
					cout<<i+1<<". "<<niz[i]._imePrezime<<endl;  
				cout<<crt<<"Unesite redni broj studenta: ";
				cin>>rb; 
			}while(rb<1 || rb>max);
			return rb-1;
		}  

		void dodaj_pitanje(char ** &pitanja,int &pitanjaBroj,int odgovoriNaPitanja[])
		{
			char slovo;
			do{
				pitanja[pitanjaBroj] = new char[100];
				cout << "Unesite pitanje broj: " << pitanjaBroj+1 << endl;
				cin.getline(pitanja[pitanjaBroj], 99);
				cout << "Unesite tacan ili netacan odgovor na ovo pitanje."<<endl;
				unosTacnihOdgovora(odgovoriNaPitanja[pitanjaBroj]);
				pitanjaBroj++;

				cout << "Da li zelite unijeti jos? D ili N" << endl;
				cin >> slovo;
				cin.ignore();
			} while (slovo == 'D'||slovo =='d');

		}
		void OmoguciPonovo(Student & student)
		{
				student._radioTest = false;
			cout << "Uspjesno ste onogucili studentu " << student._imePrezime << " ponovni rad testa" << endl;
		}


			//dodati sljedece funkcionalnosti:
		//1.administratoru omoguciti da unosi pitanja te definise tacne odgovore
		//2.administratoru dati prava da studentu ponovo omoguci polaganje testa 
		//3.uvesti username/password na osnovu koga ce se studenti logirati
		//4.odvojiti administratorske funkcije (meni) od korisnickih  
			void main()
			{
				int odgovoriNaPitanja[20];
				int max, izbor, student, pitanjaBroj = 0;
				cout << "Unesite broj studenata: ";
				cin >> max;
				cin.ignore(); 
				Student * niz = new Student[max]; 
				char** pitanja = new char*[pitanjaBroj];
				char *sifra = { "admin" };
				char *input = new char[10];
				UnosPodataka(niz, max); 
				student = PrikaziStudente(niz, max);
				system("cls");
				do{
					izbor = PrikaziMeni(); 
					switch (izbor)
					{

					case 4: break;
						//pokusajte pojednostaviti naredni dio koda, te smanjiti broj nepotrebnih provjera 
					case 1:
						{
							if (niz[student]._radioTest == false)
								PokreniTest(niz[student], pitanja, pitanjaBroj);
							else
								cout << "Student " << niz[student]._imePrezime << " je vec radio test!" << endl;
						}
						break;
					case 2:
						{
							if (niz[student]._radioTest == true)
							{
								int brojTacnih = GetUspjehStudenta(niz[student]._odgovori, pitanjaBroj, odgovoriNaPitanja);
								cout << crt << "Uspjeh studenta " << brojTacnih << "/" << pitanjaBroj << " ili " << (brojTacnih*100.0) / pitanjaBroj << "%" << crt;
							}
							else
								cout << "Student " << niz[student]._imePrezime << " jos uvijek nije radio test!" << endl;
						}
						break;
					case 3:
						{
							cout << "Unesite administratorsku sifru: " << endl;
							cin.ignore();
							cin.getline(input, 10);
							if (strcmp(input, sifra) == 0)
								dodaj_pitanje(pitanja, pitanjaBroj, odgovoriNaPitanja);
							else
								cout << "greska.Neispravna sifra" << endl;
						}
						break;
					case 5:
						{
							cout << "Unesite administratorsku sifru" << endl;
							cin.ignore();
							cin.getline(input, 10);
							if (strcmp(input, sifra) == 0){
								int unos;
								cout << "Unesite rb studenta kako bi mu ponovo omogucili rad testa" << endl;
								cin >> unos;
								unos--;
								OmoguciPonovo(niz[unos]);

							}
							else
								cout << "greske. Neispravna administratoirska sifra" << endl;
						}
						break;
					default: cout << "Unesite ponovo izbor" << endl;
					}
					system("pause>0"); 
					system("cls");
				} while (1);
				delete[] niz;
				niz = NULL;
				system("pause");
			}

_____________________________________________________________________________


#include<iostream>
using namespace std;
char crt[] = "\n======================================================\n";


enum VrstaVozila{ PUTNICKO, TERETNO };
struct Datum{ 
	int _dan, _mjesec, _godina; 
	void Unos(); 
	void Prikazi();
};
struct Vozilo{
	char _regOznaka[10]; 
	char * _markaTip;
	int _godinaProizvodnje;  
	Datum _registrovanDO; //objekat druge strukture 
	VrstaVozila _vrsta; //enumeracija 
	void Unos();
	void Prikazi(); 
	void Dealociraj();
};
struct Vlasnik{ 
	char * _imePrezime;
	char _JMBG[14]; 
	Datum _datumRodjenja; //objekat druge strukture  
	//niz od 10 pokazivaca na objekte tipa Vozilo 
	Vozilo * _vozila[10];//predpostavimo da po zakonu vlasnik ne smije imati vise
	//od 10 vozila
	int _brojacVozila; //brojac nam govori koliko vozila vlasnik posjeduje  
	void Unos();  
	void Prikazi();
	void DodajVozilo();//dodaje podatke o novom vozilu,onemoguciti dupliranje 
	void UkloniVozilo();//uklanja vozilo sa liste  
	Vozilo * GetVozilo(char * regOznaka);//vraca pokazivac na vozilo koje ima 
	//trazenu registarsku oznaku. Ukoliko vozilo ne postoji, funkcija vraca nullptr 
	void Dealociraj(); 
}; 
int PrikaziMeni()
{
	int izbor = 1;
	do{
		cout << crt << "\t\t::MENI::" << crt;
		cout << "1.Unos novih podataka o vlasnicima." << endl;
		cout << "2.Prikazi listu unesenih podataka." << endl;
		cout << "3.Pretraga po registarskoj oznaci." << endl;
		cout << "4.Pretraga po vlasniku vozila(PUNO IME I PREZIME)." << endl;
		cout << "5.Pretraga po vlasniku vozila(IME ILI PREZIME)." << endl;
		cout << "6.Napravi izmjene na podacima." << endl;
		cout << "7.Kraj rada." << crt;
		cout << "Unesite vas izbor: ";
		cin >> izbor;
		cin.ignore();
		system("cls");
	} while (izbor<1 || izbor>7);
	return izbor;
}
void unosNovihPodataka(Vlasnik* vlasnici,int &uneseno,int max )
{
	if (uneseno < max)
	{
		vlasnici[uneseno].Unos();
		uneseno++;
	}
	else
		cout << "Unijeli ste sve vlasnike" << endl;
}
void Vlasnik::Unos()
{
	char temp[30];
	cout << "Ime i prezime: ";
	cin.getline(temp, 29);
	int velicina = strlen(temp) + 1;
	_imePrezime = new char[velicina];
	strcpy_s(_imePrezime, velicina, temp);
	cout << "JMBG ";
	cin.getline(_JMBG, 14);
	_datumRodjenja.Unos();
	cout << "Da li vlasnik ima vozila u vlasnistvu? Unesite D ili d " << endl;
	char slovo;
	cin >> slovo;

	if (slovo == 'D' || slovo == 'd'){
		do
		{
			cout << "Unesite "<<_brojacVozila<<" vozilo" << endl;
			if (_brojacVozila < 10){
				_vozila[_brojacVozila]->Unos();
				_brojacVozila++;
			}
			else
				cout << "Unijeli ste sva auta. " << endl;
			cout << "Da li zelite unositi jos auta? ";
			cin >> slovo;
		} while (slovo == 'D' || slovo == 'd');
	}

	
}
void Datum::Unos()
{
	cout << "Dan: ";
	cin >> _dan;
	cout << " Mjesec: ";
	cin >> _mjesec;
	cin >> " Godina: ";
	cin >> _godina;
}
void Vozilo::Unos()
{
	char temp[20];
	int vrsta;
	cout << "Unesite registarske oznake: ";
	cin.getline(_regOznaka, 9);
	cout << "Unesite marku automobila ";
	cin.getline(temp, 19);
	int velicina=strlen(temp) + 1;
	_markaTip = new char[velicina];
	strcpy_s(_markaTip, velicina, temp);
	cout << "Godina proizvodnje: ";
	cin >> _godinaProizvodnje;
	cout << "registrovan do: ";
	_registrovanDO.Unos();
	cout << "Vrsta vozila. (1. PUTNOCKO, 2.TERETNO) ";
	cin >> vrsta;
	vrsta--;
	_vrsta = (VrstaVozila)vrsta;
}
void prikaziPodatkeDetaljno(Vlasnik* vlasnici,int uneseno)
{
	int izbor = 0;
	for (int i = 0; i < uneseno; i++)
	{
		cout << "Ime i Prezime: "<<i <<" : "<< vlasnici[i]._imePrezime << endl;
	}
	char slovo;
	cout << "Da li zelite podatke detaljno onekom vlasniku? D ili N" << endl;
	cin >> slovo;
	if (slovo == 'D' || slovo == 'd'){
		do
		{
			cout << "Unesite RB vlasnika kojeg zelite detaljno" << endl;
			cin >> izbor;
			izbor;
		} while (izbor<0 || izbor>uneseno);
		vlasnici[izbor].Prikazi();
	}


}
void Vlasnik::Prikazi()
{
	cout << "Ime i prezime: ";
	cout << _imePrezime;
	cout << "JMBG ";
	cout << _JMBG;
	cout << "Datum rodjenja: " << endl;
	_datumRodjenja.Prikazi();
	cout << "stanje vozila " << endl;
	for (int i = 0; i < _brojacVozila; i++)
	{
		_vozila[i]->Prikazi();
	}


}
void Datum::Prikazi()
{
	cout << _dan << "/" << _mjesec << "/" << _godina << endl;
}
void Vozilo::Prikazi()
{
	
	
	cout << "registarske oznake: ";
	cout << _regOznaka << endl;
	cout << "marka automobila ";
	cout << _markaTip << endl;
	cout << "Godina proizvodnje: ";
	cout << _godinaProizvodnje;
	cout << "registrovan do: ";
	_registrovanDO.Prikazi();
	cout << "Vrsta vozila. (1. PUTNOCKO, 2.TERETNO) ";
	cout << _vrsta << endl;
}
void pretragaPoRegOznaci(Vlasnik *vlasnici, int uneseno)
{
	Vozilo *trazeno;
	char temp[10];
	cout << "Unesite reg oznaku:" << endl;
	cin.getline(temp, 9);
	for (int i = 0; i < uneseno; i++)
	{
		vlasnici[i].GetVozilo(temp)->Prikazi();
	}
	cout << "Trazeno vozilo po registraciji je: " << endl;
	
}
Vozilo* Vlasnik::GetVozilo(char* regOznaka)
{
	Vozilo* trazeno;
	for (int i = 0; i < _brojacVozila; i++)
	{
		if (strcmp(regOznaka, _vozila[i]->_regOznaka) == 0){
			trazeno = _vozila[i];
			return trazeno;
		}
	}
	return nullptr;
}
void pretragaPoVlasniku(Vlasnik *vlasnici, int uneseno)
{
	bool pronadjen = false;
	char IiP[30];
	cout << "Unesite ime i prezime kako bismo ispisali vlasnika: " << endl;
	cin.getline(IiP, 29);
	for (int i = 0; i < uneseno; i++)
	{
		if (strcmp(vlasnici[i]._imePrezime, IiP) == 0){
			vlasnici[i].Prikazi();
			pronadjen = true;
		}
	}
	if (pronadjen == false)
		cout << "trazeni vlasnik ne postoji u bazi!" << endl;
}
void pretragaPoVlasnikuImeILIPrezime(Vlasnik* vlasnici, int uneseno)
{
	char*pok = NULL;
	char temp[20];
	cout << "Unesite ime ili prezime vlasnika:" << endl;
	cin.getline(temp, 19);
	for (int i = 0; i < uneseno; i++)
	{
		if (strstr(temp, vlasnici[i]._imePrezime) != NULL)
			vlasnici[i].Prikazi();
	}
	if (pok == NULL)
		cout << "Trazeni vlasnik ne postoji u bazi!"<<endl;
}
int prikaziListuPodataka(Vlasnik * vlasnici, int uneseno)
{
	int izbor;
	for (int i = 0; i < uneseno; i++)
	{
		cout << "Vlasnik:" << i + 1;
		vlasnici[i]._imePrezime;
	}
	do
	{
		cout << "Unesite izbor vlasnika gdje zelite napraviti izmjene:" << endl;
		cin >> izbor;
		cin.ignore();
		izbor--;
	} while (izbor>=0 || izbor <=uneseno);
	return izbor;
	
}

void izmjeneNaPodacima(Vlasnik* vlasnici, int uneseno)
{
	char slovo;
	int izbor = prikaziListuPodataka(vlasnici, uneseno);
	cout << "ako zelite dodati vozilo pritisnite D ili d:" << endl;
	if (slovo == 'd' || slovo == 'D'){
		vlasnici[izbor].DodajVozilo();
	}
	cout << "Ako zelite uklonuti vozilo pritisnite D ili d" << endl;
	cin >> slovo;
	if (slovo == 'd' || slovo == 'D'){
		vlasnici[izbor].UkloniVozilo();
	}
	

}
void Vlasnik::DodajVozilo()
{
	_vozila[_brojacVozila]->Unos();
}

void Vlasnik::UkloniVozilo()
{
	int rb;
	for (int i = 0; i < _brojacVozila; i++)
	{
		cout << "Vozilo: " << i + 1;
		_vozila[i]->Prikazi();
	}
	cout << "unesite rb vozila kojeg zelite izbrisati" << endl;
	cin >> rb;
	if (rb >= 0 || rb <= _brojacVozila){
		_vozila[rb]->Dealociraj();
		_vozila[rb] = nullptr;
	}
	_vozila[rb] = _vozila[_brojacVozila];
	_vozila[_brojacVozila]->Dealociraj();
	_vozila[_brojacVozila] = nullptr;
	_brojacVozila--;
}

void Vozilo::Dealociraj()
{
	delete[] _markaTip;
}

void Dealokacija(Vlasnik *& vlasnici, int uneseno)
{
	for (int i = 0; i < uneseno; i++)
	{
		vlasnici[i].Dealociraj();
	}
	vlasnici->_imePrezime = nullptr;


	for (int i = 0; i < uneseno; i++)
	{
		for (int j = 0; j < vlasnici[i]._brojacVozila; j++)
		{
			vlasnici[i]._vozila[j]->Dealociraj();
		}
	}
}
void Vlasnik::Dealociraj()
{
	delete[] _imePrezime;
}

void main()
{
	int max;
	int uneseno = 0;
	int izbor;
	cout << "Unesite koliko vlasnika zelite" << endl;
	cin >> max;
	Vlasnik* vlasnici = new Vlasnik[max];
	do{
		cout << crt << "\t\t::EVIDENCIJA VLASNIKA::" << crt;
		izbor = PrikaziMeni();
		switch (izbor)
		{
		case 1:     unosNovihPodataka(vlasnici, uneseno, max); break;
		case 2:		prikaziPodatkeDetaljno(vlasnici, uneseno); break;
		case 3:     pretragaPoRegOznaci(vlasnici, uneseno); break;
		case 4:     pretragaPoVlasniku(vlasnici, uneseno); break;
		case 5:     pretragaPoVlasnikuImeILIPrezime(vlasnici, uneseno); break;
		case 6:     izmjeneNaPodacima(vlasnici, uneseno); break;
		
		}
	} while (izbor>0 || izbor<7);

	Dealokacija(vlasnici, uneseno);
	system("pause");
}


________________________________________________________________________

#include<iostream>
using namespace std;
char * crt = "\n---------------------------\n";
int ODG;

enum VrstaRacuna { TEKUCI, DEVIZNI, STEDNI };
enum VrstaTransakcije { UPLATA, ISPLATA };

struct Datum {
	int _dan, _mjesec, _godina;
	/*	Unos / Ispis */
};

struct Transakcija {
	char _TO[20];
	float _iznos;
	VrstaTransakcije _vrstaTransakcije; // ako je isplata vrijednost _TO postaviti na brojRacuna sa koga se transakcija vrsi
	bool _aktivna; //u slucaju da se transakcija izbrise ona postaje neaktivna, ali je bitno da o njoj ostane zapis
	/*	Unos / Ispis */
};

struct Racun {
	VrstaRacuna _vrstaRacuna;
	char _brojRacuna[20];
	Transakcija * _transakcije; //za svaki racun ce se evidentirati transakcije
	int _brojTransakcija;
	bool _aktivan;
	/*
	Unos / Ispis / Dealociraj / DodajTransakciju / UkloniTransakciju
	*/
	void Unos(VrstaRacuna vrsta, char *brojRacuna);

};
void Racun::Unos(VrstaRacuna vrsta, char *brojRacuna)
{
	_vrstaRacuna = vrsta;
	strcpy_s(_brojRacuna, strlen(brojRacuna) + 1, brojRacuna);

}

struct Korisnik {
	char _JMBG[14];
	char * _imePrezime;
	Racun * _racuni;
	int _trenutnoRacuna; //brojac
	bool _aktivan;
	void Unos(char *JMBG, char *ime_prezime);

	/*
	Unos / Ispis / Dealociraj / DodajRacun / UkloniRacun /
	DodajTransakciju - pored iznosa, korisnik vrsi odabir vrste transakcije, te racuna koji zeli koristiti za tu transakciju; onemoguciti isplate vece kolicine novca nego sto korisnik posjeduje na racunu
	GetTransakcijeByIznos - vraca niz transakcija koje su imale iznos veci od trazenog
	GetTransakcije - vraca listu transakcija koje su izvrsena prema odredjenom racunu(_TO), ukljucujuci i neaktivne
	GetTransakcijeByDatum - vraca listu svih transakcija koje su obavljene
	*/
};
void Korisnik::Unos(char *JMBG, char *ime_prezime)
{
	char slovo;
	int vrsta;
	_trenutnoRacuna = 0;
	strcpy_s(_JMBG, strlen(JMBG) + 1, JMBG);
	strcpy_s(_imePrezime, strlen(ime_prezime) + 1, ime_prezime);
	cout << "Da li zelite dodati racun? Unesite D ili d " << endl;
	cin >> slovo;
	if (slovo == 'D' || slovo == 'd'){
		do
		{
			VrstaRacuna VrstaRac;
			char BrojRac[20];
			_racuni = new Racun[_trenutnoRacuna + 1];
			cout << "Unesite vrstu racuna:1. TEKUCI, 2. DEVIZNI, 3. STEDNI " << endl;
			cin >> vrsta;
			VrstaRac = (VrstaRacuna)--vrsta;
			cout << "Unesite broj racuna" << endl;
			cin.getline(BrojRac, 19);
			_racuni[_trenutnoRacuna].Unos(VrstaRac, BrojRac);


			cout << "Da li zelite dodati racun? Unesite D ili d " << endl;
			_trenutnoRacuna++;
			cin >> slovo;
		} while (slovo == 'D' || slovo == 'd');
	}
}


int PrikaziMenu() {
	int izbor;
	cout << crt << "\t::MENU::" << crt;
	cout << "1. Dodaj korisnika" << endl;
	cout << "2. Dodaj racun" << endl;
	cout << "3. Pretraga" << endl;
	cout << "4. Deaktiviranje korisnika" << crt; // racuna ili korisnika
	cout << "5. Kraj" << crt;
	do {
		cout << "Vas izbor -> ";
		cin >> izbor;
	} while (izbor < 1 || izbor>5);
	system("cls");
	return izbor;
}

void main() {
	int trenutnoKorisnika = 0, izborMenu = 0;
	Korisnik * korisnici = nullptr;

	do {
		izborMenu = PrikaziMenu();
		cin.ignore();


	} while (izborMenu != 5);

	if (izborMenu == 1){
		char jmbg[14];
		char imeprez[40];
		Korisnik* korisnici = new Korisnik[trenutnoKorisnika + 1];
		cout << "Unesite JMBG korisnika" << endl;
		cin.getline(jmbg, 13);
		cout << "Unesite Ime i Prezime" << endl;
		cin.getline(imeprez, 39);
		korisnici[trenutnoKorisnika].Unos(jmbg, imeprez);
		
	}

}


-______________________________________________________________________________


#include<iostream>
using namespace std;
char * crt = "\n---------------------------\n";
int ODG;

enum VrstaRacuna { TEKUCI, DEVIZNI, STEDNI };
enum VrstaTransakcije { UPLATA, ISPLATA };

struct Datum {
	int _dan, _mjesec, _godina;
	/*	Unos / Ispis */
	void unos(int dan, int mjesec, int godina);
	void ispis();
};

struct Transakcija {
	char _TO[20];
	float _iznos;
	VrstaTransakcije _vrstaTransakcije; // ako je isplata vrijednost _TO postaviti na brojRacuna sa koga se transakcija vrsi
	bool _aktivna; //u slucaju da se transakcija izbrise ona postaje neaktivna, ali je bitno da o njoj ostane zapis
	/*	Unos / Ispis */
	void Unos(char *brojRacuna, float iznos, VrstaTransakcije vrsta);
	void Ispis();
	void KopirajTransakcije(Transakcija t);
};
void Transakcija::Unos(char *brojRacuna, float iznos, VrstaTransakcije vrsta)
{
	strcpy_s(_TO, strlen(brojRacuna) + 1, brojRacuna);
	_iznos = iznos;
	_vrstaTransakcije = vrsta;
	_aktivna = true;
}

void Transakcija::Ispis()
{
	cout << "TO: " << _TO << endl;
	cout << "Iznos: " << _iznos << endl;
	cout << "Vrsta transakcije: " << _vrstaTransakcije << endl;
	if (_aktivna)
		cout << "Transakcija je aktivna" << endl;
	else
		cout << "Transakcija nije aktivna" << endl;
	cout << crt;
}

struct Racun {
	VrstaRacuna _vrstaRacuna;
	char _brojRacuna[20];
	Transakcija * _transakcije; //za svaki racun ce se evidentirati transakcije
	int _brojTransakcija;
	bool _aktivan;
	/*
	Unos / Ispis / Dealociraj / DodajTransakciju / UkloniTransakciju
	*/
	void Unos(VrstaRacuna vrsta, char *brojRacuna);
	void Ispis();
	void Dealociraj();
	void DodajTransakciju(char *brojRacuna, float iznos, VrstaTransakcije vrsta);
	void KopirajRacune(Racun r);
	void UkloniTranskaciju(int redni_broj_transkacije);

};

void Racun::DodajTransakciju(char *brojRacuna, float iznos, VrstaTransakcije vrsta)
{
	Transakcija *temp = new Transakcija[_brojTransakcija + 1];

	for (int i = 0; i < _brojTransakcija; i++)
		temp[i].Unos(_transakcije[i]._TO, _transakcije[i]._iznos, _transakcije[i]._vrstaTransakcije);

	temp[_brojTransakcija].Unos(brojRacuna, iznos, vrsta);
	delete[] _transakcije;
	_transakcije = temp;
	_brojTransakcija++;
	
}
void Racun::Ispis()
{
	cout << "Vrsta racuna: " << _vrstaRacuna << endl;
	cout << "Broj Racuna: " << _brojRacuna << endl;
	for (int i = 0; i < _brojTransakcija; i++)
	{
		_transakcije[i].Ispis();
	}
	if (_aktivan) 
		cout << "Racun je aktivan" << endl;
	else
		cout << "Racun nije aktivan" << endl;
	cout << crt;
}
void Racun::Dealociraj()
{
	if (_transakcije != nullptr){
		delete[] _transakcije;
	}
}
void Racun::Unos(VrstaRacuna vrsta, char *brojRacuna)
{
	_vrstaRacuna = vrsta;
	strcpy_s(_brojRacuna, strlen(brojRacuna) + 1, brojRacuna);
	_transakcije = nullptr;
	_brojTransakcija = 0;
	_aktivan = true;
}

struct Korisnik {
	char _JMBG[14];
	char * _imePrezime;
	Racun * _racuni;
	int _trenutnoRacuna; //brojac
	bool _aktivan;

	/*
	Unos / Ispis / Dealociraj / DodajRacun / UkloniRacun /
	DodajTransakciju - pored iznosa, korisnik vrsi odabir vrste transakcije, te racuna koji zeli koristiti za tu transakciju; onemoguciti isplate vece kolicine novca nego sto korisnik posjeduje na racunu
	GetTransakcijeByIznos - vraca niz transakcija koje su imale iznos veci od trazenog
	GetTransakcije - vraca listu transakcija koje su izvrsena prema odredjenom racunu(_TO), ukljucujuci i neaktivne
	GetTransakcijeByDatum - vraca listu svih transakcija koje su obavljene
	*/
	void Unos(char *JMBG, char *ime_prezime);
	void Ispis();
	void Dealociraj();
	void DodajRacun(VrstaRacuna vrsta, char *brojRacuna);
	void UkloniRacun(int redni_broj_racuna);
	void KopirajKorisnika(Korisnik k);
	Transakcija *GetTransakcijeByIznos(float iznos, int &broj_transakcija);
	Transakcija *GetTransakcije(char *TO, int &broj_transakcija);
	Transakcija *GetTransakcijeByDatum(int &broj_transakcija);
};

void Korisnik::Ispis()
{
	cout << "JMBG: " << _JMBG << endl;
	cout << "Ime i Prezime: " << _imePrezime << endl;
	for (int i = 0; i < _trenutnoRacuna; i++)
	{
		_racuni[i].Ispis();
	}
	if (_aktivan)
		cout << "Korisnik je aktivan" << endl;
	else
		cout << "Korisnik nije aktivan" << endl;
}
void Korisnik::DodajRacun(VrstaRacuna vrsta, char* brojRacuna)
{
	Racun *temp = new Racun[_trenutnoRacuna + 1];

	for (int i = 0; i < _trenutnoRacuna; i++)
		temp[i].Unos(_racuni->_vrstaRacuna,_racuni->_brojRacuna);

	if (_racuni != nullptr){
		for (int i = 0; i < _trenutnoRacuna; i++)
		{
			_racuni[i].Dealociraj();
		}
		delete[] _racuni;
	}
	
	temp[_trenutnoRacuna].Unos(vrsta, brojRacuna);
	_racuni = temp;
	_trenutnoRacuna++;

}
void Korisnik::Dealociraj()
{
	if (_racuni != nullptr){
		for (int i = 0; i < _trenutnoRacuna; i++)
			_racuni[i].Dealociraj();
		delete[] _racuni; _racuni = nullptr;
	}
}
void Korisnik::Unos(char *JMBG, char *ime_prezime)
{
	strcpy_s(_JMBG, strlen(JMBG) + 1, JMBG);
	_imePrezime = new char[strlen(ime_prezime) + 1];
	strcpy_s(_imePrezime, strlen(ime_prezime) + 1, ime_prezime);
	_racuni = nullptr;
	_trenutnoRacuna = 0;
	_aktivan = true;
}
void Korisnik::KopirajKorisnika(Korisnik k)
{
	strcpy_s(_JMBG, strlen(k._JMBG )+ 1, k._JMBG);
	_imePrezime = new char[strlen(k._imePrezime) + 1];
	strcpy_s(_imePrezime, strlen(_imePrezime) + 1, k._imePrezime);
	_racuni = new Racun[k._trenutnoRacuna];
	for (int i = 0; i < k._trenutnoRacuna; i++)
	{
		_racuni[i].KopirajRacune(k._racuni[i]);
	}
	_trenutnoRacuna = k._trenutnoRacuna;
	_aktivan = k._aktivan;

}
void Racun::KopirajRacune(Racun r)
{
	_vrstaRacuna = r._vrstaRacuna;
	strcpy_s(_brojRacuna, strlen(r._brojRacuna) + 1, r._brojRacuna);
	_brojTransakcija = r._brojTransakcija;
	_transakcije = new Transakcija[_brojTransakcija];
	for (int i = 0; i < _brojTransakcija; i++)
	{
		_transakcije[i].KopirajTransakcije(r._transakcije[i]);
	}
	_aktivan = r._aktivan;
}
void Transakcija::KopirajTransakcije(Transakcija t)
{
	strcpy_s(_TO, strlen(t._TO) + 1, t._TO);
	_iznos = t._iznos;
	_vrstaTransakcije = t._vrstaTransakcije;
	_aktivna = t._aktivna;
}

int PrikaziMenu() {
	int izbor;
	cout << crt << "\t::MENU::" << crt;
	cout << "1. Dodaj korisnika" << endl;
	cout << "2. Dodaj racun" << endl;
	cout << "3. Pretraga" << endl;
	cout << "4. Deaktiviranje korisnika" << crt; // racuna ili korisnika
	cout << "5. Kraj" << crt;
	do {
		cout << "Vas izbor -> ";
		cin >> izbor;
	} while (izbor < 1 || izbor>5);
	system("cls");
	return izbor;
}

void main() {
	int trenutnoKorisnika = 0, izborMenu = 0;
	Korisnik * korisnici = nullptr;

	do {
		izborMenu = PrikaziMenu();
		cin.ignore();
		if (izborMenu == 1)
		{
			Korisnik *temp = new Korisnik[trenutnoKorisnika + 1];

			for (int i = 0; i < trenutnoKorisnika; i++){
				temp[i].KopirajKorisnika(korisnici[i]);
			}
			if (korisnici != nullptr){
				for (int i = 0; i < trenutnoKorisnika; i++)
					korisnici[i].Dealociraj();
				delete[] korisnici;
			}
			char unosTemp[20], ime_prezime_temp[40];

			cout << "Unesite jmbg korisnika" << endl;
			cin.getline(unosTemp, 19);
			cout << "Unesite ime i prezime" << endl;
			cin.getline(ime_prezime_temp, 39);

			temp[trenutnoKorisnika].Unos(unosTemp, ime_prezime_temp);

			korisnici = temp;
			trenutnoKorisnika++;
		}
		else if (izborMenu == 2)
		{
			VrstaRacuna vrsta;
			int v;
			char brojRacuna[20];
			int korisnik;
			cout << "Unesite korisnika kojem zelite dodati racun: " << endl;
			cin >> korisnik;
			cout << "Unesite vrstu racuna: 1. TEKUCI,2. DEVIZNI,3. STEDNI" << endl;
			cin >> v;
			vrsta = (VrstaRacuna)v;
			cout << "Unesite broj racuna" << endl;
			cin.ignore();
			cin.getline(brojRacuna, 19);

			korisnici[--korisnik].DodajRacun(vrsta, brojRacuna);

		}
		else if (izborMenu == 3)
		{
			if (korisnici != nullptr)
			{
				char pretragaKorisnika[20];
				cout << "Unesite ime ili prezime korisnika" << endl;
				cin.getline(pretragaKorisnika, 19);
				for (int i = 0; i < trenutnoKorisnika; i++)
				{
					char *pok = strstr(pretragaKorisnika, korisnici[i]._imePrezime);
					if (pok != nullptr)
					{
						char karakter;
						korisnici[i].Ispis();

						char karakter;
						cout << "Da li zelite ovom korisniku dodati transakciju (D/N) -> ";
						do
						{
							cin >> karakter;
							cin.ignore();
							if (toupper(karakter) != 'D' && toupper(karakter) != 'N')
								cout << "Unijeli ste pogresan odgovor. Pokusajte ponovo." << endl;
						} while (toupper(karakter) != 'D' && toupper(karakter) != 'N');
						if (toupper(karakter) == 'D')
						{
							int vrstaUplate;
							VrstaTransakcije vrstaT;
							float iznos;
							cout << "Odaberite vrstu transakcije (1. UPLATA, 2. ISPLATA) -> ";
							cin >> vrstaUplate;
							vrstaT = (VrstaTransakcije)--vrstaUplate;
							for (int j = 0; j < korisnici[i]._trenutnoRacuna; j++)
							{
								cout << "Racun broj: " << i + 1;
								korisnici[i]._racuni[j].Ispis();
								cout << crt;
							}
							cout << "Unesite redni broj racuna koji ce se koristiti za transakciju -> ";
							int rb;
							do
							{
								cin >> rb;
								rb--;
								if (rb<0 || rb>korisnici[i]._trenutnoRacuna)
									cout << "Unijeli ste pogresan broj. Pokusajte ponovo" << endl;
							} while (rb<0 || rb>korisnici[i]._trenutnoRacuna);

							cout << "Unesite iznos za " << vrstaT << " -> ";
							cin >> iznos;
							korisnici[i]._racuni[rb].DodajTransakciju(korisnici[i]._racuni[rb]._brojRacuna, iznos, vrstaT);

						}

					}

				}
			}
		}
		else if (izborMenu == 4)
		{
			if (korisnici != nullptr)
			{
				int izbor, rb;
				cout << "Sta zelite deaktivirat: 1. KORISNIKA, 2. RACUN -> ";

				// unos izbora brisanja
				// 1->Brisanje korisnika
				// 2 -> Brisanje racuna
				cin >> izbor;
				for (int i = 0; i < trenutnoKorisnika; i++)
				{
					korisnici[i].Ispis();
					cout << crt;
				}
				cout << "Unesite rb korisnika ->:";
				cin >> rb;
				rb--;
				if (izbor == 1)
				{
					korisnici[rb]._aktivan = false;
				}
				else
				{
					if (korisnici[rb]._trenutnoRacuna > 0)
					{
						for (int i = 0; i < korisnici[rb]._trenutnoRacuna; i++)
						{
							cout << "Broj racuna: " << i + 1 << endl;
							korisnici[rb]._racuni[i].Ispis();
							cout << endl;
						}
						cout << "Unesite broj racuna kojeg zelite deaktivirati." << endl;
						cin >> izbor;
						korisnici[rb]._racuni[--izbor]._aktivan = false;
					}
				}
			}
		}
			
	} while (izborMenu != 5);
	if (korisnici != nullptr)
	{
		for (int i = 0; i <trenutnoKorisnika; i++)
		{
			korisnici[i].Dealociraj();
		}
		delete[] korisnici;
		korisnici = nullptr;
		system("pause");
	}


_______________________________________________________________


#include<iostream>
using namespace std;
char * crt = "\n---------------------------\n";
int ODG;

enum VrstaRacuna { TEKUCI, DEVIZNI, STEDNI };
char *vrstaRacuna[] = { "TEKUCI", "DEVIZNI", "STEDNI" };
enum VrstaTransakcije { UPLATA, ISPLATA };
char *vrstaTransakcije[] = { "UPLATA", "ISPLATA" };


struct Datum{
	int _dan, _mjesec, _godina;
};

struct Transakcija{
	Datum _datumTransakcije;
	float iznos;
	VrstaTransakcije _vrstaTransakcije;
	char * _TO;
	bool _aktivna; //u slucaju da se transakcija izbrise ona postaje neaktivna, ali je bitno da o njoj ostane zapis

	void Dealociraj()
	{
		delete[] _TO; _TO = nullptr;
	}
};
struct Racun{
	int max_transakcije = 20;
	VrstaRacuna _vrstaRacuna;
	char _brojRacuna[20];
	Transakcija * _transakcije; //za svaki racun ce se evidentirati transakcije
	int _brojTransakcija;
	bool _aktivan;

	void Unos(VrstaRacuna vrsta, char* brojRacuna)
	{
		if (max_transakcije > 20){
			cout << "Transakcije su popunjene" << endl;
		}
		else{
			_vrstaRacuna = vrsta;
			strcpy_s(_brojRacuna, 19, brojRacuna);
			_transakcije = nullptr;
			_brojTransakcija = 0;
			_aktivan = true;
		}			
	}
	void Ispis()
	{
		if (_vrstaRacuna == TEKUCI)
			cout <<"Vrsta racuna: "<< vrstaRacuna[0] << endl;
		else if (_vrstaRacuna == DEVIZNI)
			cout <<"Vrsta racuna: "<< vrstaRacuna[1] << endl;
		else if (_vrstaRacuna == STEDNI)
			cout <<"Vrsta racuna: "<< vrstaRacuna[2] << endl;
		cout <<"Broj racuna: "<<_brojRacuna << endl;
		if (_aktivan == true)
			cout << "Racun je aktivan" << endl;
		else
			cout << "Racun nije aktivan" << endl;

	}

	void Dealociraj()
	{
		for (int i = 0; i < _brojTransakcija; i++)
			_transakcije[i].Dealociraj();
		delete[] _transakcije;	_transakcije = nullptr;
	}

};


struct Klijenti {
	char _JMBG[14];
	char * _imePrezime;
	Racun * _racuni;
	int _trenutnoRacuna; //brojac
	bool _aktivan;

	void Unos(char * jmbg, char * ime_prezime)
	{
		strcpy_s(_JMBG, strlen(jmbg) + 1, jmbg);
		_imePrezime = new char[strlen(jmbg) + 1];
		strcpy_s(_imePrezime, strlen(ime_prezime) + 1, ime_prezime);
		_racuni = nullptr;
		_trenutnoRacuna = 0;
		_aktivan = true;
	}
	void Ispis()
	{
		cout << "jmbg: " << _JMBG << endl;
		cout << "Ime i Prezime: " << _imePrezime << endl;
		if (_aktivan == true)
			cout << "Korisnik je aktivan" << endl;
		else
			cout << "Korisnik nije aktivan" << endl;
	}
	void Dealociraj()
	{
		//delete _imePrezime;
		delete[] _racuni;
		
		
	}
	void DodajRacun(VrstaRacuna vrstaRacuna, char* brojRacuna)
	{
		Racun* temp = new Racun[_trenutnoRacuna + 1];

		for (int i = 0; i < _trenutnoRacuna; i++)
			temp[i] = _racuni[i];

		for (int i = 0; i < _trenutnoRacuna; i++)
			_racuni[i].Dealociraj();
		_racuni = nullptr;

		temp[_trenutnoRacuna].Unos(vrstaRacuna,brojRacuna);

		_racuni = temp;
		_trenutnoRacuna++;
	}
	/*
	Unos / Ispis / Dealociraj / DodajRacun / UkloniRacun /
	DodajTransakciju - pored iznosa, korisnik vrsi odabir vrste transakcije, te racuna koji zeli koristiti za tu transakciju; onemoguciti isplate vece kolicine novca nego sto korisnik posjeduje na racunu
	GetTransakcijeByIznos - vraca niz transakcija koje su imale iznos veci od trazenog
	GetTransakcije - vraca listu transakcija koje su izvrsena prema odredjenom racunu(_TO), ukljucujuci i neaktivne
	GetTransakcijeByDatum - vraca listu svih transakcija koje su obavljene
	*/
};


int PrikaziMenu() {
	int izbor;
	cout << crt << "\t::MENU::" << crt;
	cout << "1. Dodaj korisnika" << endl;
	cout << "2. Dodaj racun" << endl;
	cout << "3. Pretraga" << endl;
	cout << "4. Deaktiviranje korisnika" << crt; // racuna ili korisnika
	cout << "5. Kraj" << crt;
	do {
		cout << "Vas izbor -> ";
		cin >> izbor;
	} while (izbor < 1 || izbor>5);
	system("cls");
	return izbor;
}
void main() {
	int trenutnoKorisnika = 0, izborMenu = 0;
	Klijenti * korisnici = nullptr;


	do {
		izborMenu = PrikaziMenu();

		if (izborMenu == 1)
		{
			char JMBG[14];
			char imePrez[40];

			Klijenti* temp = new Klijenti[trenutnoKorisnika+1];
			
			for (int i = 0; i < trenutnoKorisnika; i++)
				temp[i] = korisnici[i];
			
			for (int i = 0; i < trenutnoKorisnika; i++){
				korisnici[i].Dealociraj();
			}
			cin.ignore();
			cout << "Unesite JMBG korisnika: " << endl;
			cin.getline(JMBG, 13);
			cout << "Unesite Ime iPrezime korisnika" << endl;
			cin.getline(imePrez, 39);

			temp[trenutnoKorisnika].Unos(JMBG, imePrez);
			korisnici = temp;
			trenutnoKorisnika++;
		}
		
		if (izborMenu == 2)
		{

			int odabir;
			for (int i = 0; i < trenutnoKorisnika; i++)
			{
				cout << "Korisnik: " << i + 1<<": ";
				//cout << korisnici[i].Ispis << endl;
			}
			do
			{
				cout << "Odaberite korisnika kojem zelite dodati racun" << endl;
				cin >> odabir;
				if (odabir<1 || odabir>trenutnoKorisnika)
					cout << "Taj korisnik ne postoji. Pokusajte ponovo" << endl;
			} while (odabir<1 || odabir>trenutnoKorisnika);

			odabir--;
			VrstaRacuna vrsta;
			char brojRacuna[20];
			int v;

			cout << "Unesite vrstu racuna 1.TEKUCI, 2.DEVIZNI, 3.STEDNI" << endl;
			cin >> v;
			cin.ignore();
			v--;
			vrsta = (VrstaRacuna)v;

			cout << "Unesite broj racuna: " << endl;
			cin.getline(brojRacuna, 19);
			korisnici[odabir].DodajRacun(vrsta, brojRacuna);

			
		}

	} while (izborMenu != 5);


}

______________________________________________________-


//Ucitati sadržaj matrice iz tekstualnog fajla u dvodimenzionalni niz.Korisnik mora unijeti velicinu matrice.

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <iomanip>
using namespace std;

int redova, kolona;

void unosUFajl(char * nazivFajla)
{
	ofstream unos(nazivFajla);
	if (!unos.fail()){
		char text[300];
		cout << "Unesite tekst koji zelitre unijeti u fajl" << endl;
		cin.getline(text, 300);
		unos << text;
		unos.close();
	}
	else
		cout << "Greska u otvaranju fajla" << endl;

}
void ucitajUMatricu(char * nazivFajla,char ** m)
{
	char slovo;
	int i=0, j=0;
	ifstream ispis(nazivFajla);
	if (!ispis.fail()){
	
			while (ispis.get(slovo)){
				m[i][j] = slovo;
				j++;
				if (j > kolona){
					j = 0;
					i++;
				}
				if (i > redova)
					break;
			}
		
		ispis.close();
	}
	else
		cout << "Greska u otvaranju fajla" << endl;
}
void ocisti(char ** &m)
{
	for (int i = 0; i < redova; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			m[i][j] = ' ';
		}
	}
}

void ispisiMatricu(char **m)
{
	for (int i = 0; i < redova; i++)
	{
		for (int j = 0; j < kolona; j++)
		{
			cout << setw(2) << m[i][j] << setw(2);
		}
		cout << endl;
	}
}

void main()
{
	char* nazivFajla = "matrica.txt";
	unosUFajl(nazivFajla);

	cout << "Unesite velicinu redova i kolona" << endl;
	cin >> redova >> kolona;
	char ** m = new char *[redova];
	for (int i = 0; i < redova; i++)
		m[i] = new char[kolona];

	ocisti(m);

	ucitajUMatricu(nazivFajla, m);

	if (m != nullptr){
		ispisiMatricu(m);
	}
	else
		cout << "Greska" << endl;

	system("pause");
}

___________________________________________________


/*1.	Implementirajte funkciju izmjeni.Funkcija treba kopirate sve karaktere iz fajla imeFajlaSource u fajl imeFajlaDest, 
tako što ce sve karaktere koji predstavljaju mala slova engleske abecede pretvoriti u velika slova.Funkcija treba vratiti broj
izmijenjenih karaktera.*/

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <iomanip>
using namespace std;

int izmjeni(char* imeFajlaSource, char* imeFajlaDest){

char b = 0;
ifstream f1(imeFajlaSource);
ofstream f2(imeFajlaDest);
	char a;
	if (!f1.fail()|| !f2.fail()){
		while (f1.get(a)){
			if (islower(a)){
				b++;
				a = toupper(a);
			}
			f2 << a;
		}
		f1.close();
		f2.close();
	}
	else
		cout << "Greska pri otvaranju fajla" << endl;

	return b;
}

void main()
{
	char * nazivSource = "Source.txt";
	char * nazivDest = "Destinacija.txt";
	ofstream f1(nazivSource);
	if (!f1.fail()){
		f1 << "Ovo je izvorni fajl i unosim neki tekst" << endl;
		f1.close();
	}
	else
		cout << "Greska pri otvaranju fajla" << endl;

	cout<<"Izmjenjenih slova ima: "<<izmjeni(nazivSource,nazivDest);
	system("pause");
}


_______________________________________________________________


/*1.Implementirajte program sa funkcijom void dodajKomentar(char* imeFajla, char* komentar) koja ce dodati na kraj fajla komentar
kojeg korisnik unese.*/

#include <iostream>
#include <fstream>
#include <stdlib.h>
#include <iomanip>
using namespace std;

void dodajKomentar(char* imeFajla, char* komentar)
{
	ofstream unosKomentara(imeFajla, ios::app | ios::_Nocreate);
	if (!unosKomentara.fail()){
		unosKomentara << endl << komentar;
		unosKomentara.close();
	}
	else
		cout << "Greska pri otvaranju" << endl;
}

void main()
{
	char niz[200];
	char kom[200];
	char * imeFajla = "text.txt";
	ofstream unos(imeFajla);
	if (!unos.fail()){
		cout << "Unesite neki text u fajl" << endl;
		cin.getline(niz, 200);
		unos.close();
	}
	else
		cout << "Greska pri otvaranju" << endl;

	cout << "Unesite  komentrar kako bi ga dodali na kraj teksta" << endl;
	cin.getline(kom, 200);

	dodajKomentar(imeFajla, kom);
	system("pause");
}

_______________________________________________________________


#include<iostream>
#include<fstream>
using namespace std;

char crt[] = { "\n-------------------------------------------\n" };

struct Osiguranje{
	char brojOsiguranja[12];
	float stanjeRacuna;

	void Unos()
	{
		cout << "Unesite broj osiguranja: ";
		cin.getline(brojOsiguranja, 11);
		stanjeRacuna = 0;
	}
	void Ispis()
	{
		cout << "Broj Osiguranja: " << brojOsiguranja << endl;
		cout << "Stanje Racuna: " << stanjeRacuna << endl;
	}
	void Uplata(float iznos)
	{
		if (iznos > 0)
			stanjeRacuna += iznos;
		else
			cout << "Ne mozete uplatiti negativnu vrijednost" << endl;
	}

	void Isplata(float iznos)
	{
		if (stanjeRacuna > iznos)
			stanjeRacuna -= iznos;
		else{
			cout << "Ne mozete isplatiti vise nego sto imate na racunu" << endl;
			cout << "na racunu imate " << stanjeRacuna << endl;
		}
	}
};

struct Pacijent{
	char * ImePrezime;
	char JMBG[14];
	bool RanijeBolovao;
	Osiguranje osiguranje;
	void inicijalizacija()
	{
		char slovo;
		char temp[30];
		cout << "Unesite ime i prezime pacijenta" << endl;
		cin.getline(temp, 29);
		int duzina = strlen(temp) + 1;
		ImePrezime = new char[duzina];
		strcpy_s(ImePrezime, duzina, temp);
		cout << "Unesite JMBG: " << endl;
		cin.getline(JMBG, 13);

		cout << "Da li je pacijent ranije bolovao (D/N): ";
		cin >> slovo;
		slovo = toupper(slovo);
		if (slovo == 'D')
			RanijeBolovao = true;
		else
			RanijeBolovao = false;
		cin.ignore();
		osiguranje.Unos();
	}
};

Pacijent * DodajPacijenta()
{
	Pacijent * pa = new Pacijent;
	pa->inicijalizacija();
	return pa;
}
void prikaziInfo(Pacijent * p)
{
	cout << crt;
	cout << "Ime i Prezime: " << p->ImePrezime << endl;
	cout << "JMBG: " << p->JMBG << endl;
	if (p->RanijeBolovao)
		cout << "Pacijent je ranije bolovao" << endl;
	else
		cout << "Pacijent ranije nije bolovao" << endl;
	p->osiguranje.Ispis();
	cout << crt;
}
Pacijent * Pretraga(Pacijent niz[])
{
	char temp[14];
	cout << "Unesite JMBG osobe koju trazite" << endl;
	cin.getline(temp, 13);
	for (int i = 0; i <10; i++)
	{
		char * pok = strstr(temp, niz[i].JMBG);
		if (pok != NULL){
			cout << "JMBG je pronadjen" << endl;
			return niz + i;
		}
		else{
			cout << "JMBG nije pronadjen" << endl;
			return NULL;
		}
	}
}
void UpisiUFajl(ofstream & obj, Pacijent * p)
{
	char * nazivFajla = "mojFajl.txt";
	obj.open(nazivFajla, ios::binary);
	if (!obj.fail()){
		obj.write((char*) *(&p), sizeof(*p));
		obj.close();
	}
	else
		cout << "Ne moze se otvorit fajl" << endl;
}
void kopirajFajl()
{
	Pacijent p;
	p.ImePrezime = new char[50];
	char * nazivFajla = "mojFajl.txt";
	ifstream original;
	original.open(nazivFajla, ios::binary);
	ofstream kopija;
	kopija.open("mojFajl2.txt", ios::binary);

	if (!original.fail() || !kopija.fail()){
		original.read((char*)(&p), sizeof(p));
		kopija.write((char*)(&p),sizeof(p));
		original.close();
		kopija.close();
	}
	
}


void main()
{
	int rb;
	Pacijent ** Pacijenti = new  Pacijent *[10];
	for (int i = 0; i < 10; i++)
		Pacijenti[i] = DodajPacijenta();

	Pacijent *pok = Pacijenti[3];
	float iznos;
	cout << "Unesite iznos za uplatu do 150 km" << endl;
	cin >> iznos;
	pok->osiguranje.Uplata(iznos);
	cout << "Unesite iznos za isplatu do 100 km" << endl;
	cin >> iznos;
	pok->osiguranje.Isplata(iznos);

	cout << "Odaberite kojeg pacijenta zelite da ispisete u fajl" << endl;
	cin >> rb;
	rb--;
	ofstream upis;
	UpisiUFajl(upis, Pacijenti[rb]);
	kopirajFajl();

	system("pause");
}


__________________________________________________________________

#include<iostream>
#include<fstream>

using namespace std;

enum VrstaObaveze{ Seminarski, Parcijalni1, Parcijalni2, Integralni };
struct Datum{
	int * _dan, *_mjesec, *_godina;
	void Unos(int d, int m, int g){
		_dan = new int;
		*_dan = d;
		_mjesec = new int;
		*_mjesec = m;
		_godina = new int;
		*_godina = g;
	}
	void Ispis(){ cout << *_dan << "/" << *_mjesec << "/" << *_godina << endl; }
	void Dealociraj(){ delete _dan; delete _mjesec; delete _godina; }
};
struct ObavezeNaPredmetu{
	VrstaObaveze _vrstaObaveze;
	Datum * _datumIzvrsenja;
	int _ocjena; // 5 - 10
	char * _komentar;
	int _brojacKomentara;
	void Unos(VrstaObaveze vrsta, Datum * datum, int ocjena){
		_vrstaObaveze = vrsta;
		_datumIzvrsenja = new Datum;
		_datumIzvrsenja->Unos(*datum->_dan, *datum->_mjesec, *datum->_godina);
		_ocjena = ocjena;
		_komentar = NULL;
		_brojacKomentara = 0;
	}
	void Ispis(){
		cout << _vrstaObaveze << " " << _ocjena;
		_datumIzvrsenja->Ispis();
		cout << endl;
	}
	void Dealociraj(){ delete _datumIzvrsenja; delete[] _komentar; }

	void DodajKomentar(char * komentar){
		char * temp = new char[_brojacKomentara + 1];

		for (int i = 0; i < _brojacKomentara; i++)
			temp[i] = komentar[i];

		temp[_brojacKomentara] = *komentar;

		_komentar = temp;
		temp = nullptr;

	}
};
struct PolozeniPredmet{
	Datum * _datumPolaganja;
	//u okviru jednog predmeta studenti mogu imati najviše 10 obaveza
	ObavezeNaPredmetu _listaIzvrsenihObaveza[10];
	int _trenutnoIzvrsenihObaveza;
	int * _konacnaOcjena;

	void Ispis(){
		_datumPolaganja->Ispis();
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			_listaIzvrsenihObaveza[i].Ispis();
		}
		cout << "Konacna ocjena je: " << *_konacnaOcjena << endl;
	}

	void Unos(Datum * d, ObavezeNaPredmetu obaveza){
		//Na osnovu vrijednosti primljenih parametara izvršiti inicijalizaciju odgovarajucih
		//atributa
		_datumPolaganja = new Datum;
		_datumPolaganja->Unos(*d->_dan, *d->_mjesec, *d->_godina);

		if (_trenutnoIzvrsenihObaveza <= 10){
			_listaIzvrsenihObaveza[_trenutnoIzvrsenihObaveza].Unos(obaveza._vrstaObaveze, obaveza._datumIzvrsenja, obaveza._ocjena);
			_trenutnoIzvrsenihObaveza++;
		}
		else
			cout << "Izvrsili ste sve obaveze" << endl;

		_konacnaOcjena = new int;
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			_konacnaOcjena += _listaIzvrsenihObaveza[i]._ocjena;
		}
		*_konacnaOcjena /= _trenutnoIzvrsenihObaveza;
	}
	bool DodajKomentarIzvrsenojObavezi(ObavezeNaPredmetu * obaveza, char * komentar){
		/*Funkcija ima zadatak da na osnovu primljenog parametra obaveza pronade izvršenu
		obavezu, te joj doda komentar koji je takoder proslijeden kao parametar. Voditi racuna o tome da
		jedna obaveza može imati veci broj komentara. U slucaju da tražena obaveza ne postoji, funkcija
		vraca false. */
		int rb;
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			cout << "Obaveza broj: " << i + 1;
			obaveza[i].Ispis();
		}
		cout << "Unesite rb obaveze kojoj zelite da dodate komentar" << endl;
		cin >> rb;
		obaveza[rb].DodajKomentar(komentar);

		


	}
	int FormirajKonacnuOcjenu(){
		/*Funkcija je zadužena za formiranje konacne ocjene na položenom predmetu. Za
		formiranje konacne ocjene predmet treba imati najmanje tri izvršene obaveze od kojih jedna mora biti
		seminarski rad ukoliko je student integralno položio ispit. U slucaju da komentar na
		obavezi sadrži rijec varanje, ocjena na toj obavezi se umanjuje za 1. Ukoliko svi pomenuti uslovi
		nisu izvršeni, konacna ocjena treba biti postavljena na vrijednost 5. Funkcija vraca vrijednost
		atributa _konacnaOcjena*/

		bool imaPrvi = false;
		bool imaDrugi = false;
		bool imaTreci = false;

		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni1 && _listaIzvrsenihObaveza[i]._ocjena > 5)
				for (int j = 0; j < _listaIzvrsenihObaveza[i]._brojacKomentara; j++)
				{
				if (strstr(_listaIzvrsenihObaveza[i]._komentar + j, "varanje") == nullptr)
					imaPrvi = true;
				else
				{
					_listaIzvrsenihObaveza[i]._ocjena--;
					if (_listaIzvrsenihObaveza[i]._ocjena > 5)
						imaPrvi = true;
				}
				}
		}
		for (int i = 0; i <_trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni2 && _listaIzvrsenihObaveza[i]._ocjena > 5)
				for (int j = 0; j < _listaIzvrsenihObaveza[i]._brojacKomentara; j++)
				{
				if (strstr(_listaIzvrsenihObaveza[i]._komentar + j, "varanje") == nullptr)
					imaPrvi = true;
				else
				{
					_listaIzvrsenihObaveza[i]._ocjena--;
					if (_listaIzvrsenihObaveza[i]._ocjena > 5)
						imaDrugi = true;
				}
				}
		}

		if (imaPrvi && imaDrugi){
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Seminarski && _listaIzvrsenihObaveza[i]._ocjena > 5)
				{
						for (int j = 0; j < _listaIzvrsenihObaveza[i]._brojacKomentara; j++)
						{
						if (strstr(_listaIzvrsenihObaveza[i]._komentar + j, "varanje") == nullptr)
							imaTreci = true;
						else
						{
							_listaIzvrsenihObaveza[i]._ocjena--;
							if (_listaIzvrsenihObaveza[i]._ocjena > 5)
								imaTreci = true;
						}
						}
				}
			}
		}
		int brojacOcjena = 0;
		int rezultat = 0;
		if (imaPrvi&&imaDrugi&&imaTreci){
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]._ocjena > 5){
					rezultat += _listaIzvrsenihObaveza[i]._ocjena;
					brojacOcjena++;
				}
			}
			*_konacnaOcjena = rezultat / brojacOcjena;
			return *_konacnaOcjena;
		}

		bool imaIntegralni = false;


		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Integralni&&_listaIzvrsenihObaveza[i]._ocjena > 5){
				for (int j = 0; j < _listaIzvrsenihObaveza[i]._brojacKomentara; j++)
				{
					if (strstr(_listaIzvrsenihObaveza[i]._komentar + j, "varanje") == nullptr)
						imaIntegralni = true;
					else{
						_listaIzvrsenihObaveza[i]._ocjena--;
						if (_listaIzvrsenihObaveza[i]._ocjena > 5)
							imaIntegralni = true;
					}
				}
			}
		}

		int brojacSeminarskih = 0;
		bool imaSeminarske = false;

		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Seminarski &&_listaIzvrsenihObaveza[i]._ocjena > 5){
				for (int j = 0; j < _listaIzvrsenihObaveza[i]._brojacKomentara; j++)
				{
					if (strstr(_listaIzvrsenihObaveza[i]._komentar + j, "varanje") == nullptr)
						brojacSeminarskih++;
					else{
						_listaIzvrsenihObaveza[i]._ocjena--;
						if (_listaIzvrsenihObaveza[i]._ocjena > 5)
							brojacSeminarskih++;
					}
				}
				if (brojacSeminarskih >= 2)
					imaSeminarske = true;
			}

		}
		if (imaIntegralni&&imaSeminarske){
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]._ocjena > 5){
					rezultat += _listaIzvrsenihObaveza[i]._ocjena;
					brojacOcjena++;
				}
			}
			*_konacnaOcjena = rezultat / brojacOcjena;
			return *_konacnaOcjena;
		}
		
	
		*_konacnaOcjena = 5;
		return *_konacnaOcjena;
	}
	
};
int Pretraga(PolozeniPredmet * p, int max){
	/*Funkcija ima zadatak da ispiše informacije o svim položenim predmetima kod kojih je student
	ispit položio putem parcijalnih ispita, te tom prilikom ostvario prosjecnu ocjenu vecu od 8,5. Da bi
	informacije o položenom predmetu bile ispisane moraju biti ispunjeni svi uslovi neophodni za
	formiranje konacne ocjene. Nakon ispisa, funkcija vraca broj položenih predmeta koji su zadovoljili
	navedene kriterije.*/

	int brojacZadovoljenih = 0;
	float o1 = 0, o2 = 0;

	for (int i = 0; i < p->_trenutnoIzvrsenihObaveza; i++)
	{
		if (p->_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni1){
			o1 = p[i]._listaIzvrsenihObaveza->_ocjena;

		}
		if (p->_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni2)
			o2 = p->_listaIzvrsenihObaveza[i]._ocjena;

		if ((o1 + o2) / 2 > 8.5){
			p->Ispis();
			brojacZadovoljenih++;

		}
		return brojacZadovoljenih;

	}
}

void main(){ 
	//izbjegavajte korištenje vlastitog imena i prezimena.
	//provjeriti validnost izvršenja svih dostupnih funkcionalnosti
	cout << "Puno srece u radu..." << endl;
}

_________________________________________________________________


#include<iostream> 
using namespace std;

enum VrstaObaveze{ Seminarski, Parcijalni1, Parcijalni2, Integralni, Prakticni }; 
char * VrstaObav[] = { "Seminarski", "Parcijalni1", "Parcijalni2", "Integralni", "Prakticni" };
char * crt = { "\n-----------------------------------------------------\n" };

struct Datum{
	int * _dan;
	int * _mjesec;
	 int * _godina;

	void Unos(int d, int m, int g)
	{ 
		_dan = new int(d);
		_mjesec = new int(m);
		_godina = new int(g);
	} 
	void Ispis(){
		cout << *_dan << "/" << *_mjesec << "/" << *_godina << endl;
	}
	void Dealociraj()
	{ delete _dan; delete _mjesec; delete _godina; } 

	bool Uporedi(Datum * datumPredaje){
		if (*datumPredaje->_godina >* _godina)
			return false;
		else if (*datumPredaje->_godina == *_godina){
					if (*datumPredaje->_mjesec > *_mjesec)
						return false;
					else if (*datumPredaje->_mjesec == *_mjesec){
							if (*datumPredaje->_dan > *_dan)
								return false;
							else if (*datumPredaje->_dan == *_dan)
								return true;
			}

		}
		return true;
	}
};

struct ObavezeNaPredmetu{  
	VrstaObaveze _vrstaObaveze;
	Datum * _datumIzvrsenja; 
	int * _ocjena; // 5 - 10   
void Unos(VrstaObaveze vrsta, Datum * datum, int ocjena){
	_vrstaObaveze = vrsta;  
	_datumIzvrsenja = new Datum; 
	_datumIzvrsenja->Unos(*datum->_dan, *datum->_mjesec, *datum->_godina);
	_ocjena = new int(ocjena);
} 
void Ispis(){ 
	cout << "Vrsta obaveze: " << VrstaObav[_vrstaObaveze] << " " << " ; ocjena: " << *_ocjena;
	cout << "Datum izvrsenja: ";
	_datumIzvrsenja->Ispis();  
	cout << endl;
}  void Dealociraj()
{
	delete _datumIzvrsenja;
	delete _ocjena;
}
};

struct PolozeniPredmet{
	Datum * _datumPolaganja;
	ObavezeNaPredmetu * _listaIzvrsenihObaveza[10];
	int _trenutnoIzvrsenihObaveza;
	int _konacnaOcjena; //formira se na osnovu ocjena izvrsenih obaveza  

	void Dealociraj(){
		_datumPolaganja->Dealociraj();
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			_listaIzvrsenihObaveza[i]->Dealociraj();
	}
	void Ispis(){
		cout << "Datum polaganja ispita je: ";
		_datumPolaganja->Ispis();
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			_listaIzvrsenihObaveza[i]->Ispis();
		cout << "Konacna ocjena: " << _konacnaOcjena << endl;
	}
	void Unos(Datum * d){
		  //Na osnovu vrijednosti primljenog parametra izvrsiti inicijalizaciju odgovarajucih //atributa 
		_datumPolaganja = new Datum;
		_datumPolaganja->Unos(*d->_dan,*d->_mjesec,*d->_godina);
		for (int i = 0; i < 10; i++)
		{
			_listaIzvrsenihObaveza[i] = nullptr;
		}
		/*cout << "Unesite vrstu obaveze(1. Seminarski,2. Parcijalni1,3. Parcijalni2,4. Integralni,5. Prakticni)" << endl;
		int v;
		cin >> v;
		vrsta = (VrstaObaveze)--v;*/
		_trenutnoIzvrsenihObaveza = 0;
		_konacnaOcjena = NULL;

	}  
		bool DodajIzvrsenuObavezu(ObavezeNaPredmetu o){ 

			/*Funkcija ima zadatak da na osnovu primljenog parametra osigura dodavanje novoizvrsene obaveze na predmetu.
			Potrebno je onemoguciti dodavanje identicnih obaveza, te u zavisnosti od uspjesnosti operacije funkcija treba vratiti
			true ili false. */
			bool razlicita = true;
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++){
				if (o._vrstaObaveze != Seminarski && _listaIzvrsenihObaveza[i]->_vrstaObaveze == o._vrstaObaveze){
					razlicita = false;
				}
			}
			if (razlicita){
				_listaIzvrsenihObaveza[_trenutnoIzvrsenihObaveza] = new ObavezeNaPredmetu;
				_listaIzvrsenihObaveza[_trenutnoIzvrsenihObaveza]->Unos(o._vrstaObaveze, o._datumIzvrsenja, *o._ocjena);
				_trenutnoIzvrsenihObaveza++;
				return true;
			}
			return false;

		}
		int FormirajKonacnuOcjenu(Datum * datumPredaje){
			/*Funkcija je zaduzena za formiranje konacne ocjene na polozenom predmetu. Za formiranje konacne ocjene predmeta potrebno 
			je posjedovati polozen integralni ili dva parijcalna ispita. Ukoliko je ispit polozen putem parcijalnih ispita,
			student takodjer mora imati polozen i prakticni rad kojeg je predao prije datuma oznacenog parametrom datumPredaje.
			Ukoliko svi pomenuti uslovi nisu zadovoljeni, konacna ocjena treba biti postavljena na vrijednost 5.
			Funkcija vraca vrijednost atributa _konacnaOcjena*/
			bool imaPrvi = false;
			bool imaDrugi = false;
			bool imaIntegralni = false;
			bool imaPrakticni = false;
			int ocjena = 5;
			int pomocna, pomocna2, pomocna3;

			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]->_vrstaObaveze == Parcijalni1 && *_listaIzvrsenihObaveza[i]->_ocjena > 5){
					imaPrvi = true;
					pomocna = i;
				}
				if (_listaIzvrsenihObaveza[i]->_vrstaObaveze == Parcijalni2 && *_listaIzvrsenihObaveza[i]->_ocjena > 5){
					imaDrugi = true;
					pomocna2 = i;
				}
			}
			if (imaPrvi && imaDrugi){
				for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
				{
					if (_listaIzvrsenihObaveza[i]->_vrstaObaveze == Prakticni && *_listaIzvrsenihObaveza[i]->_ocjena > 5){
						imaPrakticni = true;
						pomocna3 = i;
					}
				}
				if (imaPrakticni){
					if (datumPredaje->Uporedi(_listaIzvrsenihObaveza[pomocna3]->_datumIzvrsenja)){
						ocjena = (*_listaIzvrsenihObaveza[pomocna]->_ocjena + *_listaIzvrsenihObaveza[pomocna2]->_ocjena +
							*_listaIzvrsenihObaveza[pomocna3]->_ocjena) / 3;
					}
					if (_konacnaOcjena > ocjena){
						return _konacnaOcjena;
					}
					else
						_konacnaOcjena = ocjena;
					return _konacnaOcjena;
					}
			}
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]->_vrstaObaveze == Integralni && *_listaIzvrsenihObaveza[i]->_ocjena > 5){
					imaIntegralni = true;
					pomocna = i;
				}
			}

			if (imaIntegralni){
				ocjena = *_listaIzvrsenihObaveza[pomocna]->_ocjena;
				if (_konacnaOcjena > ocjena)
					return _konacnaOcjena;
				else
					_konacnaOcjena = ocjena;
				return _konacnaOcjena;
			}
			_konacnaOcjena = 5;
			return _konacnaOcjena;
		}
	};
	int Pretraga(PolozeniPredmet * p, int max){
		/*Funkcija ima zadatak da ispise informacije o svim polozenim predmetima kod kojih je student imao najmanje dva seminarska rada,
		a koja su radena u junsko-julskom ispitnom roku. Da bi informacije o polozenom predmetu bile ispisane moraju biti ispunjeni
		svi uslovi neophodni za formiranje konacne ocjene. Nakon ispisa, funkcija vraca broj polozenih predmeta koji su zadovoljili
		pomenute kriterije.*/
		Datum datum;
		datum.Unos(30, 9, 2017);
		int seminarskih;
		int zadovoljili = 0;
		int ocjena;
		for (int i = 0; i < max; i++)
		{
			ocjena = p[i].FormirajKonacnuOcjenu(&datum);
			seminarskih = 0;
			for (int j = 0; j < p[i]._trenutnoIzvrsenihObaveza; j++)
			{
				if (ocjena > 5)
					if(p[i]._listaIzvrsenihObaveza[j]->_vrstaObaveze == Seminarski && 
						(*p[i]._listaIzvrsenihObaveza[j]->_datumIzvrsenja->_mjesec == 6  ||
						*p[i]._listaIzvrsenihObaveza[j]->_datumIzvrsenja->_mjesec == 7))
							seminarskih++;
			}
			if (seminarskih >= 2){
				p[i].Ispis();
				zadovoljili++;
			}
		}
		return zadovoljili;
	}
	void meni(int &izbor){
		cout << crt;
		cout << "1. DodajIzvrsenuObavezu " << endl;
		cout << "2. FormirajKonacnuOcjenu" << endl;
		cout << "3. Pretraga" << endl;
		cout << "4. Kraj" << endl;
		cout << crt;
		do
		{
			cout << "Unesite neki izbor: ";
			cin >> izbor;
			if (izbor < 1 || izbor>4)
				cout << "ne valja izbor, pokusaj ponovo" << endl;
		} while (izbor < 1 || izbor>4);
		system("cls");
	}
	void main(){
		
		//izbjegavajte koristenje vlastitog imena i prezimena. 
		//provjeriti validnost izvrsenja svih dostupnih funkcionalnosti
		int brojPredmeta;
		int izbor;
		int d, m, g;
		PolozeniPredmet * Predmeti = nullptr;
		cout << "unesite koliko predmeta imate" << endl;
		cin >> brojPredmeta;
		Predmeti = new PolozeniPredmet[brojPredmeta];

		Datum * datum = new Datum;

		for (int i = 0; i < brojPredmeta; i++)
		{
			cout << "Unesite datum polaganja predmeta br: " << i + 1 <<" (dan,mjesec,godina)"<< endl;
			cin >>d >>m >>g;
			datum[i].Unos(d, m, g);
			Predmeti[i].Unos(&datum[i]);
			
		}
		do
		{
			meni(izbor);
			if (izbor == 1){
				int rb;
				cout << "Odaberite za koji predmet dodajete izvrsenu obavezu" << endl;
				for (int i = 0; i < brojPredmeta; i++)
				{
					cout << "Predmet broj: " << i + 1 << endl;
					Predmeti[i].Ispis();
					cout << crt;
				}
				cout << "Unesite rb->";
				cin >> rb;
				rb--;


				VrstaObaveze v;
				int vr;
				cout << "Unesite vrstu obaveze koju ste polozili" << endl;
				cout << "1. Seminarski,2. Parcijalni1,3. Parcijalni2,4. Integralni,5. Prakticni" << endl;
				do
				{
					cin >> vr;
					if (vr < 1 || vr>5)
						cout << "ponovi unos" << endl;
				} while (vr < 1 || vr>5);
				v = (VrstaObaveze)--vr;
				Datum * dat;
				dat = new Datum;
				int d, m, g;
				cout << "Unesite datum kada ste polagali (Dan,Mjesec,Godina): ";
				cin >> d >> m >> g;
				dat->Unos(d, m, g);
				int ocjena;
				cout << "Unesite ocjenu za ovaj predmet ";
				cin >> ocjena;
				ObavezeNaPredmetu o;
				o.Unos(v, dat, ocjena);
				if (Predmeti[rb].DodajIzvrsenuObavezu(o))
					cout << "Obaveza je dodana" << endl;
				else
					cout << "Obaveza nije dodana" << endl;

				delete dat->_dan; delete dat->_mjesec; delete dat->_godina;
				delete dat; dat = nullptr;
			}
			if (izbor == 2){
				Datum *dat;
				dat = new Datum;
				int rb;
				cout << "Unesite rok do kada su radovi trebali biti najkasnije zavrseni (DD,MM,GGGG)" << endl;
				int d, m, g;
				cin >> d >> m >> g;
				dat->Unos(d, m, g);
				system("cls");
				for (int i = 0; i < brojPredmeta; i++)
				{
					cout << "Predmet broj: " << i + 1 << endl;
					Predmeti[i].Ispis();
					cout << crt;
				}
				cout << "Odaberite za koji predmet zelite formirati konacnu ocjenu: " << endl;
				cout << "Unesite rb->";
				cin >> rb;
				rb--;
				int ocjena;
				ocjena=Predmeti[rb].FormirajKonacnuOcjenu(dat);
				cout << "Formirana konacna ocjena je: " << ocjena << endl;

				delete dat->_dan; delete dat->_mjesec; delete dat->_godina;
				delete dat; dat = nullptr;

			}
			if (izbor == 3){
				int brojPolozenihPredmeta;
				brojPolozenihPredmeta = Pretraga(Predmeti, brojPredmeta);
				cout << "Broj polozenih predmeta koji zadovoljavaju uslove je: " << brojPolozenihPredmeta << endl;
			}
		} while (izbor!=4);

		
		for (int i = 0; i <brojPredmeta; i++)
			Predmeti[i].Dealociraj();
		Predmeti = nullptr;
		delete datum->_dan; delete datum->_mjesec; delete datum->_godina;
		delete datum; datum = nullptr;

		system("pause");
	}


________________________________________________________________


//#include <iostream>
//using namespace std; 
//
//char * GetPosljednji(char * tekst, char * trazim, int & brojac){
//	char * pok = strstr(tekst, trazim);
//	if (pok == NULL) 
//		return tekst - 1; 
//	toupper(pok[0]); 
//	return GetPosljednji(pok + 1, trazim, ++brojac);
//}
//void main()
//{
//	char tekst[] = "Danas je cijena ananasa izuzetno povoljna!"; 
//	char trazim[] = "na";
//	int brojac = 0;
//	char * pok = GetPosljednji(tekst, trazim, brojac);
//	int rezultat = pok - tekst;
//	cout << rezultat << endl; /*1. _________________*/
//	cout << brojac << endl; /*2. _________________*/ 
//	itoa(rezultat, pok, 10);  cout << tekst << endl; /*3. _________________*/
//}

#include <iostream>
using namespace std;

char * crt = { "\n--------------------------------------------\n" };

struct Datum{ 
	int dan, mjesec, godina;

	bool Uporedi(Datum starijiOd){
		if (godina > starijiOd.godina)
			return false;
		else if (godina == starijiOd.godina){
			if (mjesec > starijiOd.mjesec)
				return false;
			else if (mjesec == starijiOd.mjesec){
				if (dan > starijiOd.dan)
					return false;
				else if (dan == starijiOd.dan)
					return false;
			}
		}
		return true;
	}
	void Ispis(){
		cout << dan << "/" << mjesec << "/" << godina << endl;
	}

}; 
struct Student{
	char indeks[9];//IB130130 
	char imePrezime[30]; 
	Datum datumRodjenja;

	void Ispis(){
		cout << "Index: " << indeks << endl;
		cout << "Ime i Prezime: " << imePrezime << endl;
		datumRodjenja.Ispis();
	}
};
char * GetSljedeciBrojIndeksa(char * posljednji){ 
	/*Funkcija treba da vrati sljedeci broj indeksa (u odnosu na onaj koji je primljen kao parametar)prateci format IB130XXX 
	pri cemu je fiksni dio u oznaci indeksa IB130, a posljednje 3 oznake se mijenjaju. Voditi racuna da broj indeksa uvijek
	posjeduje 8 znakova*/ 

	char * temp = new char[9];
	strcpy_s(temp, 9, "IB130");
	strcat_s(temp, 9, posljednji);
	return temp;
}
Student * GetStudentePoDatumuRodjenja(Student * lista, int max, Datum starijiOd,int &b){
	/*Funkcija treba da vrati niz studenata koji su rodeni nakon datuma rodenja definisanog parametrom starijiOD. Ako ne postoji 
	niti jedan student koji zadovoljava uslove pretrage, onda funkcija vraca NULL*/

	Student * Stariji = nullptr;
	
	for (int i = 0; i < max; i++)
	{
		if (lista[i].datumRodjenja.Uporedi(starijiOd)){
			Student * temp = new Student[b + 1];

			for (int j = 0; j < b; j++)
				temp[j] = Stariji[j];
			temp[b] = lista[i];
			Stariji = temp;
			b++;
			temp = nullptr;
		}
	}
	if (Stariji == nullptr)
		return NULL;
	return Stariji;
}
int main(){ 
	//1. korisniku omoguciti da odredi koliko objekata tipa Student zeli kreirati
	// Objekte kreirati u dinamickoj memoriji
	Student * Studenti = nullptr;
	int brojStudenata;
	cout << "Uneiste broj studenata: " << endl;
	cin >> brojStudenata;
	cin.ignore();
	Studenti = new Student[brojStudenata];

	//2. korisniku omoguciti da unutar main funkcije inicijalizuje vrijednosti 
	// atributa svakog studenta. Tom prilikom iskoristiti funkciju
	// GetSljedeciBrojIndeksa
	char * temp=new char[4];
	for (int i = 0; i < brojStudenata; i++)
	{
		cout << "Uneiste zadnje tri cifre broja indexa za studenta: " << i + 1;
		cin.getline(temp, 4);
		char * index = GetSljedeciBrojIndeksa(temp);
		cout << "Broj indeksa je: " << index << endl;
		strcpy_s(Studenti[i].indeks, 9, index);
		cout << "Uneiste ime i prezime: ";
		cin.getline(Studenti[i].imePrezime, 30);
		cout << endl;
		cout << "Unesite datum rodjenja: ";
		cout << "Dan: " << endl; cin >> Studenti[i].datumRodjenja.dan;
		cout << "Mjesec: "<< endl; cin>> Studenti[i].datumRodjenja.mjesec;
		cout << "Godina: "<< endl; cin>> Studenti[i].datumRodjenja.godina;
		cin.ignore();
	}
	//3. korisniku omoguciti pretragu studenata po datumu rodjenja, te ispisati 
	// rezultat pretrage 
	int b = 0;
	cout << "Unesite datum rodjenja studenta kako bi vam vratili ime niz studenata starijih od ovog datuma: " << endl;
	Datum d;
	cout << "Dan: " << endl; cin >> d.dan;
	cout << "Mjesec: " << endl; cin >> d.mjesec;
	cout << "Godina: " << endl; cin >> d.godina;
	Student * Niz = NULL;
	Niz = GetStudentePoDatumuRodjenja(Studenti, brojStudenata, d, b);
	if (Niz != NULL){
		for (int i = 0; i < b; i++)
		{
			Niz[i].Ispis();
			cout << crt;
		}
	}

	//4. izvrsiti potrebne dealokacije  

	delete Studenti; Studenti = nullptr;
	delete Niz; Niz = nullptr;
	system("pause");
	return 0;
} 

_________________________________________________________________

#include<iostream> 
using namespace std;

enum Vrsta{ Pitanje, Komentar, Zadatak, Rjesenje, Spam };
enum Nivo { Pocetnik, Clan, NapredniClan, Moderator };

char  * NivoTxt[] = { "Pocetnik", "Clan", "NapredniClan", "Moderator" };
char * crt = {"\n----------------------------------------------\n"};

struct Datum{ 
	int _dan, _mjesec, _godina;

	void Unos(int d, int m, int g){ 
		_dan = d;
		_mjesec = m;
		_godina = g;
	} 
	void Ispis(){
		cout << _dan << "/" << _mjesec << "/" << _godina << endl; }

	bool DaLiSuIsti(Datum * datum){
		if (_dan == datum->_dan && _mjesec == datum->_mjesec && _godina == datum->_godina)
			return true;
		return false;
	}
};

char * Enkriptuj(char * lozinka){
	int velicina = strlen(lozinka) + strlen("drvo") + 1;
	char * nova = new char[velicina];
	strcpy_s(nova, velicina, lozinka);
	strcat_s(nova, velicina, "drvo");
	strcat_s(nova, velicina, "\0");
	int brojac = 0;
	char a;
	while (brojac < velicina-1){
		a = nova[brojac];
		a = (int)a + 1;
		nova[brojac] = a;
		brojac++;
	}
	return nova;
}

char * Dekriptuj(char * lozinka){
	int velicina = strlen(lozinka) - strlen("drvo")+1;
	int zaKopirati = strlen(lozinka) - (strlen("drvo"));

	char * nova = new char(velicina);
	strncpy_s(nova, velicina, lozinka, zaKopirati);
	strcat_s(nova, velicina, "\0");
	int brojac = 0;
	char a;
	while (brojac < velicina - 1){
		a = nova[brojac];
		a = (int)a - 1;
		nova[brojac] = a;
		brojac++;
	}
	return nova;
}

struct Post{
	Vrsta _vrstaPosta;
	Datum * _datumPostavljanja;
	char * _sadrzaj;
	char _IP[16];//IP adresa sa koje je post postavljen 192.168.100.100 
	int _brojZahvala; // broj zahvala na post -thanks 
	bool _vidljiv; 

void Unos(Vrsta * vrsta, Datum * datum, char * sadrzaj, char * IP){
	_vrstaPosta = *vrsta;
	_datumPostavljanja = new Datum; 
	_datumPostavljanja->Unos(datum->_dan, datum->_mjesec, datum->_godina);
	_sadrzaj = new char[strlen(sadrzaj) + 1];
	strcpy_s(_sadrzaj, strlen(sadrzaj) + 1, sadrzaj);
	strcpy_s(_IP,16, IP); 
	_brojZahvala = 0;
	_vidljiv = true;
} 
void Vidljivost(bool vidljivost){
	_vidljiv = vidljivost;
} 
void Zahvala(){
	_brojZahvala++;
} 
void Ispis(){ 
	if (_vidljiv){
		cout << _vrstaPosta << " " << _sadrzaj << " " << _brojZahvala << " " << _IP << endl;
		_datumPostavljanja->Ispis();
		cout << endl;
	}
	else
		cout << "Post nije vidljiv" << endl;
} 
void Dealociraj(){
	delete _datumPostavljanja;
	delete[] _sadrzaj;
}
};
struct User{
	Datum _datumPristupa; //datum registracije 
	char * _korisnickoIme; 
	char * _lozinka; 
	Post * _postovi; 
	int _trenutnoPostova;
	Nivo _nivo;  

	void Dealociraj(){
		delete[] _korisnickoIme;
		delete[] _lozinka;
		for (int i = 0; i < _trenutnoPostova; i++)
			_postovi[i].Dealociraj();
	}
	void Ispis(){
		cout << "_datumPristupa: ";
		_datumPristupa.Ispis();
		cout << "_korisnickoIme: " << _korisnickoIme << endl;
		char * kriptovanaLozinka;
		kriptovanaLozinka = Enkriptuj(_lozinka);
		cout << "_lozinka: " << kriptovanaLozinka << endl;
		_lozinka = Dekriptuj(kriptovanaLozinka);
		for (int i = 0; i < _trenutnoPostova; i++)
			_postovi[i].Ispis();
		if (_nivo != -1)
			cout << "Nivo: " << NivoTxt[_nivo] << endl;
	}

	void Unos(Datum datum, char * korisnickoIme, char * lozinka){ 
		/*Na osnovu vrijednosti primljenog parametra izvrsiti inicijalizaciju odgovarajucih atributa. Lozinku je potrebno
		kriptovati na nacin na koji odaberete (predlozite neku logiku modifikacije znakova lozinke). Bitno je da sadrzaj 
		lozinke nije citljiv prilikom ispisa, ali da se moze porediti sa drugim lozinkama, odnosno da se po istom principu
		moze i dekriptovati*/
		_datumPristupa.Unos(datum._dan, datum._mjesec, datum._godina);

		_korisnickoIme = new char[strlen(korisnickoIme) + 1];
		strcpy_s(_korisnickoIme, strlen(korisnickoIme) + 1, korisnickoIme);
		
		_lozinka = new char[strlen(lozinka) + 1];
		strcpy_s(_lozinka, strlen(lozinka) + 1, lozinka);

		_postovi = nullptr;
		_trenutnoPostova = 0;
		_nivo =(Nivo) -1;

	} 
	bool AddNoviPost(Post o){  
		/*Funkcija ima zadatak da na osnovu primljenog parametra osigura dodavanje novog posta. Potrebno je onemoguciti dodavanje
		identicnih postova, te u zavisnosti od uspjesnosti operacije funkcija treba vratiti true ili false.*/
		bool identican = false;;
		Post * temp = new Post[_trenutnoPostova + 1];
		for (int i = 0; i < _trenutnoPostova; i++)
			temp[i] = _postovi[i];

		
		for (int i = 0; i < _trenutnoPostova; i++)
		{
			if (strstr(temp[i]._sadrzaj, o._sadrzaj) != NULL && strcmp(temp[i]._sadrzaj, o._sadrzaj) == 0 &&
				temp[i]._vrstaPosta == o._vrstaPosta){
				identican = true;
			}
		}
		if (identican == false){
			temp[_trenutnoPostova].Unos(&o._vrstaPosta, o._datumPostavljanja, o._sadrzaj, o._IP);
			_trenutnoPostova++;
			_postovi = temp;
			temp = nullptr;
			return true;
		}
		else
			cout << "Vec postoji identican post " << endl;
		return false;
	}
	Nivo FormirajNivo(){  
		/*Na osnovu broj zahvala na postovima funkcija odredjuje nivo korisnika (nivo = BrojZahvala/BrojPostova) , a prema
		sljedecim pravilima:   0 - 10 ---- Pocetnik,   11 - 30 ---- Clan,   31 - 70 ---- NapredniClan,   > 71 - ---- Moderator 
		na kraju funkcija vraca novoformirani nivo korisnika.*/
		Nivo n;
		int brZahvala = 0;
		int nivo;
		for (int i = 0; i < _trenutnoPostova; i++)
			brZahvala += _postovi[i]._brojZahvala;
		nivo = brZahvala / _trenutnoPostova;
		if (nivo >= 0 && nivo <= 10)
			n = Pocetnik;
		else if (nivo >= 11 && nivo <= 30)
			n = Clan;
		else if (nivo >= 31 && nivo <= 70)
			n = NapredniClan;
		else if (nivo >= 71)
			n = Moderator;
		
		return n;
	}
	Post * GetPostovePoSadrzaju(char * sadrzaj){
		/*Funkcija vraca niz postova koji posjeduju dio sadrzaja odredjenog vrijednoscu parametra. Ukoliko trazeni sadrzaj ne 
		postoji funkcija vraca NULL*/
		int _kopiranihSadrzaja = 0;
		Post * identicniPostovi = nullptr;
		Post * temp = nullptr;
		for (int i = 0; i < _trenutnoPostova; i++)
		{
			if (strstr(_postovi[i]._sadrzaj, sadrzaj) != NULL){
				temp = new Post[_kopiranihSadrzaja+1];

				for (int i = 0; i < _kopiranihSadrzaja; i++)
					temp[i] = identicniPostovi[i];

				for (int i = 0; i < _kopiranihSadrzaja; i++)
					delete[] & identicniPostovi[i];
				identicniPostovi = nullptr;

				temp[_kopiranihSadrzaja] = _postovi[i];
				_kopiranihSadrzaja++;
			}
			identicniPostovi = temp;
			temp = nullptr;
		}
		if (identicniPostovi != NULL){
			cout << "slicni postovi su: " << endl;
			for (int i = 0; i < _kopiranihSadrzaja; i++)
			{
				cout << identicniPostovi[i]._sadrzaj << endl;
				cout << crt;
			}
			return identicniPostovi;
		}
		return NULL;


	}

	void DodajLajk(){
		int brPosta;
		char slovo;
		for (int i = 0; i < _trenutnoPostova; i++)
			_postovi[i].Ispis();
		do
		{
			cout << "Unesi broj posta kome zelis dati lajk: " << endl;
			cin >> brPosta;
			_postovi[--brPosta].Zahvala();
			cout << "POSTI IMA: " << _postovi[brPosta]._brojZahvala << " LAJKOVA" << endl;
			cout << "Ako zelis dodati jos lajkova na bilo koji post od ovog korisnika pritisni D" << endl;
			cin >> slovo;
			slovo = toupper(slovo);
		} while (slovo == 'D');
	}
};

User * Pretraga(User * u, int max){ 
	/*Funkcija ima zadatak da pronadje i vrati korisnika koji je sa odredjene IP adrese u odredjeno vrijeme (datum) pristupao sistemu.
	Vrijednost IP adrese i datuma za pretragu se unosi na pocetku izvrsenja funkcije. Prije vracanja pokazivaca na pronadjenog
	korisnika funkcija treba postaviti vidljivost svih njegovih postova na false. Ukoliko trazeni korisnik ne postoji funkcija
	treba da vrati NULL*/
	Datum * datumProvjera;
	char IP[16];
	cout << "Unesite IP adresu i datum kako bi pretrazli da li je iko sa te adrese pristupao sistemu tog datuma: " << endl;
	cout << "Unesite IP adresu format(---.---.---.---)" << endl;
	cin.getline(IP, 16);
	datumProvjera = new Datum;
	int d, m, g;
	cout << "Unesite datum formata: ";
	cout << "Dan: ";
	cin >> d;
	cout << "Mjesec: ";
	cin >> m;
	cout << "Godina: ";
	cin >> g;
	cin.ignore();
	datumProvjera->Unos(d, m, g);

	for (int i = 0; i < max; i++)
	{
		if (u[i]._datumPristupa.DaLiSuIsti(datumProvjera)){
			for (int j = 0; j < u[i]._trenutnoPostova; j++)
				if (strstr(u[i]._postovi[j]._IP, IP)){
				for (int j = 0; j < u[i]._trenutnoPostova; j++)
					u[i]._postovi[j]._vidljiv = false;
				return &u[i];
				}
		}
	}
	
	return NULL;
}


void meni(int &izbor){
	cout << crt;
	cout << "1. AddNoviPost " << endl;
	cout << "2. FormirajNivo" << endl;
	cout << "3. GetPostovePoSadrzaju" << endl;
	cout << "4. Pretraga" << endl;
	cout << "5. Dodaj lajk(zahvalu)" << endl;
	cout << "6.Ucini vidljivim sve postove" << endl;
	cout << "7. Kraj" << endl;
	cout << crt;
	do
	{
		cout << "Unesite neki izbor: ";
		cin >> izbor;
		cin.ignore();
		if (izbor < 1 || izbor>7)
			cout << "ne valja izbor, pokusaj ponovo" << endl;
	} while (izbor < 1 || izbor>7);
	system("cls");
}
void main(){
	//izbjegavajte koristenje vlastitog imena i prezimena.
	//provjeriti validnost izvrsenja svih dostupnih funkcionalnosti  1. 

	int izbor;
	User * Useri = nullptr;
	int brojUsera;
	cout << "Unesite koliko korisnika zelite: " << endl;
	cin >> brojUsera;
	cin.ignore();
	Useri = new User[brojUsera];

	int d, m, g;
	Datum dat;
	char imePrezime[40];
	char * lozinka;
	char loz[100];
	for (int i = 0; i < brojUsera; i++)
	{
		cout << "USER BROJ: " << i + 1 << endl;
		cout << "Uneiste datum pristupa korisnika ";
		cout << "Dan: ";
		cin >> d;
		cout << "Mjesec: ";
		cin >> m;
		cout << "Godina: ";
		cin >> g;
		cin.ignore();
		dat.Unos(d, m, g);
		cout << "Ime i prezime: ";
		cin.getline(imePrezime, 40);
		cout << "Uneiste lozinku: ";
		cin.getline(loz, 100);
		lozinka = new char[strlen(loz) + 1];
		strcpy_s(lozinka, strlen(loz) + 1, loz);
		Useri[i].Unos(dat, imePrezime, lozinka);
	}
	do
	{
		meni(izbor);
		switch (izbor)
		{
		case 1:{
			Post * p = new Post;
			char Sadrzaj[300];
			int v;
			cout << "Unesite vrstu posta (1.Pitanje,2. Komentar,3. Zadatak,4. Rjesenje,5. Spam) ";
			cin >> v;
			p->_vrstaPosta = (Vrsta) --v;
			cout << "Uneiste datumPostavljanja ";
			int d, m, g;
			cout << "Dan: ";
			cin >> d;
			cout << "Mjesec: ";
			cin >> m;
			cout << "Godina: ";
			cin >> g;
			cin.ignore();
			p->_datumPostavljanja = new Datum;
			p->_datumPostavljanja->Unos(d, m, g);

			cout << "Uneiste sadrzaj posta: ";
			cin.getline(Sadrzaj, 300);
			p->_sadrzaj = new char[strlen(Sadrzaj) + 1];
			strcpy_s(p->_sadrzaj, strlen(Sadrzaj) + 1, Sadrzaj);

			cout << "Uneiste IP adresu sa koje unosite post ";
			cin.getline(p->_IP, 16);
			p->_brojZahvala = 0;
			p->_vidljiv = true;

			cout << "--------ISPIS SVIH USERA---------" << endl;
			for (int i = 0; i < brojUsera; i++)
			{
				cout << "ISPIS USERA BROJ: " << i + 1 << endl;
				Useri[i].Ispis();
				cout << crt;
			}
			int rb;
			cout << "Unesite rb usera kojem zelite dodati novi post" << endl;
			cin >> rb;
			if (Useri[--rb].AddNoviPost(*p))
				cout << "Post uspjesno dodan" << endl;

			break;
		}
		case 2:{
			int rb;
			Nivo n;
			cout << "Unesite rb usera kojem zelite formirati nivo" << endl;
			cin >> rb;
			n = Useri[--rb].FormirajNivo();
			Useri[--rb]._nivo = n;
			cout << "Nivo korisnika je: " << NivoTxt[n] << endl;
			break;
		}
		case 3:{
			char sadrzaj[300];
			Post * postovi = nullptr;
			cout << "Unesite sadrzaj kako bi vam vratili postovve sa istim sadrzajem od jednog korisnika" << endl;
			cin.getline(sadrzaj, 300);
			int rb;
			cout << "Unesite rb usera od kojeg zelite pretraziti postove" << endl;
			cin >> rb;
			cin.ignore();
			postovi = Useri[--rb].GetPostovePoSadrzaju(sadrzaj);
			break;
		}
		case 4:{
			User * u;
			cout << "--------ISPIS SVIH USERA---------" << endl;
			for (int i = 0; i < brojUsera; i++)
			{
				cout << "ISPIS USERA BROJ: " << i + 1 << endl;
				Useri[i].Ispis();
				cout << crt;
			}
			int rb;
			cout << "unesite rb usera kojeg zelite pretraziti" << endl;
			cin >> rb;
			cin.ignore();
			u = Pretraga(&Useri[--rb], brojUsera);
			if (u != NULL){
				u->Ispis();
			}
			break;
		}
		case 5:{
			int rb;
			cout << "--------ISPIS SVIH USERA---------" << endl;
			for (int i = 0; i < brojUsera; i++)
			{
				cout << "ISPIS USERA BROJ: " << i + 1 << endl;
				Useri[i].Ispis();
				cout << crt;
			}
			cout << "Unesite rb korisnika kome zelite dodati lajk" << endl;
			cin >> rb;
			Useri[--rb].DodajLajk();
			break;
		}
		case 6:{
			int rb;
			cout << "--------ISPIS SVIH USERA---------" << endl;
			for (int i = 0; i < brojUsera; i++)
			{
				cout << "ISPIS USERA BROJ: " << i + 1 << endl;
				Useri[i].Ispis();
				cout << crt;
			}
			cout << "Unesite rb korisnika kome zelite uciniti vidljivim sve postove" << endl;
			cin >> rb;
			rb--;
			for (int i = 0; i < Useri[rb]._trenutnoPostova; i++){
				if (Useri[rb]._postovi[i]._vidljiv == false)
					Useri[rb]._postovi[i]._vidljiv = true;
			}
		}
		case 7:{
			cout << "DOVIDJENJA" << endl;
		}
		}
	} while (izbor!=7);

	for (int i = 0; i < brojUsera; i++)
		Useri[i].Dealociraj();
	Useri = nullptr;

	system("pause");
}

_____________________________________________________________________

#include<iostream>
using namespace std;

char * crt = { "\n--------------------------------------\n" };

enum Kompanija{ Pegasus, TurkishAirlines, AustrianAirlines, FlyEmirates };
char * KompanijaChar[] = { "Pegasus", "TurkishAirlines", "AustrianAirlines", "FlyEmirates" };

int ID = 1;

struct Putnik{ 
	int _putnikID; 
	char * _imePrezime; 
	float _brojPredjenihMilja; 

	void Unos(char * imePrezime){ 
		int size = strlen(imePrezime) + 1; 
		_imePrezime = new char[size]; 
		strcpy_s(_imePrezime, size, imePrezime); 
		_brojPredjenihMilja = 0;
		_putnikID = ID++;
	} 
	void Info(){
		cout << "[" << _putnikID << "] " << _imePrezime <<    " (" << _brojPredjenihMilja << " milja)" << endl;
	}
	void Dealociraj(){
		delete[] _imePrezime;
		_imePrezime = nullptr;
	}  
	void DodajPredjeneMilje(int brojMilja){
		_brojPredjenihMilja += brojMilja;
	}
};

struct Rezervacija{
	Putnik _putnik;
	int _oznakaSjedista;
	float _cijena;

	void Unos(Putnik putnik, int oznaka, float cijena){
		_putnik.Unos(putnik._imePrezime);
		_oznakaSjedista = oznaka; 
		_cijena = cijena;
	}
	void Info(){  
		_putnik.Info();
		cout << "Sjediste:" << _oznakaSjedista << " Cijena: " << _cijena << endl;
	} 
	void Dealociraj(){
		_putnik.Dealociraj();
	}
};
struct Let{
	Kompanija _kompanija; 
	char * _pocetak;//pocetna lokacija  
	char * _destinacija; 
	Rezervacija * _rezervacije; 
	int _brojMjesta; //maksimalan broj mjesta na letu   
	float _brojMilja; //odnosi se na duzinu leta – broj predjenih milja 
	float _cijenaKarte; 

	void Ispis(){
		cout << "Kompanija: " << KompanijaChar[_kompanija] << endl;
		cout << "Pocetna lokacija: " << _pocetak << endl;
		cout << "Krajnja lokacija: " << _destinacija << endl;
		cout << "Duzina leta:" << _brojMilja << " milja" << endl;
		cout << "Cijena karte: " << _cijenaKarte << " Rubalja" << endl;
	}

	void Unos(Kompanija kompanija, char * pocetak, char * destinacija,   int brojMjesta, float brojMilja, float cijena){ 
	_kompanija = kompanija;
	int size = strlen(pocetak) + 1;
	_pocetak = new char[size]; 
	strcpy_s(_pocetak, size, pocetak); 
	size = strlen(destinacija) + 1; 
	_destinacija = new char[size]; 
	strcpy_s(_destinacija, size, destinacija); 
	_brojMjesta = brojMjesta;
	_rezervacije = new Rezervacija[_brojMjesta]; 
	Putnik temp;
	temp.Unos("<SLOBODNO MJESTO>"); 
	for (int i = 0; i < _brojMjesta; i++)
		_rezervacije[i].Unos(temp, i, 0);
	_brojMilja = brojMilja; 
	_cijenaKarte = cijena; 
	}
	void Dealociraj(){ 
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani   za potrebe objekta tipa Let*/
		delete[] _pocetak; _pocetak = nullptr;
		delete[] _destinacija; _destinacija = nullptr;
		_rezervacije->Dealociraj();
		delete _rezervacije;
	} 
	bool AddRezervaciju(Putnik * p){  
		/*na samom pocetku, funkcija treba ispisati listu svih SLOBODNIH sjedista na letu, te putniku omoguciti da odabere
		neko do njih. voditi racuna o broju   predjenih milja prilikom formiranja cijene karte. ako je putnik presao
		od 10000 do 50000 milja onda ostvaruje popust od 10% na punu cijenu karte, od 50000 do 100000 milja ostvaruje 
		popust od 20% na punu cijenu karte, a   preko 100000 milja ostvaruje popust od 30% na punu cijenu karte.  
		onemoguciti dodavanje rezervacija sa identicnim putnicima (isti putnikID i   imePrezime). u zavisnosti od uspjesnosti 
		funkcija vraca true ili false */
		for (int i = 0; i < _brojMjesta; i++)
		{
			if (strcmp(_rezervacije[i]._putnik._imePrezime, p->_imePrezime) == 0 && _rezervacije[i]._putnik._putnikID == p->_putnikID){
				cout << "rezervacija se ne moze dodati jer vec postoji taj putnik rezervisan" << endl;
				return false;
			}
		}

		for (int i = 0; i < _brojMjesta; i++)
		{
			cout << "-------SVA SLOBODNA MJESTA-------" << endl;
			if (strcmp(_rezervacije[i]._putnik._imePrezime, "<SLOBODNO MJESTO>") == 0){
				cout << "Slobodno mjesto broj: " << i + 1 << endl;
				_rezervacije[i]._putnik.Info();
				cout << crt;
			}
		}
		int rb;
		cout << "Unesite rb slobodnog mjesta za rezervaciju";
		cin >> rb;
		rb--;
		_rezervacije[rb].Unos(*p, rb, _cijenaKarte);
		return true;
	} 
}; 
float GetMiljeByKompanija(Let * letovi, int maxLetova, Kompanija kompanija, Putnik * putnik){
	/*funkcija vraca broj milja koje je putnik (proslijedjen kao parametar funkcije)  ostvario putujuci sa kompanijom 
	koja je takodjer proslijedjena kao parametar  funkcije*/
	float milje = 0;
	for (int i = 0; i < maxLetova; i++)
	{
		if (letovi[i]._kompanija == kompanija){
			for (int j = 0; j < letovi[i]._brojMjesta; j++)
			{
				if (strcmp(letovi[i]._rezervacije->_putnik._imePrezime, putnik->_imePrezime) == 0)
					milje += letovi[i]._brojMilja;
			}
		}
	}
	return milje;
}
int menu(){
	int izbor;
	cout << "-----------MENI---------" << endl;
	cout << "1. unesite let" << endl;
	cout << "2. dodaj novu rezervaciju" << endl;
	cout << "3. predjene milje za trazenu kompaniju" << endl;
	cout << "4. Unesite putnika" << endl;
	cout << "5. Kraj" << endl;
	cout << crt;
	do
	{
		cout << "Unesite izbor-> ";
		cin >> izbor;
		if (izbor < 1 || izbor>5)
			cout << "greska, pokusajte ponovo" << endl;
	} while (izbor < 1 || izbor>5);
	cin.ignore();
	system("cls");
	return izbor;
}
void main(){

	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti*/
	Let * letovi = nullptr;
	letovi = new Let[50];
	int trenutnoLetova = 0;
	int izbor;

	Putnik * putnici = new Putnik[50];
	int trenutnoPutnika = 0;
	do
	{
		izbor = menu();

		if (izbor == 1){
			if (trenutnoLetova <= 50){
				int v;
				cout << "Unesite vrstu kompanije za ovaj let: 1. Pegasus, 2. TurkishAirlines, 3. AustrianAirlines, 4. FlyEmirates " << endl;
				cin >> v;
				cin.ignore();
				Kompanija kompanija;
				kompanija = (Kompanija)--v;
				cout << "Unesite pocetnu destinaciju: ";
				char * pocetna = new char[20];
				cin.getline(pocetna, 20);
				cout << "Unesite Krajnju destinaciju";
				char krajnja[20];
				cin.getline(krajnja, 20);
				cout << "Unesite max broj mjesta u za let:";
				int brojMjesta;
				cin >> brojMjesta;
				cout << "Unesite duzinu puta(razdaljinu izmedju dva grada)" << endl;
				float brojMlja;
				cin >> brojMlja;
				cout << "Unesite cijenu za ovaj let;";
				float cijena;
				cin >> cijena;

				letovi[trenutnoLetova].Unos(kompanija, pocetna, krajnja, brojMjesta, brojMlja, cijena);
				trenutnoLetova++;
			}
			else
				cout << "Svi letovi su popunjeni" << endl;
		}
		else if (izbor == 2){
			if (trenutnoPutnika != 0){
				int rb;
				bool dodanLet;
				for (int i = 0; i < trenutnoLetova; i++){
					cout << "---LET BROJ: " << i + 1 << " -----" << endl;
					letovi[i].Ispis();
				}
				cout << "uneiste rb leta sa kojim zelite putovati" << endl;
				cin >> rb;
				cin.ignore();
				rb--;
				for (int i = 0; i < trenutnoPutnika; i++){
					cout << "Putnik broj: " << i + 1;
					putnici[i].Info();
				}
				cout << "Unesite rb putnika za kojeg zelite rezervisati let" << endl;
				int rbPutnika;
				cin >> rbPutnika;
				rbPutnika--;
				dodanLet = letovi[rb].AddRezervaciju(&putnici[rbPutnika]);
				if (dodanLet){
					cout << "Rezervacija je uspjesno dodana" << endl;
					putnici[rbPutnika]._brojPredjenihMilja += letovi[rb]._brojMilja;
				}
				else
					cout << "Rezervacija nije uspjesno dodana" << endl;
			}
			else
				cout << "Morate prvo dadati putniuka kako biste rezervisali za nekoga" << endl;
		}
		else if (izbor == 3){
			int rb, kmp;
			Kompanija k;
			float milje;
			for (int i = 0; i < trenutnoPutnika; i++){
				cout << "Putnik broj: " << i + 1 << endl;
				putnici[i].Info();
				cout << crt;
			}
			cout << "odaberite putnika kojeg zelite pretrazivati" << endl;
			cin >> rb;
			cin.ignore();
			rb--;
			cout << "Unesite kompaniju koju pretrazujete  1. Pegasus, 2. TurkishAirlines, 3. AustrianAirlines, 4. FlyEmirates " << endl;
			cin >> kmp;
			cin.ignore();
			k = (Kompanija)--kmp;
			milje = GetMiljeByKompanija(letovi, trenutnoLetova, k, &putnici[rb]);
			cout << "Putnik " << putnici[rb]._imePrezime << " je sa kompanijom " << KompanijaChar[k] << " je presao " << milje << "milja" << endl;
		}
		else if (izbor == 4){
			char ime[30];
			cout << "Unesite ime i prezime putnika ";
			cin.getline(ime, 30);
			putnici[trenutnoPutnika].Unos(ime);
			trenutnoPutnika++;
		}
	} while (izbor!=5);

	system("pause");
}

_____________________________________________________________________

#include <iostream>
using namespace std;

enum Opstina{ Opstina1, Opstina2, Opstina3, Opstina4 };
char * OpstineChar[] = { "Opstina1", "Opstina2", "Opstina3", "Opstina4" };
enum Kandidati{ Kandidat1, Kandidat2, Kandidat3, Kandidat4 };
char * KandidatiChar[] = { "Kandidat1", "Kandidat2", "Kandidat3", "Kandidat4" };

struct Datum{
	int _dan, _mjesec, _godina;
	void Unos(int d, int m, int g){ 
		_dan = d;
		_mjesec = m;
		_godina = g;
	}
	void Ispis(){
		cout << _dan << "/" << _mjesec << "/" << _godina << endl;
	}

	bool daLiJePunoljetan(Datum datumRodjenja){
		if (_godina - datumRodjenja._godina > 18)
			return true;
		else if (_godina - datumRodjenja._godina == 18){
			if (_mjesec > datumRodjenja._mjesec)
				return true;
		}
		return false;
	}
};
struct Osoba{
	Datum _datumRodjenja;
	char * _imePrezime;
	char _JMBG[14];
	Opstina _Prebivaliste;
	void unos(Datum d, char * ip, char jmbg[], Opstina p){
		_datumRodjenja.Unos(d._dan, d._mjesec, d._godina);
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime, strlen(ip) + 1, ip);
		strcpy_s(_JMBG, strlen(jmbg) + 1, jmbg);
		_Prebivaliste = p;
	}
	void Dealociraj(){
		delete[] _imePrezime; _imePrezime = nullptr;
	}
	void Info(){
		cout << "Datum rodjenja: ";
		_datumRodjenja.Ispis();
		cout << "Ime i prezime: " << _imePrezime << endl;
		cout << "JMBG: " << _JMBG << endl;
		cout << "Prebivavliste: " << OpstineChar[_Prebivaliste] << endl;
	}
};
struct Glas{
	Osoba * _glasac;
	Kandidati * _glasZa;

	void Unos(Osoba o, Kandidati k){  
		_glasac = new Osoba;
		*_glasac = o;
		_glasZa = new Kandidati;
		*_glasZa = k;
	}
	void Ispis(){
		_glasac->Info();
		cout << "Glas za: " << KandidatiChar[*_glasZa] << endl;
	}
	void Dealociraj(){
		_glasac->Dealociraj();
		delete _glasac; _glasac = nullptr;
		delete _glasZa; _glasZa = nullptr;
	}
};
struct Izbori2014{
	Opstina * _glasackoMjesto;
	Glas * _glasovi[1000];
	int _doSadaGlasalo;

	void Unos(Opstina * o){
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture.*/
		_glasackoMjesto = new Opstina;
		_glasackoMjesto = o;
		_doSadaGlasalo = 0;
	}
	bool AddGlas(Glas  * noviGlas){
		/*funkcija treba da omoguci dodavanje informacija o novom glasu i tom prilikom:
		-     onemoguciti da ista osoba glasa vise puta
		-     onemoguciti glasanje osobama mladjim od 18 godina (uzeti u obzir
		samo mjesec i godinu rodjenja)
		-     onemoguciti glasanje osobama iz drugih opstina
		-     u zavisnosti od uspjesnosti operacije funkcija vraca true ili false
		*/
		if (_doSadaGlasalo <= 1000){
			Datum datumGlasanja;
			bool mozeGlasat = false;
			int d = 1, m = 9, g = 2017;
			datumGlasanja.Unos(d, m, g);
			if (datumGlasanja.daLiJePunoljetan(noviGlas->_glasac->_datumRodjenja) &&
				noviGlas->_glasac->_Prebivaliste == *_glasackoMjesto){
				mozeGlasat = true;
				for (int i = 0; i < _doSadaGlasalo; i++)
				{
					if (strcmp(_glasovi[i]->_glasac->_imePrezime, noviGlas->_glasac->_imePrezime) == 0 && 
						strcmp(_glasovi[i]->_glasac->_JMBG, noviGlas->_glasac->_JMBG) == 0)
							mozeGlasat = false;
					}

				}
			if (mozeGlasat){
				_glasovi[_doSadaGlasalo] = new Glas;
				_glasovi[_doSadaGlasalo]->Unos(*noviGlas->_glasac, *noviGlas->_glasZa);
				_doSadaGlasalo++;
				return true;
			}
		}
		else
			cout << "Glasovi su popunjeni" << endl;
		return false;
	}
	void Dealociraj(){
		/*definisati funkciju vodeci racuna o oslobadjasnju svih resursa koji su alocirani za potrebe objekta tipa Izbori2014*/
		delete _glasackoMjesto; _glasackoMjesto = nullptr;
		for (int i = 0; i <= _doSadaGlasalo; i++)
			_glasovi[i]->Dealociraj();
	}
};
struct nacelnik{
	Opstina _o;
	Kandidati _k;
	int _brojGlsova;
	float _procenatGlasova;

	void Unos(Kandidati k){
		_k = k;
		_brojGlsova = 0;
		_procenatGlasova = 0;
	}
	void Ispis(){
		cout << "kandidat: " << _k << endl;
		cout << "broj glasova: " << _brojGlsova << endl;
		cout << "Procenat glasova : " << _procenatGlasova << endl;
	}
};
Opstina ProglasiPobjednika(Izbori2014 * izbornaMjesta, int brojIzbornihMjesta){
	/*
	u zavisnosti od postignutog uspjeha:
	- funkcija treba ispisati listu kandidata sortiranu opadajucim redoslijedom, a uz
	svakog kandidata je potrebno ispisati i osvojeni procenat glasova
	- funkcija vraca opstinu u kojoj je pobjednicki kandidat ostvario najveci broj
	glasova
	- ukoliko je pobjednicki kandidat ostvario podjednak broj glasova u vise opstina,
	funkcija vraca prvu koja se nalazi u nizu na koji pokazuje pokazivac
	izbornaMjesta
	*/
	nacelnik n[4];

	n[0].Unos(Kandidat1);
	n[1].Unos(Kandidat2);
	n[2].Unos(Kandidat3);
	n[3].Unos(Kandidat4);
	int b1 = 0, b2 = 0, b3 = 0, b4 = 0;
	for (int i = 0; i < brojIzbornihMjesta; i++)
	{
		for (int j = 0; j < izbornaMjesta[i]._doSadaGlasalo; j++)
		{
			if (*izbornaMjesta[i]._glasovi[j]->_glasZa == Kandidat1)
				n[0]._brojGlsova++;
			if (*izbornaMjesta[i]._glasovi[j]->_glasZa == Kandidat2)
				n[1]._brojGlsova++;
			if (*izbornaMjesta[i]._glasovi[j]->_glasZa == Kandidat3)
				n[2]._brojGlsova++;
			if (*izbornaMjesta[i]._glasovi[j]->_glasZa == Kandidat4)
				n[3]._brojGlsova++;
		}
		for (int i = 0; i < 4; i++)
		{
			n[i]._procenatGlasova = n[i]._brojGlsova / izbornaMjesta->_doSadaGlasalo * 100;
		}
		nacelnik temp;
		bool izvrsenaZamjena;
		do
		{
			izvrsenaZamjena = false;
			for (int i = 0; i < 4; i++)
			{

				if (n[i]._brojGlsova < n[i + 1]._brojGlsova){
					temp = n[i];
					n[i] = n[i + 1];
					n[i + 1] = temp;
					izvrsenaZamjena = true;
				}
			}
		} while (izvrsenaZamjena==true);
	}
	for (int i = 0; i < 4; i++)
	{
		n[i].Ispis();
	}
	return 


}
int main(){
	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti.
	izbjegavajte koristenje vlastitog imena i prezimena*/
	Datum d1, d2, d3, d4;
	d1.Unos(22, 11, 1994);
	d2.Unos(13, 2, 1993);
	d3.Unos(22, 11, 1999);
	d4.Unos(13, 4, 1995);

	Osoba o1, o2, o3, o4, o5;
	o1.unos(d1, "nema imena", "2211333221", Opstina1);
	o2.unos(d3, "bez imena", "112211222", Opstina1);
	o3.unos(d4, "sta ce ime", "332211222", Opstina1);
	o4.unos(d1, "ludilo", "33322221111", Opstina2);
	o5.unos(d2, "bezimeni", "12332112332", Opstina2);
	cout << endl;

	o1.Info();
	o3.Info();

	Glas g1, g2, g3, g4, g5;
	g1.Unos(o1, Kandidat1);
	g2.Unos(o2, Kandidat3);
	g3.Unos(o3, Kandidat4);
	g4.Unos(o4, Kandidat1);
	g5.Unos(o5, Kandidat1);
	cout << endl;

	g1.Ispis();
	g3.Ispis();


	cout << endl;
	Izbori2014 *izbori = new Izbori2014[2];
	Opstina ops1 = Opstina1;
	Opstina ops2 = Opstina2;
	izbori[0].Unos(&ops1);
	if(izbori[0].AddGlas(&g1))
		cout << "Uspjesno dodan glas" << endl;
	else
		cout << "Neuspjesno" << endl;

	if(izbori[0].AddGlas(&g2))
		cout << "Uspjesno dodan glas" << endl;
	else
		cout << "Neuspjesno" << endl;

	izbori[1].Unos(&ops2);
	if(izbori[1].AddGlas(&g3))
		cout << "Uspjesno dodan glas" << endl;
	else
		cout << "Neuspjesno" << endl;

	if (izbori[1].AddGlas(&g4))
		cout << "Uspjesno dodan glas" << endl;
	else
		cout << "Neuspjesno" << endl;
	if (izbori[1].AddGlas(&g5))
		cout << "Uspjesno dodan glas" << endl;
	else
		cout << "Neuspjesno" << endl;

	cout << "Pobjednicki kandidat je najvise glasova ostvario u Opstini" << ProglasiPobjednika(izbori, 2) + 1 << endl;

	system("pause");
	return 0;
}

__________________________________________________________________


#include<iostream>
using namespace std;

char crt[] = { "\n----------------------------------------------\n" };

enum Kompanija{ Pegasus, TurkishAirlines, AustrianAirlines, FlyEmirates };
char  * KompanijaChar[] = { "Pegasus", "TurkishAirlines", "AustrianAirlines", "FlyEmirates" };
int ID = 1;

struct Putnik{ 
	int _putnikID; 
	char * _imePrezime;
	float _brojPredjenihMilja;

	void Unos(char * imePrezime){
		int size = strlen(imePrezime) + 1; 
		_imePrezime = new char[size]; 
		strcpy_s(_imePrezime, size, imePrezime);
		_brojPredjenihMilja = 0; 
		_putnikID = ID++;
	}  
	void Info(){
		cout << "[" << _putnikID << "] " << _imePrezime <<    " (" << _brojPredjenihMilja << " milja)" << endl;
	}
	void Dealociraj(){
		delete[] _imePrezime; 
		_imePrezime = nullptr;
	} 
	void DodajPredjeneMilje(int brojMilja){
		_brojPredjenihMilja += brojMilja;
	}
};
struct Rezervacija{
	Putnik _putnik; 
	int _oznakaSjedista;
	float _cijena; 

	void Unos(Putnik * putnik, int oznaka, float cijena){ 
	_putnik.Unos(putnik->_imePrezime);
	_oznakaSjedista = oznaka; 
	_cijena = cijena; 
	}  
	void Info(){ 
		_putnik.Info();  
		cout << "Sjediste: " << _oznakaSjedista << " Cijena: "    << _cijena << endl; 
	} 
	void Dealociraj(){ 
		_putnik.Dealociraj();
	}
};
struct Let{
	Kompanija _kompanija;
	char * _pocetak; //pocetna lokacija 
	char * _destinacija;
	Rezervacija * _rezervacije[100];
	float * _brojMilja; //odnosi se na duzinu leta – broj predjenih milja 
	float * _cijenaKarte;

	void Ispis(){
		cout << "Kompanija: "<<KompanijaChar[_kompanija] << endl;
		cout << "_pocetak: " << _pocetak << endl;
		cout << "_destinacija: " << _destinacija << endl;
	}

	void NulirajRezervaciju(){
		for (int i = 0; i < 100; i++)
			_rezervacije[i] = nullptr;
	}
	void Unos(Kompanija * kompanija, char * pocetak, char * destinacija,   float brojMilja, float cijenaKarte){ 
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture. predloziti mehanizam
		pracenja broja slobodnih mjesta bez uvodjenja dodatnih atributa */
		_kompanija = *kompanija;
		_pocetak = new char[strlen(pocetak) + 1];
		strcpy_s(_pocetak, strlen(pocetak) + 1, pocetak);
		_destinacija = new char[strlen(destinacija) + 1];
		strcpy_s(_destinacija, strlen(destinacija) + 1, destinacija);
		_brojMilja = new float;
		*_brojMilja = brojMilja;
		_cijenaKarte = &cijenaKarte;

	} 
	void Dealociraj(){
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani za potrebe objekta tipa Let*/ 
		delete[] _pocetak; _pocetak = nullptr;
		delete[] _destinacija; _destinacija = nullptr;
		int i = 0;
		while (_rezervacije[i] != nullptr){
			delete[] _rezervacije[i];
			i++;
		}
	} 
	bool AddRezervaciju(Putnik * p){
		/*putniku se dodjeljuje prvo slobodno sjediste pri cemu ce oznaka sjedista biti identicna lokaciji rezervacije u nizu.
		prilikom dodjeljivanja slobodnog sjedista voditi racuna o broju predjenih milja putnika. ako je putnik presao
		vise od 50000 milja onda mu je potrebno ponuditi sjediste pored prozora (pretpostavimo da su sva sjedista sa
		neparnim indeksom sjedista pored prozora).u slucaju da putnik ne zeli mjesto pored prozora, onda mu se dodjeljuje
		prvo slobodno sjediste. onemoguciti dodavanje rezervacija sa identicnim putnicima (isti putnikID i imePrezime).
		u zavisnosti od uspjesnosti funkcija vraca true ili false */
		int b = 0;
		char slovo;
		while (_rezervacije[b] != nullptr){
			b++;
		}
		if (b <= 100){
			if (p->_brojPredjenihMilja > 50000){
				cout << "Da li zelite sjediste pored prozora-> (D/N) ";
				cin >> slovo;
				slovo = toupper(slovo);
				if (slovo == 'D' && b % 2 == 0){
					b++;
					while(_rezervacije[b] != nullptr){
						b += 2;
					}
					if (slovo == 'D')
						cout << "Rezervisemo mjesto pored prozora..." << endl;
				}
			}
			if (b <= 100){
				_rezervacije[b] = new Rezervacija;
				_rezervacije[b]->Unos(p, b, *_cijenaKarte);
				return true;
			}
			else
				cout << "Zao nam je.Mjesta pored prozora su popunjena." << endl;
		}
		else
			cout << "Sve je vec rezervisano. Zao nam je" << endl;
		return false;
	}
	bool RemoveRezervaciju(char * imePrezime){ 
		/*na osnovu vrijednosti parametra izvrsiti uklanjanje rezervacije iz niza. voditi racuna o alociranom memorijskom prostoru.
		u zavisnosti od uspjesnosti funkcija vraca true ili false */ 
		int b = 0;
		while (_rezervacije[b] != nullptr){
			if (strcmp(_rezervacije[b]->_putnik._imePrezime, imePrezime)==0){
				_rezervacije[b]->Dealociraj();
				_rezervacije[b] = nullptr;
				return true;
			}
			b++;
		}
		return false;
	}
};
float GetMiljeByKompanija(Let * letovi, int maxLetova, Kompanija kompanija,  Putnik * putnik){ 
	/*funkcija vraca broj milja koje je putnik (proslijedjen kao parametar funkcije) ostvario putujuci sa kompanijom koja je 
	takodjer proslijedjena kao parametar funkcije*/ 

	float milje = 0;
	for (int i = 0; i < maxLetova; i++)
	{
		if (letovi[i]._kompanija == kompanija){
			int b = 0;
			while (letovi[i]._rezervacije[b] != nullptr){
				if (strcmp(letovi[i]._rezervacije[b]->_putnik._imePrezime, putnik->_imePrezime) == 0)
					milje += *letovi[i]._brojMilja;
				b++;
			}
		}
	}
	return milje;

}
void menu(int &izbor){
	cout << "-----------------MENI---------------" << endl;
	cout << "1.AddRezervaciju " << endl;
	cout << "2. RemoveRezervaciju" << endl;
	cout << "3. GetMiljeByKompanija" << endl;
	cout << "4. Kraj" << endl;
	cout << crt;
	do
	{
		cout << "Unesite izbor-> ";
		cin >> izbor;
		if (izbor < 1 || izbor>4)
			cout << "Pokusajte ponovo" << endl;
	} while (izbor < 1 || izbor>4);
	system("cls");
	cin.ignore();
}
void main(){
	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti. izbjegavajte koristenje vlastitog imena i prezimena*/
	int brojLetova;
	cout << "Unesite koliko letova zelite" << endl;
	cin >> brojLetova;
	Let * letovi = new Let[brojLetova];

	for (int i = 0; i < brojLetova; i++){
		letovi[i].NulirajRezervaciju();
		int komp;
		cout << "Unesite kompaniju za " << i + 1 << " let: |1. Pegasus, |2. TurkishAirlines, |3. AustrianAirlines, |4. FlyEmirates|";
		cin >> komp;
		cin.ignore();
		Kompanija k;
		k = (Kompanija)--komp;
		cout << "Uneiste odakle polijece:" << endl;
		char pocetak[30];
		cin.getline(pocetak, 30);
		cout << "Uneiste gdje slijece:" << endl;
		char destinacija[30];
		cin.getline(destinacija, 30);
		cout << "Kolika je razdaljina izmedju gradova? Unesi ovdje->";
		float milje;
		cin >> milje;
		cin.ignore();
		cout << "Kolikoa je cijena karte? Unesi->";
		float cijena;
		cin >> cijena;
		cin.ignore();
		letovi[i].Unos(&k, pocetak, destinacija, milje, cijena);
	}
	system("cls");
	int brojPutnika;
	cout << "Uneiste koliko zelite unijeti putnika" << endl;
	cin >> brojPutnika;
	cin.ignore();
	Putnik * putnici = new Putnik[brojPutnika];
	char ip[30];
	for (int i = 0; i < brojPutnika; i++)
	{
		cout << "Uneiste ime i prezime putnika broj" << i + 1;
		cin.getline(ip, 30);
		putnici[i].Unos(ip);
	}
	int izbor;
	do
	{
		menu(izbor);
		switch (izbor){
		case 1:{
			int rb1,rb2;
			for (int i = 0; i < brojLetova; i++)
			{
				cout << "Ispis leta broj: " << i + 1 << endl;
				letovi[i].Ispis();
				cout << crt;
			}
			cout << "Odaberite kompaniju sa kojom zelite putovati" << endl;
			cin >> rb1;

			for (int i = 0; i < brojPutnika; i++)
			{
				cout << "Ispis putnika broj: " << i + 1 << endl;
				putnici[i].Info();
				cout << crt;
			}

			cout << "Unesite rb putnika kojem zelite rezervisati mjesto ";
			cin >> rb2;

			if (letovi[--rb1].AddRezervaciju(&putnici[--rb2]))
				cout << "Mjesto je rezervisano" << endl;
			break;
		}
		case 2:{
			bool izbrisana = false;
			char ip[30];
			cout << "Uneiste ime i preztime putnika kome zelite izbrijsati rezervaciju  ";
			cin.getline(ip, 30);
			for (int i = 0; i < brojLetova; i++)
			{
				if (letovi[i].RemoveRezervaciju(ip)){
					izbrisana = true;
					break;
				}
					
			}
			if (izbrisana)
				cout << "REZERVACIJA JE IZBRISANA" << endl;
			else
				cout << "REZERVACIJA NIJE IZBRISANA" << endl;
			break;
		}
		case 3:{
			int rb1, izbor;
			for (int i = 0; i < brojPutnika; i++)
			{
				cout << "Ispis putnika broj: " << i + 1 << endl;
				putnici[i].Info();
				cout << crt;
			}
			cout << "Odaberite putnikakojeg zelite da pretrazujete" << endl;
			cin >> rb1;
			cout << "Odaberite kompaniju koju zelite da pretrazujete za tog putnika |1. Pegasus, |2. TurkishAirlines, |3. AustrianAirlines, |4. FlyEmirates|" << endl;
			cin >> izbor;
			cin.ignore();
			Kompanija k;
			k = (Kompanija)--izbor;
			cout << "Predjene milje za kompaniju " << KompanijaChar[k] << " od putnika " << putnici[izbor]._imePrezime << " je " << GetMiljeByKompanija(letovi, brojLetova, k, &putnici[--rb1]) << endl;
			break;
		}case 4:{
			cout << "Dovidjenja" << endl;
			break;
		}
		}

	} while (izbor!=4);

	system("pause");
}

______________________________________________________________________


#include <iostream>
using namespace std;  

enum Opstina{ Opstina1, Opstina2, Opstina3, Opstina4 };
char * OpstineChar[] = { "Opstina1", "Opstina2", "Opstina3", "Opstina4" }; 
enum Kandidati{ Kandidat1, Kandidat2, Kandidat3, Kandidat4 };
char * KandidatiChar[] = { "Kandidat1", "Kandidat2", "Kandidat3", "Kandidat4" };
char * crt = { "\n-------------------------------------------\n" };

struct Datum{ 
	int _dan, _mjesec, _godina;

	void Unos(int d, int m, int g){
		_dan = d;
		_mjesec = m;
		_godina = g;
	} 
	void Ispis(){
		cout << _dan << "/" << _mjesec << "/" << _godina << endl;
	} 
	bool daLiJeMladji(Datum noviGlasac){
		if (_godina - noviGlasac._godina > 18)
			return true;
		else if (_godina - noviGlasac._godina == 18){
			if (_mjesec >= noviGlasac._mjesec)
				return true;
		}
		return false;
	}
};
struct Osoba{
	Datum _datumRodjenja;
	char * _imePrezime;
	char _JMBG[14]; 
	Opstina _Prebivaliste;
	void unos(Datum d, char * ip, char jmbg[], Opstina p){
		_datumRodjenja = d; 
		_imePrezime = new char[strlen(ip) + 1]; 
		strcpy_s(_imePrezime,strlen(ip)+1 ,ip); 
		strcpy_s(_JMBG,strlen(jmbg)+1,jmbg); 
		_Prebivaliste = p;
	}
	void Dealociraj(){
		delete[] _imePrezime;
		_imePrezime = nullptr;
	} 
	void Info(){
		_datumRodjenja.Ispis();
		cout << _imePrezime << " " << _JMBG << " " << OpstineChar[_Prebivaliste] << endl;
	}
}; 

struct Glas{ 
	Osoba _glasac;
	Kandidati _glasZa; 
	void Unos(Osoba o, Kandidati k){ 
		_glasac.unos(o._datumRodjenja, o._imePrezime, o._JMBG, o._Prebivaliste);
		_glasZa = k;
	}  
	void Ispis(){
		_glasac.Info(); 
		cout << KandidatiChar[_glasZa] << endl;
	} 
	void Dealociraj(){
		_glasac.Dealociraj();
	}
}; 

struct Izbori2014{
	Opstina _glasackoMjesto;
	Glas * _glasovi;
	int _brojGlasaca;
	void Unos(Opstina * o){
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture.*/
		_glasackoMjesto = *o;
		_glasovi = nullptr;
		_brojGlasaca = 0;
	}
	void Ispis(){
		cout << "Glasacko mjesto: " << OpstineChar[_glasackoMjesto] << endl;
	}
	bool AddGlas(Glas * g){ 
		/*funkcija treba da omoguci dodavanje informacija o novom glasu   tom prilikom:			
		- onemoguciti da ista osoba glasa vise puta  
		- onemoguciti glasanje osobama mladjim od 18 godina (uzeti u obzir samo mjesec i godinu rodjenja) 
		- onemoguciti glasanje osobama iz drugih opstina   
		- u zavisnosti od uspjesnosti operacije funkcija vraca true ili false   */
		Datum trenutniDatum;
		trenutniDatum.Unos(11, 6, 2017);
		for (int i = 0; i < _brojGlasaca; i++)
		{
			if (strcmp(_glasovi[i]._glasac._imePrezime, g->_glasac._imePrezime) == 0)
				return false;
		}
		if (trenutniDatum.daLiJeMladji(g->_glasac._datumRodjenja) && _glasackoMjesto == g->_glasac._Prebivaliste){
			Glas * temp = new Glas[_brojGlasaca + 1];
			for (int i = 0; i < _brojGlasaca; i++)
				temp[i] = _glasovi[i];

			for (int i = 0; i < _brojGlasaca; i++)
				_glasovi[i].Dealociraj();

			temp[_brojGlasaca] = *g;

			_glasovi = temp;
			temp = nullptr;
			_brojGlasaca++;
			return true;
		}
		return false;


	} 
	void Dealociraj(){
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani za potrebe objekta tipa Izbori2014*/
	}
};
struct nacelnik{

	Kandidati  _k;
	int _brojacGlasova = 0;
	float _prosjek = 0;

	void Unos(Kandidati k){
		_k = k;
		_brojacGlasova = 0;
		_prosjek = 0;
	}
	void Ispis(){
		cout << "Kandidat: " << _k << endl;
		cout << "Broj glasova: " << _brojacGlasova << endl;
		cout << "Prosjek: " << _prosjek << endl;
	}
};

struct PobjednikUOpstini{
	Opstina _o;
	int _brojacGlasovaZaNajboljeg = 0;

};
Opstina ProglasiPobjednika(Izbori2014 * izbornaMjesta, int brojIzbornihMjesta){ 
	/*  u zavisnosti od postignutog uspjeha,  
	- funkcija treba ispisati listu kandidata sortiranu opadajucim redoslijedom,a uz svakog kandidata je potrebno 
	ispisati i osvojeni procenat glasova 
	- funkcija vraca opstinu u kojoj je pobjednickikandidat ostvario najveci broj glasova 
	- ukoliko je pobjednicki kandidat ostvario podjednak broj glasova u vise opstina, funkcija vraca prvu koja se nalazi
	u nizu na koji pokazuje pokazivac izbornaMjesta  */

	nacelnik NizNacelnika[4];
	NizNacelnika[0].Unos(Kandidat1);
	NizNacelnika[1].Unos(Kandidat2);
	NizNacelnika[2].Unos(Kandidat3);
	NizNacelnika[3].Unos(Kandidat4);



	for (int i = 0; i < brojIzbornihMjesta; i++)
	{
		for (int j = 0; j < izbornaMjesta[i]._brojGlasaca; j++)
		{
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat1)
				NizNacelnika[0]._brojacGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat2)
				NizNacelnika[1]._brojacGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat3)
				NizNacelnika[2]._brojacGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat4)
				NizNacelnika[3]._brojacGlasova++;

		}
	}
	for (int i = 0; i < 4; i++)
		NizNacelnika[i]._prosjek = NizNacelnika[i]._brojacGlasova /(float) izbornaMjesta->_brojGlasaca * 100;


	nacelnik temp;
	bool izvrsenaIzmjena;
	do
	{
		izvrsenaIzmjena = false;

		for (int i = 0; i < 4; i++)
		{
			if (NizNacelnika[i]._brojacGlasova < NizNacelnika[i + 1]._brojacGlasova){
				temp = NizNacelnika[i];
				NizNacelnika[i] = NizNacelnika[i + 1];
				NizNacelnika[i + 1] = temp;
				izvrsenaIzmjena = true;
			}
		}
	} while (izvrsenaIzmjena==true);

	for (int i = 0; i < 4; i++)
	{
		NizNacelnika[i].Ispis();
	}
	PobjednikUOpstini sveOpstine[4];
	sveOpstine[0]._o = Opstina1;
	sveOpstine[1]._o = Opstina2;
	sveOpstine[2]._o = Opstina3;
	sveOpstine[3]._o = Opstina4;

	for (int i = 0; i < izbornaMjesta->_brojGlasaca; i++)
	{
		if (izbornaMjesta->_glasovi->_glasZa == NizNacelnika[0]._k){
			if (izbornaMjesta->_glasackoMjesto == Opstina1)
				sveOpstine[0]._brojacGlasovaZaNajboljeg++;
			else if (izbornaMjesta->_glasackoMjesto == Opstina2)
				sveOpstine[1]._brojacGlasovaZaNajboljeg++;
			else if (izbornaMjesta->_glasackoMjesto == Opstina3)
				sveOpstine[2]._brojacGlasovaZaNajboljeg++;
			else if (izbornaMjesta->_glasackoMjesto == Opstina4)
				sveOpstine[3]._brojacGlasovaZaNajboljeg++;
		}

	}
	do
	{
		izvrsenaIzmjena = false;
		PobjednikUOpstini p;

		for (int i = 0; i < 4; i++)
		{
			if (sveOpstine[i]._brojacGlasovaZaNajboljeg < sveOpstine[i+1]._brojacGlasovaZaNajboljeg){
				p = sveOpstine[i];
				sveOpstine[i] = sveOpstine[i + 1];
				sveOpstine[i + 1] = p;
				izvrsenaIzmjena = true;
			}
		}
	} while (izvrsenaIzmjena == true);

	return sveOpstine[0]._o;
}
void meni(int &izbor){
	cout << "1. Dodaj Glas" << endl;
	cout << "2.Proglasi pobjednika" << endl;
	cout << "3. Kraj glasanja" << endl;
	cout << "Unesite izbor-> ";
	do
	{
		cin >> izbor;
		if (izbor < 1 || izbor>3)
			cout << "Pogrtresan izbor, pokusajte ponovo" << endl;
	} while (izbor < 1 || izbor>3);
	cin.ignore();
	system("cls");
}

int main(){
	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti.
	izbjegavajte koristenje vlastitog imena i prezimena*/
	int izbor, brojMjesta;
	Opstina o;
	Izbori2014 * glasackaMjesta = nullptr;
	cout << "Unesite koliko ima izbornih mjesta" << endl;
	cin >> brojMjesta;
	glasackaMjesta = new Izbori2014[brojMjesta];
	for (int i = 0; i < brojMjesta; i++){
		cout << "Unesite kojoj opstini pripada ovo izborno mjesto br: " << i + 1 << endl;
		cout << "(1. Opstina1, 2. Opstina2, 3. Opstina3, 4. Opstina4)" << endl;
		cin >> izbor;
		o = (Opstina)--izbor;
		glasackaMjesta[i].Unos(&o);
	}
	do
	{
		meni(izbor);

		if (izbor == 1){
			Glas * glas = nullptr;
			glas = new Glas;
			cout << "Unesite datum rodjenja glasaca" << endl;
			int d, m, g;
			cout << "Dan: ";
			cin >> d;
			cout << "Mjesec: ";
			cin >> m;
			cout << "Godina: ";
			cin >> g;
			cin.ignore();
			glas->_glasac._datumRodjenja.Unos(d, m, g);
			cout << "unesite ime i prezime glasaca" << endl;
			char ip[30];
			cin.getline(ip, 30);
			glas->_glasac._imePrezime = new char[strlen(ip) + 1];
			strcpy_s(glas->_glasac._imePrezime, strlen(ip) + 1, ip);
			cout << "Unesite JMBG glasaca" << endl;
			char jmbg[14];
			cin.getline(jmbg, 14);
			strcpy_s(glas->_glasac._JMBG, strlen(jmbg) + 1, jmbg);
			cout << "Odaberite mjesto prebivalista glasaca(1. Opstina1,2. Opstina2,3. Opstina3,4. Opstina4) " << endl;
			int br;
			cin >> br;
			glas->_glasac._Prebivaliste = (Opstina)--br;
			cout << "Unesite kandidata za kojeg glasate: (1. Kandidat1,2. Kandidat2,3. Kandidat3,4. Kandidat4)" << endl;
			int kandidat;
			cin >> kandidat;
			glas->_glasZa = (Kandidati)--kandidat;

			for (int i = 0; i < brojMjesta; i++){
				cout << "Glasacko mjesto broj: " << i + 1 << endl;
				glasackaMjesta[i].Ispis();
				cout << crt;
			}
			cout << "Unesite glasacko mjesto na kojem glasac glasa((1. Opstina1,2. Opstina2,3. Opstina3,4. Opstina4)" << endl;
			int glMjesto;
			cin >> glMjesto;

			if (glasackaMjesta[--glMjesto].AddGlas(glas))
				cout << "Glas je uspjesno dodan" << endl;
			else
				cout << "Glasanje nije uspjelo" << endl;
		}
		if (izbor == 2){
			Opstina o;
			o = ProglasiPobjednika(glasackaMjesta, brojMjesta);
			cout << "Pobjednik je najvise glasova imao u " << OpstineChar[o] << " opstini" << endl;
		}
	} while (izbor!=3);


	return 0;
}

__________________________________________________________________

#include <iostream> 
#include<fstream>
using namespace std;  

enum Opstina{ Opstina1, Opstina2, Opstina3, Opstina4 };
char * OpstineChar[] = { "Opstina1", "Opstina2", "Opstina3", "Opstina4" };
enum Kandidati{ Kandidat1, Kandidat2, Kandidat3, Kandidat4 };
char * KandidatiChar[] = { "Kandidat1", "Kandidat2", "Kandidat3", "Kandidat4" };

struct Datum{ 
	int _dan, _mjesec, _godina; 
	void Unos(int d, int m, int g){
		_dan = d;
		_mjesec = m;
		_godina = g;
	} 
	void Ispis(){
		cout << _dan << "/" << _mjesec << "/" << _godina << endl;
	}

	bool DaLiJeStariji(Datum datumRodjenjaGlasaca){
		if (_godina - datumRodjenjaGlasaca._godina > 18)
			return true;
		else if (_godina - datumRodjenjaGlasaca._godina == 18){
			if (_mjesec > datumRodjenjaGlasaca._mjesec)
				return true;
			else if (_mjesec == datumRodjenjaGlasaca._mjesec)
				return true;
		}
		return false;
	}
};

struct Osoba{
	Datum _datumRodjenja;
	char * _imePrezime;
	char _JMBG[14];
	Opstina _Prebivaliste;
	void unos(Datum d, char * ip, char jmbg[], Opstina p){
		_datumRodjenja = d;
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime,strlen(ip)+1, ip);  
		strcpy_s(_JMBG,strlen(jmbg)+1, jmbg); 
		_Prebivaliste = p;
	} 
	void Dealociraj(){
		delete [] _imePrezime;
		_imePrezime = nullptr;
	}
	void Info(){
		_datumRodjenja.Ispis();
		cout << _imePrezime << " " << _JMBG << " " << OpstineChar[_Prebivaliste] << endl;
	}

};
struct Glas{
	Osoba _glasac; 
	Kandidati _glasZa; 
	void Unos(Osoba o, Kandidati k){
		_glasac.unos(o._datumRodjenja, o._imePrezime, o._JMBG, o._Prebivaliste);
		_glasZa = k;
	} 
	void Ispis(){
		_glasac.Info();
		cout << KandidatiChar[_glasZa] << endl;
	}
	void Dealociraj(){
		_glasac.Dealociraj();
	} 
};

struct KandidatiBrojGlasova{
	Kandidati _k;
	int _brojGlasovaZaKandidata = 0;
	float _postotakUspjesnosti = 0;

	void Ispis(){
		cout << "Kandidat: " << KandidatiChar[_k] << endl;
		cout << "Broj glasova: " << _brojGlasovaZaKandidata << endl;
		cout << "Postotak uspjesnosti: " << _postotakUspjesnosti << endl;
	}
};

bool DaLiJeManji(Datum d1, Datum d2){
	if (d1._godina<d2._godina)
		return true;
	else if (d1._godina == d2._godina){
		if (d1._mjesec < d2._mjesec)
			return true;
		else if (d1._mjesec == d2._mjesec){
			if (d1._dan < d2._dan)
				return true;
		}
	}
	return false;
}
bool DaLiJeVeci(Datum d1, Datum d2){
	if (d1._godina>d2._godina)
		return true;
	else if (d1._godina == d2._godina){
		if (d1._mjesec > d2._mjesec)
			return true;
		else if (d1._mjesec == d2._mjesec){
			if (d1._dan > d2._dan)
				return true;
		}
	}
	return false;
}


struct Izbori2014{
	Opstina _glasackoMjesto; 
	Glas * _glasovi[1000];
	int _brojGlasaca; 
	void Unos(Opstina * o){ 
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture.*/ 
		_glasackoMjesto = *o;
		for (int i = 0; i < 1000; i++)
			_glasovi[i] = nullptr;
		_brojGlasaca = 0;
	} 

	bool AddGlas(Glas * g){
		/*funkcija treba da omoguci dodavanje informacija o novom glasu   tom prilikom:													
		- onemoguciti da ista osoba glasa vise puta 
		- onemoguciti glasanje osobama mladjim od 18 godina (uzeti u obzir samo mjesec i godinu rodjenja) 
		- onemoguciti glasanje osobama iz drugih opstina  
		- u zavisnosti od uspjesnosti operacije funkcija vraca true ili false   */
		if (_brojGlasaca < 1000){
			Datum DatumGlasanja;
			DatumGlasanja.Unos(16, 6, 2017);

			for (int i = 0; i < _brojGlasaca; i++)
			{
				if (strcmp(_glasovi[i]->_glasac._imePrezime, g->_glasac._imePrezime) == 0)
					return false;
			}
			if (DatumGlasanja.DaLiJeStariji(g->_glasac._datumRodjenja) && _glasackoMjesto == g->_glasac._Prebivaliste){

				_glasovi[_brojGlasaca] = new Glas;
				_glasovi[_brojGlasaca]->Unos(g->_glasac, g->_glasZa);
				_brojGlasaca++;
				return true;
			}
		}
		return false;



	}
	void Dealociraj(){ 
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani za potrebe objekta tipa Izbori2014*/
		for (int i = 0; i < _brojGlasaca; i++)
		{
			_glasovi[i]->Dealociraj();
		}
	}

	void Ispis(){
		cout << "Glasacko mjesto: " << OpstineChar[_glasackoMjesto] << endl;
		cout << "Svi glasovi: " << endl;
		for (int i = 0; i < _brojGlasaca; i++)
		{
			_glasovi[i]->Ispis();
		}
	}

	void IspisPoUspjehu() {

		KandidatiBrojGlasova niz[4];
		niz[0]._k = Kandidat1;
		niz[1]._k = Kandidat2;
		niz[2]._k = Kandidat3;
		niz[3]._k = Kandidat4;

		for (int i = 0; i < _brojGlasaca; i++)
		{
			if (_glasovi[i]->_glasZa == niz[0]._k)
				niz[0]._brojGlasovaZaKandidata++;
			if (_glasovi[i]->_glasZa == niz[1]._k)
				niz[1]._brojGlasovaZaKandidata++;
			if (_glasovi[i]->_glasZa == niz[2]._k)
				niz[2]._brojGlasovaZaKandidata++;
			if (_glasovi[i]->_glasZa == niz[3]._k)
				niz[3]._brojGlasovaZaKandidata++;
		}

		for (int i = 0; i < 4; i++)
		{
			niz[i]._postotakUspjesnosti = (niz[i]._brojGlasovaZaKandidata /(float) _brojGlasaca) * 100;
		}

		KandidatiBrojGlasova temp;
		bool sortirano;
		do
		{
			sortirano = false;
			for (int i = 0; i < 4; i++)
			{
				if (niz[i]._brojGlasovaZaKandidata < niz[i + 1]._brojGlasovaZaKandidata){
					temp = niz[i];
					niz[i] = niz[i + 1];
					niz[i + 1] = temp;
					sortirano = true;
				}
			}
		} while (false);

		for (int i = 0; i < 4; i++)
			niz[i].Ispis();
	}

	void BrojGlasacaPoRodjenju(){

		Datum OD, DO;
		OD.Unos(1, 1, 1980);
		DO.Unos(1, 1, 2000);
		for (int i = 0; i < _brojGlasaca; i++)
		{
			if (DaLiJeManji(_glasovi[i]->_glasac._datumRodjenja, DO) && DaLiJeVeci(_glasovi[i]->_glasac._datumRodjenja, OD))
				_glasovi[i]->Ispis();

		}
	}
};

/*
1. Upisi u binarni fajl - Objekat koji je primljen kao parametar upisuje u binarni fajl.Naziv fajla treba biti identican
nazivu opstine u kojoj se odrzavaju izbori
2. UcitajIzBinarnogFajla - u objekat koji je primljen kao parametar ucitava sadrzaj binarnog fajla(naziv fajla takodjer
3. PretragaRekurzivno - Rekurzivna funkcija koja treba da vrati broj glasova koje je na izborima ostvario odredjeni kandidat (kandidat se prosljedjuje kao parametar)

*/

int PretragaRekurzivno(Izbori2014 izbori, Kandidati k, int brojac = 0, int brojacGlasova = 0){
	if (brojac == izbori._brojGlasaca)
		return brojacGlasova;
	if (izbori._glasovi[brojac]->_glasZa == k)
		return  PretragaRekurzivno(izbori, k, brojac+1, brojacGlasova+1);
	else
		return PretragaRekurzivno(izbori, k, brojac+1, brojacGlasova);
	
}
void UpisUBinarniFajl(Izbori2014 i){
	ofstream upis;
	upis.open(OpstineChar[i._glasackoMjesto], ios::binary);
	if (upis.is_open()){
		upis.write((char*)(&i), sizeof(i));
		upis.close();
	}
}
void UcitajIzBinarnogFajla(Izbori2014 &izbori_fromFile, char o[]){
	ifstream ispis;
	ispis.open(o, ios::binary);
	if (ispis.is_open()){
		ispis.read((char*)(&izbori_fromFile), sizeof(izbori_fromFile));
		ispis.close();
	}
}
//Opstina ProglasiPobjednika(Izbori2014 * izbornaMjesta, int brojIzbornihMjesta){ 
//	/*  u zavisnosti od postignutog uspjeha, 
//	- funkcija treba ispisati listu kandidata sortiranu opadajucim redoslijedom, a uz svakog kandidata je potrebno ispisati i osvojeni procenat glasova
//	- funkcija vraca opstinu u kojoj je pobjednicki kandidat ostvario najveci broj glasova 
//	- ukoliko je pobjednicki kandidat ostvario podjednak broj glasova u vise opstina, funkcija vraca prvu koja se nalazi u nizu na koji pokazuje pokazivac izbornaMjesta  */
//} 

int main(){
	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti.
	izbjegavajte koristenje vlastitog imena i prezimena*/ 
	Datum dat1, dat2, dat3, dat4;

	dat1.Unos(10,7,1992);
	dat2.Unos(25,6,1987);
	dat3.Unos(2,9,1970);
	dat4.Unos(5,5,2005);
	dat1.Ispis();
	dat2.Ispis();

	cout << endl;
	Osoba o1, o2, o3, o4;
	o1.unos(dat1, "Kemal Gacan", "1007992174135", Opstina1);
	o2.unos(dat2, "Pero Peric", "11111111111112", Opstina2);
	o3.unos(dat3, "Huso Husic", "2222222222223", Opstina1);
	o4.unos(dat4, "franjo franjic", "3333333333334", Opstina1);

	o2.Info();
	o3.Info();
	o4.Info();

	cout << endl;

	Glas *g1 = new Glas;
	Glas *g2 = new Glas;
	Glas *g3 = new Glas;
	Glas *g4 = new Glas;


	g1->Unos(o1, Kandidat1);
	g2->Unos(o2, Kandidat2);
	g3->Unos(o3, Kandidat1);
	g4->Unos(o4, Kandidat3);

	g2->Ispis();
	g3->Ispis();

	cout << endl;

	Izbori2014 i1;
	Izbori2014 izbori_fromFile;
	Opstina op1, op2, op3, op4;
	op1 = Opstina1;
	op2 = Opstina2;
	op3 = Opstina3;
	op4 = Opstina4;
	i1.Unos(&op1);

	if (i1.AddGlas(g1))
		cout << "Glas 1 je uspjesno dodan" << endl;
	if (i1.AddGlas(g2))
		cout << "Glas 2 je uspjesno dodan" << endl;
	if (i1.AddGlas(g3))
		cout << "Glas 3 je uspjesno dodan" << endl;
	if (i1.AddGlas(g4))
		cout << "Glas 4 je uspjesno dodan" << endl;

	cout << endl;

	i1.Ispis();

	cout << endl;
	i1.IspisPoUspjehu();

	cout << endl;

	i1.BrojGlasacaPoRodjenju();

	cout << endl;

	cout << "Broj glasova za kandoidata1 ->" << PretragaRekurzivno(i1, Kandidat1) << endl;
	cout << "Broj glasova za kandoidata2 ->" << PretragaRekurzivno(i1, Kandidat2) << endl;
	cout << "Broj glasova za kandoidata3 ->" << PretragaRekurzivno(i1, Kandidat3) << endl;

	cout << endl;

	UpisUBinarniFajl(i1);
	UcitajIzBinarnogFajla(izbori_fromFile, "Opstina1");
	izbori_fromFile.Ispis();

	g1->Dealociraj();
	g2->Dealociraj();
	g3->Dealociraj();
	g4->Dealociraj();
	
	i1.Dealociraj();
	

	system("pause");
	return 0;
}




___________________________________________________________________


#include<iostream> 
using namespace std;
enum Vrsta{ Pitanje, Komentar, Zadatak, Rjesenje, Spam };
enum Nivo { Pocetnik, Clan, NapredniClan, Moderator };
char * NivoChar[] = { "Pocetnik", "Clan", "NapredniClan"," Moderator" };
struct Datum{ 
	int _dan, _mjesec, _godina; 

	void Unos(int d, int m, int g){ 
		_dan = d; 
		_mjesec = m;
		_godina = g;
	}  
	void Ispis(){
		cout << _dan << "/" << _mjesec << "/" << _godina << endl; 
	}

	bool DaLiSuIsti(Datum DatumPristupa){
		if (_godina == DatumPristupa._godina &&_mjesec == DatumPristupa._mjesec&&_dan == DatumPristupa._dan)
			return true;
		return false;
	}
};
struct Post{
	Vrsta _vrstaPosta;
	Datum * _datumPostavljanja;
	char * _sadrzaj; 
	char _IP[16];//IP adresa sa koje je post postavljen 192.168.100.100
	int _brojZahvala; // broj zahvala na post - thanks  
	bool _vidljiv;

void Unos(Vrsta * vrsta, Datum * datum, char * sadrzaj, char * IP,int brojZahvala){ 
	_vrstaPosta = *vrsta;   
	_datumPostavljanja = new Datum;
	_datumPostavljanja->Unos(datum->_dan, datum->_mjesec, datum->_godina); 
	_sadrzaj = new char[strlen(sadrzaj)+ 1];
	strcpy_s(_sadrzaj, strlen(sadrzaj) + 1, sadrzaj);
	strcpy_s(_IP,strlen(IP)+1,IP); 
	_brojZahvala = brojZahvala;
	_vidljiv = true;
} 
void Vidljivost(bool vidljivost){ 
	_vidljiv = vidljivost;
} 
void Zahvala(){
	_brojZahvala++; 
}  
void Ispis(){
	cout << _vrstaPosta;
	cout << _sadrzaj;
	cout << _brojZahvala;
	cout<<_IP << endl; 
	_datumPostavljanja->Ispis();
	if (_vidljiv)
		cout << "Post je vidljiv";
	else
		cout << "post nije vidljiv";
	cout << endl;
} 
void Dealociraj(){
	delete _datumPostavljanja;
	delete[] _sadrzaj; 
}
};
char * Enkriptuj(char * lozinka){
	char * l;
	int size = strlen(lozinka) + strlen("galeb") + 1;
	l = new char[size];
	strcpy_s(l, size, lozinka);
	strcat_s(l, size, "galeb");
	//strcat_s(l, size, '\0');
	int brojac = 0;
	char a;
	while (brojac < size-1){
		a = l[brojac];
		a = a + 2;
		l[brojac] = a;
		brojac++;
	}
	return l;
}
char * Dekriptuj(char * lozinka){
	char * l;
	int size = strlen(lozinka) - strlen("galeb");
	l = new char[size];
	strncpy_s(l, size, lozinka, size-1);
	strcat_s(l, size, '\0');
	int brojac = 0;
	char a;
	while (brojac < size - 1){
		a = l[brojac];
		a = a - 2;
		l[brojac] = a;
		brojac++;
	}
	return l;
}
struct User{
	Datum _datumPristupa; //datum registracije 
	char * _korisnickoIme;  
	char * _lozinka; 
	Post * _postovi; 
	int _trenutnoPostova; 
	Nivo _nivo;  

	void Ispis(){
		_datumPristupa.Ispis();
		cout<< " | " << _korisnickoIme << " | " << _lozinka << endl;
	}
	void Unos(Datum datum, char * korisnickoIme, char * lozinka){ 
		/*Na osnovu vrijednosti primljenog parametra izvrsiti inicijalizaciju odgovarajucih atributa. Lozinku je potrebno kriptovati
		na nacin na koji odaberete (predlozite neku logiku modifikacije znakova lozinke). Bitno je da sadrzaj lozinke nije citljiv
		prilikom ispisa, ali da se moze porediti sa drugim lozinkama, odnosno da se po istom principu moze i dekriptovati*/
		_datumPristupa = datum;
		_korisnickoIme = new char[strlen(korisnickoIme) + 1];
		strcpy_s(_korisnickoIme, strlen(korisnickoIme) + 1, korisnickoIme);
		_lozinka = Enkriptuj(lozinka);
		_postovi = nullptr;
		_trenutnoPostova = 0;

	}  bool AddNoviPost(Post o){  
		/*Funkcija ima zadatak da na osnovu primljenog parametra osigura dodavanje novog posta. Potrebno je onemoguciti dodavanje 
		identicnih postova, te u zavisnosti od uspjesnosti operacije funkcija treba vratiti true ili false.*/
		for (int i = 0; i < _trenutnoPostova; i++)
		{
			if (strcmp(_postovi[i]._sadrzaj, o._sadrzaj) == 0)
				return false;
		}
		Post * temp = new Post[_trenutnoPostova + 1];
		for (int i = 0; i < _trenutnoPostova; i++)
			temp[i] = _postovi[i];
		//for (int i = 0; i < _trenutnoPostova; i++)
		//	_postovi[i].Dealociraj();
		delete[] _postovi;
		temp[_trenutnoPostova] = o;
		_postovi = temp;
		_trenutnoPostova++;
		temp = nullptr;
		return true;

	}
	Nivo FormirajNivo(){ 
		/*Na osnovu broj zahvala na postovima funkcija odredjuje nivo korisnika (nivo = BrojZahvala/BrojPostova) , a prema sljedecim pravilima: 
		0 - 10 ---- Pocetnik,   11 - 30 ---- Clan,   31 - 70 ---- NapredniClan,   > 71 - ---- Moderator   na kraju funkcija vraca
		novoformirani nivo korisnika.*/ 
		int ukupnoZahvala = 0;
		for (int i = 0; i < _trenutnoPostova; i++)
		{
			ukupnoZahvala += _postovi[i]._brojZahvala;
		}
		ukupnoZahvala /= _trenutnoPostova;
		Nivo n;
		if (ukupnoZahvala >= 0 && ukupnoZahvala <= 10)
			n = Pocetnik;
		else if (ukupnoZahvala >10 && ukupnoZahvala <= 30)
			n = Clan;
		else if (ukupnoZahvala > 30 && ukupnoZahvala <= 70)
			n = NapredniClan;
		else if (ukupnoZahvala > 70)
			n = Moderator;
		return n;

	}
	Post * GetPostovePoSadrzaju(char * sadrzaj,int &brojac){
		/*Funkcija vraca niz postova koji posjeduju dio sadrzaja odredjenog vrijednoscu parametra. Ukoliko trazeni sadrzaj ne 
		postoji funkcija vraca NULL*/
		Post * p = nullptr;
		for (int i = 0; i < _trenutnoPostova; i++)
		{
			if (strstr(_postovi[i]._sadrzaj, sadrzaj)!=nullptr){
				Post * temp = new Post[brojac + 1];
				for (int i = 0; i < brojac; i++)
					temp[i] = p[i];
				delete[] p;
				temp[brojac] = _postovi[i];
				p = temp;
				temp = nullptr;
				brojac++;
			}
		}
		if (p == nullptr)
			return NULL;
		else
			return p;
	}
};
User * Pretraga(User * u, int max){  
	/*Funkcija ima zadatak da pronadje i vrati korisnika koji je sa odredjene IP adrese u odredjeno vrijeme (datum) pristupao sistemu.
	Vrijednost IP adrese i datuma za pretragu se unosi na pocetku izvrsenja funkcije. Prije vracanja pokazivaca na pronadjenog korisnika
	funkcija treba postaviti vidljivost svih njegovih postova na false. Ukoliko trazeni korisnik ne postoji funkcija treba da vrati NULL*/
	char *IP = { "192.168.1.1" };
	Datum d;
	d.Unos(10, 6, 2017);

	User * user = nullptr;
	for (int i = 0; i < max; i++)
	{
		for (int j = 0; j < u[i]._trenutnoPostova; j++)
		{
			if (d.DaLiSuIsti(*u[i]._postovi[j]._datumPostavljanja) && strcmp(u[i]._postovi[j]._IP, IP) == 0)
				user = &u[i];
		}
	}
	for (int i = 0; i < user->_trenutnoPostova; i++)
	{
		user->_postovi[i]._vidljiv = false;
	}
	return user;

}
void main(){  
	//izbjegavajte koristenje vlastitog imena i prezimena.  
	//provjeriti validnost izvrsenja svih dostupnih funkcionalnosti  1.

	Datum d1, d2, d3, d4;
	d1.Unos(10, 6, 2017);
	d2.Unos(16, 6, 2017);
	d3.Unos(13, 6, 2017);
	d4.Unos(23,3, 2017);

	d1.Ispis();
	d3.Ispis();

	Post p1, p2, p3, p4;
	Vrsta * v = new Vrsta;
	*v = Pitanje;
	p1.Unos(v, &d1, "Da li je zemlja okrugla","192.168.1.1",10);
	*v = Komentar;
	p2.Unos(v, &d2, "Da zemlja je okrugla", " 192.168.1.3",20);
	*v = Zadatak;
	p3.Unos(v, &d3, "Koje je boje trava", " 192.168.1.4",30);
	*v = Spam;
	p4.Unos(v, &d4, "Koje je boje trava", "192.168.1.5 ",100);

	p1.Ispis();
	p3.Ispis();

	User u1;
	u1.Unos(d1, "Huso Husic", "tastatura");

	u1.Ispis();

	if (u1.AddNoviPost(p1))
		cout << "p1 je uspjesno dodan" << endl;
	if (u1.AddNoviPost(p2))
		cout << "p2 je uspjesno dodan" << endl;
	if (u1.AddNoviPost(p3))
		cout << "p3 je uspjesno dodan" << endl;
	if (u1.AddNoviPost(p4))
		cout << "p4 je uspjesno dodan" << endl;

	Nivo n= u1.FormirajNivo();
	cout <<"Korisnik"<<u1._korisnickoIme<<"ima nivo "<< NivoChar[n];
	cout << endl;
	int brojac = 0;
	Post *p=u1.GetPostovePoSadrzaju("zemlja",brojac);
	for (int i = 0; i < brojac; i++)
		p[i].Ispis();

	cout << endl;
	
	User * user = Pretraga(&u1, 1);
	user->Ispis();

	char * lozinka = Dekriptuj(u1._lozinka);
	cout << lozinka << endl;

	delete v;
	p1.Dealociraj();
	p2.Dealociraj();
	p3.Dealociraj();
	p4.Dealociraj();
	delete[] p;
	p = nullptr;
	user = nullptr;

	system("pause");
}

_________________________________________________________________________________



#include <iostream> 
using namespace std;
struct Datum{ 
	int dan, mjesec, godina;

	void Unos(int da, int mj, int go){
		dan = da;
		mjesec = mj;
		godina = go;
	}
	void Ispis(){
		cout << dan << "/" << mjesec << "/" << godina << endl;
	}
	bool DalijeMladji(Datum datumRodjenja){
		if (godina < datumRodjenja.godina)
			return true;
		else if (godina == datumRodjenja.godina){
			if (mjesec < datumRodjenja.mjesec)
				return true;
			else if (mjesec == datumRodjenja.mjesec){
				if (dan <= datumRodjenja.dan)
					return true;
			}
		}
		return false;
	}
}; 
struct Student{ 
	char _indeks[9];//IB130130 
	char _imePrezime[30]; 
	Datum _datumRodjenja; 

	void Unos(char * index,char  * imePrezime,Datum d){
		strcpy_s(_indeks,9, index);
		strcpy_s(_imePrezime,30, imePrezime);
		_datumRodjenja = d;
	}
	void Ispis(){
		cout << _indeks << " | " << _imePrezime << " | ";
		_datumRodjenja.Ispis();
	}
};
char * GetSljedeciBrojIndeksa(char * posljednji){
	/*Funkcija treba da vrati sljedeci broj indeksa (u odnosu na onaj koji je primljen kao parametar)prateci format IB130XXX pri cemu
	je fiksni dio u oznaci indeksa IB130, a posljednje 3 oznake se mijenjaju. Voditi racuna da broj indeksa uvijek posjeduje 8 znakova*/

	char * novi = new char[9];
	strcpy_s(novi, 9, "IB160");
	strcat_s(novi, 9, posljednji);

	return novi;

}
Student * GetStudentePoDatumuRodjenja(Student * lista, int max, Datum starijiOd,int & brojac){ 
	/*Funkcija treba da vrati niz studenata koji su rodeni nakon datuma rodenja definisanog parametrom starijiOD. Ako ne postoji niti
	jedan student koji zadovoljava uslove pretrage, onda funkcija vraca NULL*/
	Student *niz = nullptr;
	for (int i = 0; i < max; i++)
	{
		if (starijiOd.DalijeMladji(lista[i]._datumRodjenja)){
			Student * temp = new Student[brojac + 1];
			for (int i = 0; i < brojac; i++)
				temp[i] = niz[i];
			delete[] niz;
			temp[brojac] = lista[i];
			niz = temp;
			brojac++;
			temp = nullptr;
		}
	}
	if (niz != nullptr)
		return niz;
	return nullptr;
}
int main(){ 
	//1. korisniku omoguciti da odredi koliko objekata tipa Student zeli kreirati. 
	// Objekte kreirati u dinamickoj memoriji 
	cout << "Unesite koliko studenata zelite" << endl;
	int brojStudenata;
	cin >> brojStudenata;
	cin.ignore();
		Student * studenti = new Student[brojStudenata];

	//2. korisniku omoguciti da unutar main funkcije inicijalizuje vrijednosti  
	// atributa svakog studenta. Tom prilikom iskoristiti funkciju  
	// GetSljedeciBrojIndeksa 
		char * posljednji = new char[4];
		Datum datumRodjenja;
		int d, m, g;
		cin.ignore();
		for (int i = 0; i < brojStudenata; i++)
		{
			cout << "Unesite zadnje 3 cifre za index studenta " << i + 1 << endl;
			cin.getline(posljednji, 4);
			char * brIndexa = GetSljedeciBrojIndeksa(posljednji);
			cout << "Unesite ime i prezime" << endl;
			char imePrezime[30];
			cin.getline(imePrezime, 30);
			cout << "Unesite dan mjesec i godinu" << endl;
			cin >> d >> m >> g;
			cin.ignore();
			datumRodjenja.Unos(d, m, g);
			studenti[i].Unos(brIndexa, imePrezime, datumRodjenja);

		}
	//3. korisniku omoguciti pretragu studenata po datumu rodjenja, te ispisati 
	// rezultat pretrage 
		Datum StarijiOD;
		StarijiOD.Unos(1, 1, 1992);
		int brojac = 0;
		Student * niz = GetStudentePoDatumuRodjenja(studenti, brojStudenata, StarijiOD, brojac);
		for (int i = 0; i < brojac; i++)
		{
			niz[i].Ispis();
		}
	//4. izvrsiti potrebne dealokacije 
		delete[] studenti; 
		studenti = nullptr;
		delete posljednji;
		posljednji = nullptr;

		system("pause");
	return 0;
} 

__________________________________________________________________________


#include<iostream> 
using namespace std;

enum Kompanija{ Pegasus, TurkishAirlines, AustrianAirlines, FlyEmirates };
int ID = 1;

struct Putnik{
	int _putnikID; 
	char * _imePrezime; 
	float _brojPredjenihMilja;

	void Unos(char * imePrezime,float milje){ 
		int size = strlen(imePrezime) + 1; 
		_imePrezime = new char[size]; 
		strcpy_s(_imePrezime, size, imePrezime);
		_brojPredjenihMilja = milje;
		_putnikID = ID++;
	} 
	void Info(){ 
		cout << "[" << _putnikID << "] " << _imePrezime <<    " (" << _brojPredjenihMilja << " milja)" << endl;
	} 
	void Dealociraj(){
		delete[] _imePrezime;
		_imePrezime = nullptr;
	} 
	void DodajPredjeneMilje(int brojMilja){
		_brojPredjenihMilja += brojMilja;
	}
};
struct Rezervacija{
	Putnik _putnik;
	int _oznakaSjedista;
	float _cijena; 
	void Unos(Putnik * putnik, int oznaka, float cijena){ 
		_putnik.Unos(putnik->_imePrezime,putnik->_brojPredjenihMilja); 
		_oznakaSjedista = oznaka;
		_cijena = cijena;
	} 
	void Info(){
		_putnik.Info(); 
		cout << "Sjediste: " << _oznakaSjedista << " Cijena: " << _cijena << endl;
	} 
	void Dealociraj(){ 
		_putnik.Dealociraj();
	}
}; 
struct Let{
	Kompanija _kompanija; 
	char * _pocetak; //pocetna lokacija 
	char * _destinacija; 
	Rezervacija * _rezervacije[100]; 
	float * _brojMilja; //odnosi se na duzinu leta – broj predjenih milja 
	float * _cijenaKarte; 

	void Ispis(){
		cout << _pocetak << " |" << _destinacija << " |" << *_brojMilja << " |" << *_cijenaKarte << endl;
		int brojac = 0;
		while (_rezervacije[brojac] != nullptr){
			_rezervacije[brojac]->Info();
		}
	}
	void Unos(Kompanija * kompanija, char * pocetak, char * destinacija,   float brojMilja, float cijenaKarte){  
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture. predloziti mehanizam 
		pracenja broja slobodnih mjesta bez uvodjenja dodatnih atributa */ 
		_pocetak = new char[strlen(pocetak) + 1];
		strcpy_s(_pocetak, strlen(pocetak) + 1, pocetak);
		_destinacija = new char[strlen(destinacija) + 1];
		strcpy_s(_destinacija, strlen(destinacija) + 1, destinacija);
		for (int i = 0; i < 100; i++)
			_rezervacije[i] = nullptr;
		_brojMilja = new float;
		*_brojMilja = brojMilja;
		_cijenaKarte = new float;
		*_cijenaKarte = cijenaKarte;

	} 
	void Dealociraj(){ 
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani za potrebe objekta tipa Let*/ 
		delete[] _pocetak;
		delete[] _destinacija;
		int brojac = 0;
		while (_rezervacije[brojac]!=nullptr){
			_rezervacije[brojac]->Dealociraj();
			brojac++;
		}
		delete _brojMilja;
		delete _cijenaKarte;
	}
	bool AddRezervaciju(Putnik * p){  
		/*putniku se dodjeljuje prvo slobodno sjediste pri cemu ce oznaka sjedista biti identicna lokaciji rezervacije u nizu.
		prilikom dodjeljivanja slobodnog sjedista voditi racuna o broju predjenih milja putnika. ako je putnik presao vise od 
		50000 milja onda mu je potrebno ponuditi sjediste pored prozora (pretpostavimo da su sva sjedista sa neparnim indeksom
		sjedista pored prozora).u slucaju da putnik ne zeli mjesto pored prozora, onda mu se dodjeljuje prvo slobodno sjediste. 
		onemoguciti dodavanje rezervacija sa identicnim putnicima (isti putnikID i imePrezime). u zavisnosti od uspjesnosti 
		funkcija vraca true ili false */ 
		int brojac = 0;
		while (_rezervacije[brojac] != nullptr){
			brojac++;
		}
		for (int i = 0; i < brojac; i++)
		{
			if (strcmp(p->_imePrezime, _rezervacije[i]->_putnik._imePrezime) == 0 && p->_putnikID == _rezervacije[i]->_putnik._putnikID){
				return false;
			}
		}
		if (p->_brojPredjenihMilja > 50000){
			cout << "Da li zelite mjesto do prozora(D/N)" << endl;
			char slovo;
			cin >> slovo;
			slovo = toupper(slovo);
			if (slovo == 'D'){
				if (brojac % 2 != 0)
					brojac++;
			}
		}
		_rezervacije[brojac] = new Rezervacija;
		_rezervacije[brojac]->_putnik = *p;
		return true;
	} 
		bool RemoveRezervaciju(char * imePrezime){  
		/*na osnovu vrijednosti parametra izvrsiti uklanjanje rezervacije iz niza. voditi racuna o alociranom memorijskom prostoru.
		u zavisnosti od uspjesnosti funkcija vraca true ili false */ 
			int brojac = 0;
			while (_rezervacije[brojac] != nullptr){
				if (strcmp(_rezervacije[brojac]->_putnik._imePrezime, imePrezime) == 0){
					_rezervacije[brojac]->Dealociraj();
					_rezervacije[brojac] = nullptr;
					return true;
				}
				brojac++;
			}
			return false;
	} 
}; 
//float GetMiljeByKompanija(Let * letovi, int maxLetova, Kompanija kompanija,  Putnik * putnik){ 
//	/*funkcija vraca broj milja koje je putnik (proslijedjen kao parametar funkcije) ostvario putujuci sa kompanijom koja je takodjer
//	proslijedjena kao parametar funkcije*/ }
void main(){
	/*provjeriti validnost izvrsenja svih dostupnih funkcionalnosti.
	izbjegavajte koristenje vlastitog imena i prezimena*/

	Putnik p1, p2, p3;
	p1.Unos("Fedja Fedjic",54000);
	p2.Unos("Rule Rulic",30000);
	p3.Unos("Cile Mile",80000);
	p2.Info();
	p1.Info();

	cout << endl;

	Rezervacija r1, r2, r3;
	r1.Unos(&p1, 12, 450);
	r2.Unos(&p2, 13, 450);
	r3.Unos(&p3, 16, 200);
	r1.Info();
	r2.Info();

	cout << endl;

	Let l1;
	Kompanija * k = new Kompanija;
	*k = TurkishAirlines;
	l1.Unos(k, "Sarajevo", "Berlin", 1200, 620);
	l1.Ispis();
	
	cout << endl;
	if (l1.AddRezervaciju(&p1))
		cout << "Rezervacija za p1 je dodana..." << endl;
	if (l1.AddRezervaciju(&p2))
		cout << "Rezervacijaza p2 je dodana..." << endl;
	if (l1.AddRezervaciju(&p1))
		cout << "Rezervacija za p1 je dodana..." << endl;
	if (l1.AddRezervaciju(&p3))
		cout << "Rezervacija za p3 je dodana..." << endl;

	cout << endl;
	
	if (l1.RemoveRezervaciju("Rule Rulic"))
		cout << "rezervacija p2 izbrisana..." << endl;
	if (l1.RemoveRezervaciju("meho Mehic"))
		cout << "rezervacija izbrisana..." << endl;

	//p1.Dealociraj();
	//p2.Dealociraj();
	//p3.Dealociraj();

	//r1.Dealociraj();
	//r2.Dealociraj();
	//r3.Dealociraj();

	delete k; k = nullptr;

	l1.Dealociraj();

	system("pause");
}

________________________________________________________________________



#include <iostream>
using namespace std;
/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/
//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char *crt = "\n-------------------------------------------\n";

enum eNacinStudiranja { REDOVAN, DL };
enum eRazred { PRVI = 1, DRUGI, TRECI, CETVRTI };


struct DatumVrijeme {
int *_dan, *_mjesec, *_godina, *_sati, *_minuti;
void Unos(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0) {
_dan = new int(dan);
_mjesec = new int(mjesec);
_godina = new int(godina);
_sati = new int(sati);
_minuti = new int(minuti);
}
void Dealociraj() {
delete _dan; _dan = nullptr;
delete _mjesec; _mjesec = nullptr;
delete _godina; _godina = nullptr;
delete _sati; _sati = nullptr;
delete _minuti; _minuti = nullptr;
}
void Ispis() {
cout << *_dan << "." << *_mjesec << "." << *_godina << " " << *_sati << ":" << *_minuti << endl;
}
};

const DatumVrijeme rokZaPrijavu = { new int(5), new int(7), new int(2017), new int(12), new int(30) };


struct Predmet {
char * _naziv;
int _ocjena;
DatumVrijeme * _datumUnosa;
void Unos(char * naziv, int ocjena, DatumVrijeme datumUnosa) {
int vel = strlen(naziv) + 1;
_naziv = new char[vel];
strcpy_s(_naziv, vel, naziv);
_ocjena = ocjena;
_datumUnosa->Unos(*datumUnosa._dan, *datumUnosa._mjesec, *datumUnosa._godina, *datumUnosa._sati, *datumUnosa._minuti);
}
void Dealociraj() {
delete[] _naziv; _naziv = nullptr;
_datumUnosa->Dealociraj(); delete _datumUnosa;
}

void Ispis() {
//kreirati funkciju GetDatumKaoNizKaraktera() koja vraca vrijednosti atributa strukture datum kao niz karaktera
cout << _naziv << " (" << _ocjena << ") " << _datumUnosa->GetDatumKaoNizKaraktera() << endl;
}
};

struct Uspjeh {
eRazred _razred;
Predmet * _predmeti;
int _brojPredmeta;
void Unos(eRazred razred) {
_razred = razred;
_predmeti = nullptr;
_brojPredmeta = 0;
}
void Dealociraj() {
for (size_t i = 0; i < _brojPredmeta; i++)
_predmeti[i].Dealociraj();
delete[] _predmeti; _predmeti = nullptr;
}

void Ispis() {
cout << crt << "Razred -> " << _razred << crt;
for (size_t i = 0; i < _brojPredmeta; i++)
_predmeti[i].Ispis();
}
};

struct Kandidat {
eNacinStudiranja _nacinStudiranja;
char * _imePrezime;
shared_ptr<Uspjeh> _uspjeh[4];

void Unos(eNacinStudiranja nacinStudiranja, char * imePrezime) {
int vel = strlen(imePrezime) + 1;
_imePrezime = new char[vel];
strcpy_s(_imePrezime, vel, imePrezime);
_nacinStudiranja = nacinStudiranja;
for (size_t i = 0; i < 4; i++)
_uspjeh[i] = nullptr;
}
void Dealociraj() {
delete[] _imePrezime; _imePrezime = nullptr;
for (size_t i = 0; i < 4; i++)
_uspjeh[i]->Dealociraj();
}
void Ispis() {
cout << crt << _imePrezime << " " << _nacinStudiranja;
for (size_t i = 0; i < 4; i++)
_uspjeh[i]->Ispis();
}
};

void main()
{
DatumVrijeme datum19062017_1015, datum20062017_1115, datum30062017_1215, datum05072017_1231;
datum19062017_1015.Unos(19, 6, 2017, 10, 15);
datum20062017_1115.Unos(20, 6, 2017, 11, 15);
datum30062017_1215.Unos(30, 6, 2017, 12, 15);
datum05072017_1231.Unos(5, 7, 2017, 12, 31);

cout << datum19062017_1015.GetDatumKaoNizKaraktera() << endl;//9.6.2017 10:15

Predmet Matematika, Fizika, Hemija, Engleski;
//2 - ocjena na predmetu; datum - datum evidentiranja uspjeha na predmetu jer postoji krajnji rok za evidentiranje
Matematika.Unos("Matematika", 2, datum19062017_1015);
Fizika.Unos("Fizika", 5, datum20062017_1115);
Hemija.Unos("Hemija", 2, datum20062017_1115);
Engleski.Unos("Engleski", 5, datum05072017_1231);

int brojKandidata = 2;

Kandidat * prijave2017 = new Kandidat[brojKandidata];
prijave2017[0].Unos(DL, "Jasmin Azemovic");
prijave2017[1].Unos(REDOVAN, "Indira Hamulic");

/*
uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda.
prilikom dodavanja onemoguciti:
- dodavanje predmeta za razrede koji nisu definisani enumeracijom,
- dodavanje istoimenih predmeta na nivou jednog razreda,
- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda za I razred i sl.). Funkcija vraca true ili false u zavisnosti od (ne)uspjesnost izvrsenja
*/
if (prijave2017[0].DodajPredmet(DRUGI, Engleski))//ne bi trebao dodati jer je prosao postavljeni rok za dodavanje predmeta
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[0].DodajPredmet(DRUGI, Matematika))
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[0].DodajPredmet(PRVI, Fizika))
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[0].DodajPredmet(PRVI, Hemija))
cout << "Predmet uspjesno dodan!" << crt;

Matematika._ocjena = 5;
Hemija._ocjena = 3;

if (prijave2017[1].DodajPredmet(PRVI, Matematika))
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[1].DodajPredmet(PRVI, Matematika))//ne bi trebalo ponovo dodati Matematiku!
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[1].DodajPredmet(TRECI, Hemija))
cout << "Predmet uspjesno dodan!" << crt;
if (prijave2017[1].DodajPredmet(DRUGI, Engleski))
cout << "Predmet uspjesno dodan!" << crt;

/*
koristeci Lambda izraz kreirati funkciju koja ce vratiti uspjeh kandidata koji je ostvario najveci prosjek (na nivou razreda, a ne ukupni prosjek). ukoliko vise kandidata ima isti prosjek funkcija vraca uspjeh (najboljeg razreda) prvog pronadjenog kandidata
*/
auto najboljiUspjeh = /*...*/;
shared_ptr<Uspjeh> najbolji = najboljiUspjeh();
najbolji->Ispis();

/*
napisati rekurzivnu funkciju koja ce vratiti pokazivac na kandidata sa najvecom ocjenom na predmetu koji je proslijedjen kao parametar. ukoliko je vise kandidata ostvarilo istu ocjenu, funkcija treba da vrati onog kandidata koji je prvi evidentirao tu ocjenu (ako je isto vrijeme evidentiranja, onda funkcija vraca kandidata koji je prvi u nizu).	u slucaju da niti jedan kandidat nije evidentirao trazeni predmet funkcija vraca nullptr. u nastavku je prikazan primjer poziva rekurzivne funkcije, a ostale parametre dodajte po potrebi.
*/
Kandidat * kandidatSaNajboljomOcjenom = rekNajboljaOcjena(prijave2017, brojKandidata, "Matematika");

for (size_t i = 0; i < brojKandidata; i++)
{
prijave2017[i].Ispis();
prijave2017[i].Dealociraj();
}
delete[] prijave2017;
prijave2017 = nullptr;

system("pause>0");
}


__________________________________________________________________________________

#include <iostream>
#include <memory>
using namespace std;
/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/
//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char *crt = "\n-------------------------------------------\n";

enum eNacinStudiranja { REDOVAN, DL };
enum eRazred { PRVI = 1, DRUGI, TRECI, CETVRTI };


struct DatumVrijeme {
	int *_dan, *_mjesec, *_godina, *_sati, *_minuti;
	void Unos(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0) {
		_dan = new int(dan);
		_mjesec = new int(mjesec);
		_godina = new int(godina);
		_sati = new int(sati);
		_minuti = new int(minuti);
	}
	void Dealociraj() {
		delete _dan; _dan = nullptr;
		delete _mjesec; _mjesec = nullptr;
		delete _godina; _godina = nullptr;
		delete _sati; _sati = nullptr;
		delete _minuti; _minuti = nullptr;
	}
	void Ispis() {
		cout << *_dan << "." << *_mjesec << "." << *_godina << " " << *_sati << ":" << *_minuti << endl;
	}

	char *GetDatumKaoNizKaraktera(){
		char dan[3], mjesec[3], godina[5], sati[3], minuti[3];
		_itoa(*_dan, dan, 10);
		_itoa(*_mjesec, mjesec, 10);
		_itoa(*_godina, godina, 10);
		_itoa(*_sati, sati, 10);
		_itoa(*_minuti, minuti, 10);

		int size = strlen(dan) + strlen(mjesec) + strlen(godina) + strlen(sati) + strlen(minuti) + 6;
		char *char_datum = new char[size];

		strcpy_s(char_datum, size, dan);
		strcat_s(char_datum, size, ".");
		strcat_s(char_datum, size, mjesec);
		strcat_s(char_datum, size, ".");
		strcat_s(char_datum, size, godina);
		strcat_s(char_datum, size, " ");
		strcat_s(char_datum, size, sati);
		strcat_s(char_datum, size, ":");
		strcat_s(char_datum, size, minuti);

		return char_datum;
	}
};

const DatumVrijeme rokZaPrijavu = { new int(5), new int(7), new int(2017), new int(12), new int(30) };


struct Predmet {
	char * _naziv;
	int _ocjena;
	DatumVrijeme * _datumUnosa;
	void Unos(char * naziv, int ocjena, DatumVrijeme datumUnosa) {
		int vel = strlen(naziv) + 1;
		_naziv = new char[vel];
		strcpy_s(_naziv, vel, naziv);
		_ocjena = ocjena;
		_datumUnosa = new DatumVrijeme;
		_datumUnosa->Unos(*datumUnosa._dan, *datumUnosa._mjesec, *datumUnosa._godina, *datumUnosa._sati, *datumUnosa._minuti);
	}
	void Dealociraj() {
		delete[] _naziv; _naziv = nullptr;
		_datumUnosa->Dealociraj(); delete _datumUnosa;
	}

	void Ispis() {
		//kreirati funkciju GetDatumKaoNizKaraktera() koja vraca vrijednosti atributa strukture datum kao niz karaktera
		cout << _naziv << " (" << _ocjena << ") " << _datumUnosa->GetDatumKaoNizKaraktera() << endl;
	}
};

struct Uspjeh {
	eRazred _razred;
	Predmet * _predmeti;
	int _brojPredmeta;
	void Unos(eRazred razred) {
		_razred = razred;
		_predmeti = nullptr;
		_brojPredmeta = 0;
	}
	void Dealociraj() {
		for (size_t i = 0; i < _brojPredmeta; i++)
			_predmeti[i].Dealociraj();
		delete[] _predmeti; _predmeti = nullptr;
	}

	void Ispis() {
		cout << crt << "Razred -> " << _razred << crt;
		for (size_t i = 0; i < _brojPredmeta; i++)
			_predmeti[i].Ispis();
	}
	void DodajPredmet(Predmet p){
		Predmet *temp = new Predmet[_brojPredmeta + 1];
		for (size_t i = 0; i < _brojPredmeta; i++)
		{
			temp[i].Unos(_predmeti[i]._naziv, _predmeti[i]._ocjena, *_predmeti[i]._datumUnosa);
			_predmeti[i].Dealociraj();
		}
		if (_predmeti != nullptr)
			delete[] _predmeti;
		temp[_brojPredmeta].Unos(p._naziv, p._ocjena, *p._datumUnosa);
		_predmeti = temp;
		_brojPredmeta++;
	}
};

struct Kandidat {
	eNacinStudiranja _nacinStudiranja;
	char * _imePrezime;
	shared_ptr<Uspjeh> _uspjeh[4];

	void Unos(eNacinStudiranja nacinStudiranja, char * imePrezime) {
		int vel = strlen(imePrezime) + 1;
		_imePrezime = new char[vel];
		strcpy_s(_imePrezime, vel, imePrezime);
		_nacinStudiranja = nacinStudiranja;
		for (size_t i = 0; i < 4; i++)
			_uspjeh[i] = nullptr;
	}
	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
		for (size_t i = 0; i < 4; i++)
		if (_uspjeh[i] != nullptr)
			_uspjeh[i]->Dealociraj();
	}
	void Ispis() {
		cout << crt << _imePrezime << " " << _nacinStudiranja;
		for (size_t i = 0; i < 4; i++)
		if (_uspjeh[i] != nullptr)
			_uspjeh[i]->Ispis();
	}
	int PretvoriUDane(DatumVrijeme d){
		return *d._dan + *d._mjesec * 30 + *d._godina * 365;
	}
	bool DodajPredmet(eRazred razred, Predmet p){
		if (razred != PRVI && razred != DRUGI && razred != TRECI && razred != CETVRTI)
			return false;
		
		if (_uspjeh[(int)razred - 1] != nullptr){
			for (size_t i = 0; i < _uspjeh[(int)razred - 1]->_brojPredmeta; i++)
			{
				if (strcmp(_uspjeh[(int)razred - 1]->_predmeti[i]._naziv, p._naziv) == 0)
					return false;
			}
		}
		if (PretvoriUDane(rokZaPrijavu) <= PretvoriUDane(*p._datumUnosa))
			return false;
		if (_uspjeh[(int)razred - 1] == nullptr){
			_uspjeh[(int)razred - 1] = make_shared<Uspjeh>();
			_uspjeh[(int)razred - 1]->Unos(razred);
		}
		_uspjeh[(int)razred - 1]->DodajPredmet(p);
		return true;
	}
};

Kandidat *rekNajboljaOcjena(Kandidat *kandidati, int broj_kandidata, char *predmet, Kandidat *najbolja_ocjena = nullptr, int ocjena = 0, int razred = 0, int broj_predmeta = 0){
	if (broj_kandidata <= 0)
		return najbolja_ocjena;
	if (najbolja_ocjena == nullptr)
		return rekNajboljaOcjena(kandidati, broj_kandidata, predmet, &kandidati[broj_kandidata - 1]);
	if (razred == 4)
		return rekNajboljaOcjena(kandidati, broj_kandidata - 1, predmet, najbolja_ocjena, ocjena);
	if (kandidati[broj_kandidata - 1]._uspjeh[razred] != nullptr){
		if (broj_predmeta == kandidati[broj_kandidata - 1]._uspjeh[razred]->_brojPredmeta)
			return rekNajboljaOcjena(kandidati, broj_kandidata, predmet, najbolja_ocjena, ocjena, razred + 1);
		if (strcmp(predmet, kandidati[broj_kandidata - 1]._uspjeh[razred]->_predmeti[broj_predmeta]._naziv) == 0){
			if (ocjena < kandidati[broj_kandidata - 1]._uspjeh[razred]->_predmeti[broj_predmeta]._ocjena)
				return rekNajboljaOcjena(kandidati, broj_kandidata, predmet, najbolja_ocjena, ocjena, razred, broj_predmeta + 1);
		}
		return rekNajboljaOcjena(kandidati, broj_kandidata, predmet, najbolja_ocjena, ocjena, razred, broj_predmeta + 1);
	}
	return rekNajboljaOcjena(kandidati, broj_kandidata, predmet, najbolja_ocjena, ocjena, razred + 1);
}

void main()
{
	DatumVrijeme datum19062017_1015, datum20062017_1115, datum30062017_1215, datum05072017_1231;
	datum19062017_1015.Unos(19, 6, 2017, 10, 15);
	datum20062017_1115.Unos(20, 6, 2017, 11, 15);
	datum30062017_1215.Unos(30, 6, 2017, 12, 15);
	datum05072017_1231.Unos(5, 7, 2017, 12, 31);

	cout << datum19062017_1015.GetDatumKaoNizKaraktera() << endl;//9.6.2017 10:15

	Predmet Matematika, Fizika, Hemija, Engleski;
	//2 - ocjena na predmetu; datum - datum evidentiranja uspjeha na predmetu jer postoji krajnji rok za evidentiranje
	Matematika.Unos("Matematika", 2, datum19062017_1015);
	Fizika.Unos("Fizika", 5, datum20062017_1115);
	Hemija.Unos("Hemija", 2, datum20062017_1115);
	Engleski.Unos("Engleski", 5, datum05072017_1231);

	int brojKandidata = 2;

	Kandidat * prijave2017 = new Kandidat[brojKandidata];
	prijave2017[0].Unos(DL, "Jasmin Azemovic");
	prijave2017[1].Unos(REDOVAN, "Indira Hamulic");

	/*
	uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda.
	prilikom dodavanja onemoguciti:
	- dodavanje predmeta za razrede koji nisu definisani enumeracijom,
	- dodavanje istoimenih predmeta na nivou jednog razreda,
	- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
	razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda za I razred i sl.). Funkcija vraca true ili false u zavisnosti od (ne)uspjesnost izvrsenja
	*/
	if (prijave2017[0].DodajPredmet(DRUGI, Engleski))//ne bi trebao dodati jer je prosao postavljeni rok za dodavanje predmeta
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(DRUGI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Fizika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;

	Matematika._ocjena = 5;
	Hemija._ocjena = 3;

	if (prijave2017[1].DodajPredmet(PRVI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(PRVI, Matematika))//ne bi trebalo ponovo dodati Matematiku!
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(TRECI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(DRUGI, Engleski))
		cout << "Predmet uspjesno dodan!" << crt;

	///*
	//koristeci Lambda izraz kreirati funkciju koja ce vratiti uspjeh kandidata koji je ostvario najveci prosjek (na nivou razreda, a ne ukupni prosjek). ukoliko vise kandidata ima isti prosjek funkcija vraca uspjeh (najboljeg razreda) prvog pronadjenog kandidata
	//*/
	auto najboljiUspjeh = [prijave2017, brojKandidata]()-> shared_ptr<Uspjeh> {
		float prosjek1 = 0;
		float prosjek2 = 0;
		shared_ptr<Uspjeh> pok = nullptr;
		for (size_t i = 0; i < brojKandidata; i++)
		{
			for (size_t j = 0; j < 4; j++)
			{
				prosjek1 = 0;
				if (prijave2017[i]._uspjeh[j] != nullptr){
					for (size_t k = 0; k < prijave2017[i]._uspjeh[j]->_brojPredmeta; k++)
					{
						prosjek1 = prosjek1 + prijave2017[i]._uspjeh[j]->_predmeti[k]._ocjena;
					}
					prosjek1 = prosjek1 / prijave2017[i]._uspjeh[j]->_brojPredmeta;
					if (prosjek1 > prosjek2){
						prosjek2 = prosjek1;
						pok = prijave2017[i]._uspjeh[j];
					}
				}
			}
		}
		return pok;
	};
	shared_ptr<Uspjeh> najbolji = najboljiUspjeh();
	najbolji->Ispis();

	///*
	//napisati rekurzivnu funkciju koja ce vratiti pokazivac na kandidata sa najvecom ocjenom na predmetu koji je proslijedjen kao parametar. ukoliko je vise kandidata ostvarilo istu ocjenu, funkcija treba da vrati onog kandidata koji je prvi evidentirao tu ocjenu (ako je isto vrijeme evidentiranja, onda funkcija vraca kandidata koji je prvi u nizu).	u slucaju da niti jedan kandidat nije evidentirao trazeni predmet funkcija vraca nullptr. u nastavku je prikazan primjer poziva rekurzivne funkcije, a ostale parametre dodajte po potrebi.
	//*/
	Kandidat * kandidatSaNajboljomOcjenom = rekNajboljaOcjena(prijave2017, brojKandidata, "Matematika");
	kandidatSaNajboljomOcjenom->Ispis();

	for (size_t i = 0; i < brojKandidata; i++)
	{
		prijave2017[i].Ispis();
		prijave2017[i].Dealociraj();
	}

	datum05072017_1231.Dealociraj(); datum19062017_1015.Dealociraj(); datum20062017_1115.Dealociraj(); datum30062017_1215.Dealociraj();
	
	delete[] prijave2017;
	prijave2017 = nullptr;

	system("pause>0");

}

_________________________________________________________

#include<iostream> 
using namespace std;

enum VrstaObaveze{ Seminarski, Parcijalni1, Parcijalni2, Integralni };
char * VrstaObavezeText[] = { "Seminarski", "Parcijalni1", "Parcijalni2", "Integralni" };

struct Datum{
	int * _dan;
	int *_mjesec;
	int *_godina;

	void Unos(int d, int m, int g){
		_dan = new int;
		*_dan = d;
		_mjesec = new int;
		*_mjesec = m;
		_godina = new int;
		*_godina = g;
	}
	void Ispis(){
		cout << *_dan << "/" << *_mjesec << "/" << *_godina << endl;
	}
	void Dealociraj(){
		delete _dan;
		delete  _mjesec;
		delete _godina;
	}
};
struct ObavezeNaPredmetu{
	VrstaObaveze _vrstaObaveze;
	Datum * _datumIzvrsenja;
	int _ocjena; // 5 - 10  
	char * _komentar;
	void Unos(VrstaObaveze vrsta, Datum * datum, int ocjena){
		_vrstaObaveze = vrsta;
		_datumIzvrsenja = new Datum;
		_datumIzvrsenja->Unos(*datum->_dan, *datum->_mjesec, *datum->_godina);
		_ocjena = ocjena;
		_komentar = nullptr;
	}
	void DodajKomentar(char * komentar){
		char * temp;
		if (_komentar != nullptr){
			temp = new char[strlen(_komentar) + strlen(komentar) + 2];
			strcpy_s(temp, strlen(_komentar) + strlen(komentar) + 2, _komentar);
			strcat_s(temp, strlen(_komentar) + strlen(komentar) + 2, ";");
			strcat_s(temp, strlen(_komentar) + strlen(komentar) + 2, komentar);
			_komentar = temp;
			temp = nullptr;
		}
		else
		{
			temp = new char[strlen(komentar) + 1];
			strcpy_s(temp, strlen(komentar) + 1, komentar);
			_komentar = temp;
			temp = nullptr;
		}

	}
	void Ispis(){
		cout << VrstaObavezeText[_vrstaObaveze] << " " << _ocjena;
		_datumIzvrsenja->Ispis();
		cout << endl;
	}
	void Dealociraj(){
		_datumIzvrsenja->Dealociraj();
		delete _datumIzvrsenja;
		delete[] _komentar;
	}
};
struct PolozeniPredmet{
	Datum * _datumPolaganja;
	//u okviru jednog predmeta studenti mogu imati najviše 10 obaveza 
	ObavezeNaPredmetu _listaIzvrsenihObaveza[10];
	int _trenutnoIzvrsenihObaveza = 0;
	int * _konacnaOcjena;

	void Ispis(){
		_datumPolaganja->Ispis();
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			_listaIzvrsenihObaveza[i].Ispis();
	}

	void Unos(Datum * d, ObavezeNaPredmetu obaveza){
		//Na osnovu vrijednosti primljenih parametara izvršiti inicijalizaciju odgovaraju?ih
		//atributa 
		_datumPolaganja = new Datum;
		_datumPolaganja = d;
		if (_trenutnoIzvrsenihObaveza <= 10){
			_listaIzvrsenihObaveza[_trenutnoIzvrsenihObaveza] = obaveza;
			_trenutnoIzvrsenihObaveza++;
		}
		_konacnaOcjena = 0;

	} 
	bool DodajKomentarIzvrsenojObavezi(ObavezeNaPredmetu * obaveza, char * komentar){
		/*Funkcija ima zadatak da na osnovu primljenog parametra obaveza prona?e izvršenu obavezu, te joj doda komentar koji je tako?er
		proslije?en kao parametar. Voditi ra?una o tome da jedna obaveza može imati ve?i broj komentara. U slu?aju da tražena obaveza
		ne postoji, funkcija vra?a false. */
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (obaveza->_vrstaObaveze == _listaIzvrsenihObaveza[i]._vrstaObaveze)
			{
				_listaIzvrsenihObaveza[i].DodajKomentar(komentar);
				return true;
			}
		}
		return false;
	}
	int FormirajKonacnuOcjenu(){
		/*Funkcija je zadužena za formiranje kona?ne ocjene
		na položenom predmetu. Za formiranje kona?ne ocjene predmet treba imati najmanje tri izvršene obaveze od kojih jedna mora biti
		seminarski rad ukoliko je student integralno položio ispit. U slu?aju da komentar na obavezi sadrži rije? varanje, ocjena na toj obavezi
		se umanjuje za 1. Ukoliko svi pomenuti uslovi nisu izvršeni, kona?na ocjena treba biti postavljena na vrijednost 5. Funkcija vra?a
		vrijednost atributa _konacnaOcjena*/
		bool imaPrvi = false, imaDrugi = false;
		bool imaVaranje1 = false, imaVaranje2 = false;
		int prvi, drugi;
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni1 && _listaIzvrsenihObaveza[i]._ocjena > 5){
				imaPrvi = true;
				if (_listaIzvrsenihObaveza[i]._komentar != nullptr)
					if (strstr(_listaIzvrsenihObaveza[i]._komentar, "varanje") != NULL){
					_listaIzvrsenihObaveza[i]._ocjena--;
					imaVaranje1 = true;
					prvi = i;
					}

			}
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Parcijalni2 && _listaIzvrsenihObaveza[i]._ocjena > 5){
				imaDrugi = true;
				if (_listaIzvrsenihObaveza[i]._komentar != nullptr)
					if (strstr(_listaIzvrsenihObaveza[i]._komentar, "varanje") != NULL){
					_listaIzvrsenihObaveza[i]._ocjena--;
					imaVaranje2 = true;
					drugi = i;
					}
			}
		}

		int ocjene = 0;
		int brojacvalidnih = 0;
		if (imaPrvi&&imaDrugi&&_trenutnoIzvrsenihObaveza >= 3){
			if (imaVaranje1 == true || imaVaranje2 == true){
				if (_listaIzvrsenihObaveza[prvi]._ocjena == 5 || _listaIzvrsenihObaveza[drugi]._ocjena == 5)
					cout << endl;
			}

			else{
				for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
				{
					if (_listaIzvrsenihObaveza[i]._ocjena > 5){
						ocjene += _listaIzvrsenihObaveza[i]._ocjena;
						brojacvalidnih++;
					}
				}
				ocjene /= (float)brojacvalidnih;
				_konacnaOcjena = new int;
				*_konacnaOcjena = ocjene;
				return *_konacnaOcjena;
			}
		}
		bool imaIntegralni = false, imaSeminarski = false;
		int treci = 0;
		for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
		{
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Integralni &&_listaIzvrsenihObaveza[i]._ocjena > 5){
				imaIntegralni = true;
				if (_listaIzvrsenihObaveza[i]._komentar != nullptr)
					if (strstr(_listaIzvrsenihObaveza[i]._komentar, "varanje") != NULL){
					_listaIzvrsenihObaveza[i]._ocjena--;
					treci = i;
					}
			}
			if (_listaIzvrsenihObaveza[i]._vrstaObaveze == Seminarski &&_listaIzvrsenihObaveza[i]._ocjena > 5)
				imaSeminarski = true;
		}
		if (imaIntegralni && imaSeminarski){
			for (int i = 0; i < _trenutnoIzvrsenihObaveza; i++)
			{
				if (_listaIzvrsenihObaveza[i]._ocjena > 5){
					ocjene += _listaIzvrsenihObaveza[i]._ocjena;
					brojacvalidnih++;
				}
			}
			ocjene /= (float)brojacvalidnih;
			_konacnaOcjena = new int;
			*_konacnaOcjena = ocjene;
			return *_konacnaOcjena;
		}
		_konacnaOcjena = new int;
		*_konacnaOcjena = 5;
		return *_konacnaOcjena;
	}
};
//int Pretraga(PolozeniPredmet * p, int max){
//	/*Funkcija ima zadatak da ispiše informacije o svim položenim predmetima kod kojih je student ispit položio putem parcijalnih ispita,
//	te tom prilikom ostvario prosje?nu ocjenu ve?u od 8,5. Da bi informacije o položenom predmetu bile ispisane moraju biti ispunjeni svi
//	uslovi neophodni za formiranje kona?ne ocjene. Nakon ispisa, funkcija vra?a broj položenih predmeta koji su zadovoljili navedene kriterije.*/
//} 
void main(){
	//izbjegavajte korištenje vlastitog imena i prezimena. 
	//provjeriti validnost izvršenja svih dostupnih funkcionalnosti 

	Datum d1, d2, d3;
	d1.Unos(12, 6, 1992);
	d2.Unos(7, 7, 1999);
	d3.Unos(8, 7, 2016);
	d1.Ispis();
	d2.Ispis();
	d3.Ispis();

	ObavezeNaPredmetu o1, o2, o3;
	o1.Unos(Seminarski, &d1, 7);
	o2.Unos(Parcijalni1, &d2, 6);
	o3.Unos(Parcijalni2, &d3, 8);
	o1.Ispis();
	o2.Ispis();
	o3.Ispis();

	PolozeniPredmet pr1, pr2, pr3;
	pr1.Unos(&d1, o1);
	pr1.Unos(&d2, o2);
	pr1.Unos(&d3, o3);
	pr2.Unos(&d2, o2);
	pr3.Unos(&d3, o3);
	if (pr1.DodajKomentarIzvrsenojObavezi(&o1, "testiranje komentara1"))
		cout << "Komentar uspjesno dodan..." << endl;
	if (pr1.DodajKomentarIzvrsenojObavezi(&o2, "testiranje komentara4"))
		cout << "Komentar uspjesno dodan..." << endl;
	if (pr1.DodajKomentarIzvrsenojObavezi(&o3, "testiranje komentara5"))
		cout << "Komentar uspjesno dodan..." << endl;
	if(pr2.DodajKomentarIzvrsenojObavezi(&o1, "testiranje komentara2"))
		cout << "Komentar uspjesno dodan..." << endl;
	if(pr3.DodajKomentarIzvrsenojObavezi(&o3, "testiranje komentara3"))
		cout << "Komentar uspjesno dodan..." << endl;
	cout << "Konacna ocjena za pr1 je: "<<pr1.FormirajKonacnuOcjenu() << endl;
	cout << "Konacna ocjena za pr2 je: " << pr2.FormirajKonacnuOcjenu() << endl;
	cout << "Konacna ocjena za pr3 je: " << pr3.FormirajKonacnuOcjenu() << endl;



	//pr1.Ispis();



	d1.Dealociraj();
	d2.Dealociraj();
	o1.Dealociraj();
	o2.Dealociraj();
	o3.Dealociraj();

	system("pause");
}

_________________________________________________________

#include <iostream>
#include <functional>
using namespace std;

const int max_size = 30;
struct Kolekcija
{
	int podaci[max_size];
	int brojac = 0;
};

void kDodaj(Kolekcija& k, int newV)
{
	//dodaj newV u podaci na poziciju brojac
	//uvecati brojac
	k.podaci[k.brojac] = newV;
	k.brojac++;
}

void kGenerisiPodatke(Kolekcija& k)
{
	for (int i = 0; i < max_size / 2; i++)
	{
		int newV = rand() - rand();
		//newV dodati u kolekciju k
		kDodaj(k,newV);
	}
}

void kPrinter(Kolekcija& k, char* opis)
{
	cout << opis << endl;
	for (int i = 0; i < k.brojac; i++)
	{
		int& p = k.podaci[i];
		cout << i << ": " << p << endl;
	}
}



Kolekcija kFilter(Kolekcija& k, function<bool(int&)> f)
{
	Kolekcija newK;
	//iz kolekcije k u kolekciju newK kopirati elemente koji zadovoljavaju uslov f
	for (int i = 0; i < k.brojac; i++)
	{
		int &x = k.podaci[i];
		if (f(x))
			kDodaj(newK,x);
	}
	return newK;
}
bool filter(int & x){
	return (x > 0);
}
bool filterParnih(int & x){
	return (x % 2 == 0);
}

void kForEach(Kolekcija& k, function<void(int&)> f)
{
	//za svaki element iz kolekcije k izvrsi zadatak f
	for (int i = 0; i < k.brojac; i++)
	{
		int & x = k.podaci[i];
		f(x);
	}
}
void uvecaj(int& x){
	x++;
}

void rotiraj(int& m, int& n)
{
	int t = m;
	m = n;
	n = t;
}

void kSortiraj(Kolekcija& k, function<bool(int&, int&)> t)
{
	int n = k.brojac;
	//granica izmedu nesortiranog i sortiranog dijela niza
	for (int granica = n - 1; granica >= 0; granica--)
	{
		for (int j = 0; j < granica; j++)
		{
			int& a = k.podaci[j];
			int& b = k.podaci[j + 1];
			if (t(a, b))
				rotiraj(a, b);
		}
	}
}
bool sort(int& a, int& b){
	return (a > b);
}


void main()
{
	//a. Instaciraj Kolekciju k1  i generiši podatke
	Kolekcija k1;
	kGenerisiPodatke(k1);

	//b. Iz kolekcije k1 filtiraj parne brojeve u kolekciju k2
	Kolekcija k2 = kFilter(k1, filterParnih);
	//c. Iz kolekcije k2 filtiraj pozitivne brojeve u kolekciju k3
	Kolekcija k3 = kFilter(k2, filter);
	//d. Ispisati na ekran sve tri kolekcije

	//f. koristeci kForEach uvecati sve elemente kolekcije k2
	kForEach(k2, uvecaj);

	//g. koristeci kForEach kopirati sve elemente kolekcije k3 u novu kolekciju 
	Kolekcija k4;
	kForEach(k3, [&k4](int& x){ kDodaj(k4, x); });

	//h. Sortirati sve tri kolekcije i ispisati na ekran
	kSortiraj(k1, sort);

	kPrinter(k1, "Svi brojevi");
	kPrinter(k2, "Parni brojevi");
	kPrinter(k3, "Parni pozitivni bojevi");

	system("pause");
}
_______________________________________________________________________

#include <iostream>
using namespace std;  

char crt[] = "\n--------------------------------------------------\n";
void OslobodiMemoriju(char * &tekst)  {  
	//dealocirati tekst 
	delete[] tekst;
	tekst = NULL;
	cout << "Memorija oslobodjena" << endl;
} 
void Informacije(char * tekst)  {
	int razmaci = 0, brojevi = 0, velika = 0, mala = 0, interpunkcijski = 0;       
	cout << crt << "\t\t::INFO::" << crt; 
	cout << crt << "Tekst: " << tekst << crt; 
	cout << "Niz ima " << strlen(tekst) << " karaktera." << crt;
	cout << "Razmaka: \t\t\t" << razmaci << endl;
	cout << "Brojeva: \t\t\t" << brojevi << endl; 
	cout << "Velikih slova: \t\t\t" << velika << endl;
	cout << "Malih slova: \t\t\t" << mala << endl;  cout << "Interpunkcijskih znakova: \t" << interpunkcijski;
	cout << crt << "Info: Informacije prikazane...." << crt;
}   
void DodajTekst(char * &tekst)  { 
	//stari tekst + razmak + novi tekst
	cout << "Unesite dodatni tekst: " << endl;
	char* temp = new char[100];
	cin.getline(temp, 100);
	char * noviTekst = new char[strlen(tekst) + strlen(temp) + 2];
	strcpy_s(noviTekst, strlen(tekst) + strlen(temp) + 2,tekst);
	strcat_s(noviTekst, strlen(tekst) + strlen(temp) + 2, " ");
	strcpy_s(noviTekst, strlen(tekst) + strlen(temp) + 2, temp);
	OslobodiMemoriju(tekst);
	tekst = noviTekst;
}  
void Pretraga(char * tekst)  { 
	cout << "Unestte rijec i vracam vam da li ona postoji u tekstu" << endl;
	char rijec[20];
	cin.getline(rijec, 20);
	char* pok = NULL;
	pok = strstr(tekst, rijec);
	if (pok != NULL)
		cout << "Trazena rijec postoji u tekstu" << endl;
	cout << "Da li zelite da prikazemo ostatak teksta(D/N)" << endl;
	char slovo;
	cin >> slovo;
	if (toupper(slovo) == 'D')
		cout << pok << endl;
}  
void UnosTeksta(char *& tekst){ 
	if (tekst != NULL)
		OslobodiMemoriju(tekst);
	tekst = new char[100];
	cout << "zavrsavanje teksta sa '#'" << endl;
	cin.getline(tekst, 100,'#');
}  
int PrikaziMeni() {
	int izbor = 1; 
	do { 
		cout << crt << "\t\t::MENI::" << crt;
		cout << "1. Unos novog teksta" << endl;
		cout << "2. Dodavanje teksta" << endl;  
		cout << "3. Informacije o tekstu" << endl; 
		cout << "4. Pretraga" << endl; 
		cout << "5. Zatvori editor" << endl;
		cout << "Unesite vas izbor: "; 
		cin >> izbor;
		cin.ignore();
		system("cls");
	}
	while (izbor < 1 || izbor>5);
	return izbor;
}
void main() {
	int izbor = 0;
	char * tekst = NULL; 
	do {
		cout << crt << "\t\t::TEKST EDITOR::";
		izbor = PrikaziMeni();
		switch (izbor) {
		case 1:    UnosTeksta(tekst); break;
		case 2:    DodajTekst(tekst); break; 
		case 3:    Informacije(tekst); break; 
		case 4:  Pretraga(tekst); break; 
		} 
		system("pause>0");  
		system("cls");
	} while (izbor != 5); 
	if (tekst != NULL) 
		OslobodiMemoriju(tekst);
	cout << crt;
}


_____________________________________________________________________________


#include <iostream> 
using namespace std; 

enum Opstina{ Opstina1, Opstina2, Opstina3, Opstina4 };
char * OpstineChar[] = { "Opstina1", "Opstina2", "Opstina3", "Opstina4" };

enum Kandidati{ Kandidat1, Kandidat2, Kandidat3, Kandidat4 };
char * KandidatiChar[] = { "Kandidat1", "Kandidat2", "Kandidat3", "Kandidat4" };

struct Datum{ 
	int _dan, _mjesec, _godina;

	void Unos(int d, int m, int g){
		_dan = d; 
		_mjesec = m;
		_godina = g;
	} 
	void Ispis(){ 
		cout << _dan << "/" << _mjesec << "/" << _godina << endl;
	}
};
bool mladjiOd18(Datum rodjenje, Datum danasnji){
	if (danasnji._godina - rodjenje._godina < 18)
		return true;
	if (danasnji._godina - rodjenje._godina == 18){
		if (danasnji._mjesec > rodjenje._godina)
			return true;
		if (danasnji._mjesec == rodjenje._godina){
			if (danasnji._dan > rodjenje._dan)
				return true;
		}
	}
	return false;
}
struct Osoba{
	Datum _datumRodjenja;
	char * _imePrezime;
	char _JMBG[14]; 
	Opstina _Prebivaliste; 

	void unos(Datum d, char * ip, char jmbg[], Opstina p){
		_datumRodjenja = d;
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime, strlen(ip) + 1, ip);
		strcpy_s(_JMBG,14, jmbg);
		_Prebivaliste = p; 
	} 
	void Dealociraj(){ 
		delete[] _imePrezime;
		_imePrezime = nullptr;
	} 
	void Info(){ 
		_datumRodjenja.Ispis();
		cout << _imePrezime << " " << _JMBG << " " << OpstineChar[_Prebivaliste] << endl;
	}
}; 
struct Glas{ 
	Osoba _glasac;  
	Kandidati _glasZa; 
	void Unos(Osoba o, Kandidati k){
		_glasac.unos(o._datumRodjenja, o._imePrezime, o._JMBG, o._Prebivaliste); 
		_glasZa = k;
	}
	void Ispis(){
		_glasac.Info();
		cout << KandidatiChar[_glasZa] << endl;
	} 
	void Dealociraj(){ 
		_glasac.Dealociraj();
		//_glasZa.Dealociraj();
	} 
};

struct Izbori2014{
	Opstina _glasackoMjesto;
	Glas * _glasovi; 
	int _brojGlasaca;
	void Unos(Opstina * o){
		/*na osnovu vrijednosti primljenih parametara, inicijalizovati vrijednosti atributa strukture.*/
		_glasackoMjesto = *o;
		_glasovi = nullptr;
		_brojGlasaca = 0;
	} 
	bool AddGlas(Glas * g){
		/*funkcija treba da omoguci dodavanje informacija o novom glasu   tom prilikom
	 - onemoguciti da ista osoba glasa vise puta  
	 - onemoguciti glasanje osobama mladjim od 18 godina (uzeti u obzir samo mjesec i godinu rodjenja) 
	 - onemoguciti glasanje osobama iz drugih opstina  
	 - u zavisnosti od uspjesnosti operacije funkcija vraca true ili false   */
		Datum danasnji;
		danasnji.Unos(11, 9, 2017);

		if (mladjiOd18(g->_glasac._datumRodjenja, danasnji))
			return false;
		if (_glasackoMjesto != g->_glasac._Prebivaliste)
			return false;

		if (_glasovi != nullptr){
			for (int i = 0; i < _brojGlasaca; i++)
			{
				if (strstr(_glasovi[i]._glasac._imePrezime, g->_glasac._imePrezime) != NULL)
					return false;
			}
		}
			Glas * temp = new Glas[_brojGlasaca + 1];
			for (int i = 0; i < _brojGlasaca; i++)
				temp[i].Unos(_glasovi[i]._glasac, _glasovi[i]._glasZa);
			if (_glasovi!=nullptr)
				delete[] _glasovi;
			_glasovi = nullptr;
			temp[_brojGlasaca].Unos(g->_glasac, g->_glasZa);
			_glasovi = temp;
			temp = nullptr;
			_brojGlasaca++;
			return true;
	}
	void Dealociraj(){ 
		/*definisati funkciju vodeci racuna o oslobadjanju svih resursa koji su alocirani za potrebe objekta tipa Izbori2014*/ 
		delete[] _glasovi;
	}
};

struct PobjednickaOpstina{
	Opstina op;
	int brojac = 0;
};

struct KandidatBrojGlasova {
	Kandidati Kandidat;
	int brojGlasova;
	float procenat;

	void Unos(Kandidati k){
		Kandidat = k;
		brojGlasova = 0;
		procenat = 0;
	}
	void Ispis(){
		cout << KandidatiChar[Kandidat] << " ";
		cout << "Broj glasova: " << brojGlasova << endl << " ";
		cout << "procenat osvojenih glasova: " << procenat << "%" << endl;
	}
};

Opstina ProglasiPobjednika(Izbori2014 * izbornaMjesta, int brojIzbornihMjesta){ 
	/*  u zavisnosti od postignutog uspjeha,  - funkcija treba ispisati listu kandidata sortiranu opadajucim redoslijedom,
	a uz svakog kandidata je potrebno ispisati i osvojeni procenat glasova 
	- funkcija vraca opstinu u kojoj je pobjednicki kandidat ostvario najveci broj glasova 
	- ukoliko je pobjednicki kandidat ostvario podjednak broj glasova u vise opstina, funkcija vraca prvu koja se nalazi u nizu na koji 
	pokazuje pokazivac izbornaMjesta  */

	KandidatBrojGlasova lista[4];
	int ukupanBrojGlasova = 0;
	lista[0].Unos(Kandidat1);
	lista[1].Unos(Kandidat2);
	lista[2].Unos(Kandidat3);
	lista[3].Unos(Kandidat4);

	for (int i = 0; i < brojIzbornihMjesta; i++)
	{
		for (int j = 0; j <izbornaMjesta[i]._brojGlasaca; j++)
		{
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat1)
				lista[0].brojGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat2)
				lista[1].brojGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat3)
				lista[2].brojGlasova++;
			if (izbornaMjesta[i]._glasovi[j]._glasZa == Kandidat4)
				lista[3].brojGlasova++;
			ukupanBrojGlasova++;
		}
	}
	for (int i = 0; i < 4; i++)
	{
		lista[i].procenat = lista[i].brojGlasova / (float)ukupanBrojGlasova * 100;
	}
	KandidatBrojGlasova temp;
	bool sortirano;
	do
	{
		sortirano = false;
		for (int i = 0; i <3; i++)
		{
			if (lista[i].brojGlasova > lista[i + 1].brojGlasova){
				temp = lista[i];
				lista[i] = lista[i + 1];
				lista[i + 1] = temp;
				sortirano = true;
			}

		}
	} while (sortirano);

	for (int i = 0; i < 4; i++)
		lista[i].Ispis();

	PobjednickaOpstina niz[4];
	niz[0].op = Opstina1;
	niz[1].op = Opstina2;
	niz[2].op = Opstina3;
	niz[3].op = Opstina4;

	for (int i = 0; i < brojIzbornihMjesta; i++)
	{
		for (int j = 0; j <izbornaMjesta[i]._brojGlasaca; j++)
		{
			if (izbornaMjesta[i]._glasovi[j]._glasZa == lista[3].Kandidat){
				if (izbornaMjesta[i]._glasovi[j]._glasac._Prebivaliste == Opstina1)
					niz[0].brojac++;
				if (izbornaMjesta[i]._glasovi[j]._glasac._Prebivaliste == Opstina2)
					niz[1].brojac++;
				if (izbornaMjesta[i]._glasovi[j]._glasac._Prebivaliste == Opstina3)
					niz[2].brojac++;
				if (izbornaMjesta[i]._glasovi[j]._glasac._Prebivaliste == Opstina4)
					niz[4].brojac++;
			}
				
		}

		PobjednickaOpstina temp1;
		do
		{
			sortirano = false;
			for (int i = 0; i <3; i++)
			{
				if (niz[i].brojac> niz[i + 1].brojac){
					temp1 = niz[i];
					niz[i] = niz[i + 1];
					niz[i + 1] = temp1;
					sortirano = true;
				}

			}
		} while (sortirano);
	}

	return niz[3].op;
} 
int main(){
	
	Datum d1, d2, d3, d4;
	d1.Unos(3, 3, 1975);
	d2.Unos(3, 3, 1980);
	d3.Unos(3, 3, 2015);
	d4.Unos(3, 3, 1999);

	Osoba o1, o2, o3, o4, o5,o6,o7;
	o1.unos(d1, "Zajko Zeba", "1111111111111", Opstina1);
	o2.unos(d1, "Goran Zakaric", "2222222222222", Opstina1);
	o3.unos(d2, "Asim Zec", "3333333333333", Opstina1);
	o4.unos(d3, "Srdjan Stanic", "4444444444444", Opstina1);
	o5.unos(d4, "Ugljesa Radinovic", "5555555555555", Opstina2);
	o6.unos(d1, "Admir Adzem", "6666666666666", Opstina1);
	o7.unos(d1, "Sasa Kajkut", "7777777777777", Opstina1);

	Glas g1, g2, g3, g4, g5, g6,g7,g8;
	g1.Unos(o1, Kandidat1);
	g2.Unos(o1, Kandidat1);
	g3.Unos(o2, Kandidat1);
	g4.Unos(o3, Kandidat2);
	g5.Unos(o4, Kandidat2);
	g6.Unos(o5, Kandidat3);
	g7.Unos(o6, Kandidat1);
	g8.Unos(o7, Kandidat2);

	Izbori2014 i1;
	Opstina * OOpstina;
	OOpstina = new Opstina;
	*OOpstina = Opstina1;
	i1.Unos(OOpstina);
	if (i1.AddGlas(&g1))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g2))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g3))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g4))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g5))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g6))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g7))
		cout << "Glas uspjesno dodan" << endl;
	if (i1.AddGlas(&g8))
		cout << "Glas uspjesno dodan" << endl;

	Opstina op=ProglasiPobjednika(&i1, 1);
	cout << "Pobjednicka opstina je: " << OpstineChar[op] << endl;

	system("pause");
	return 0;
}

_________________________________________________________________

#include<iostream>
using namespace std;
#include<memory>
/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NEÆE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI ÆETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/

//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char *crt = "\n-------------------------------------------\n";

enum eNacinStudiranja { REDOVAN, DL };
enum eRazred { PRVI = 1, DRUGI, TRECI, CETVRTI };

struct Datum {
	int _dan, _mjesec, _godina;
	void Unos(int d, int m, int g) {
		_dan = d; 
		_mjesec = m;
		_godina = g;
	}
	void Ispis() { 
		cout << _dan << "/" << _mjesec << "/" << _godina << endl; 
	}
	bool DaLiJeManji(Datum rokZaPrijavu){
		if (_godina < rokZaPrijavu._godina)
			return true;
		if (_godina == rokZaPrijavu._godina && _mjesec < rokZaPrijavu._mjesec)
			return true;
		if (_godina == rokZaPrijavu._godina && _mjesec == rokZaPrijavu._mjesec && _dan < rokZaPrijavu._dan)
			return true;;
		return false;
	}
};

const Datum rokZaPrijavu = { 5, 7, 2017 };

char * errVecDodan = "Istoimeni predmet se moze dodati najvise dva puta!";
char * errProsaoRok = "Zao nam je. Rok za prijavu je vec prosao!";
char * uspjesnoDodan = "Predmet uspjesno dodan!";

struct Predmet {
	char * _naziv;
	int * _ocjena;
	Datum _datumUnosa;
	void Unos(char * naziv, int ocjena, Datum datumUnosa) {
		int vel = strlen(naziv) + 1;
		_naziv = new char[vel];
		strcpy_s(_naziv, vel, naziv);
		_ocjena = new int(ocjena);
		_datumUnosa.Unos(datumUnosa._dan, datumUnosa._mjesec, datumUnosa._godina);
	}
	void Dealociraj() {
		delete[] _naziv; _naziv = nullptr;
		delete _ocjena; _ocjena = nullptr;
	}

	void Ispis() {
		cout << _naziv << " (" << *_ocjena << ") "; _datumUnosa.Ispis();
	}
	void PromijeniOcjenu(int ocjena) { *_ocjena = ocjena; }
};

struct Uspjeh {
	eRazred  _razred;
	bool _najboljiUcenik; // ako je kandidat u tom razredu proglasen najboljim ucenikom
	shared_ptr<Predmet> * _predmeti;
	int _brojPredmeta;
	void Unos(eRazred razred, bool najboljiUcenik) {
		_razred = razred;
		_najboljiUcenik = najboljiUcenik;
		_brojPredmeta = 0;
	}

	void UnosPredmeta(Predmet p){
		shared_ptr<Predmet> *temp = new shared_ptr<Predmet>[_brojPredmeta + 1];
		for (int i = 0; i < _brojPredmeta; i++){
			temp[i] = make_shared<Predmet>();
			temp[i]->Unos(_predmeti[i]->_naziv, *_predmeti[i]->_ocjena, _predmeti[i]->_datumUnosa);
		}
		for (int i = 0; i < _brojPredmeta; i++)
			_predmeti[i]->Dealociraj();
		temp[_brojPredmeta] = make_shared<Predmet>();
		temp[_brojPredmeta]->Unos(p._naziv, *p._ocjena, p._datumUnosa);
		_predmeti = temp;
		temp = nullptr;
		_brojPredmeta++;
	}
	void Dealociraj() {

	}
	void Ispis() {
		cout << crt << "Razred -> " << _razred << "Najbolji -> " << _najboljiUcenik << crt;
		for (size_t i = 0; i < _brojPredmeta; i++)
			_predmeti[i]->Ispis();
	}
};

struct Kandidat {
	eNacinStudiranja _nacinStudiranja;
	char * _imePrezime;
	Uspjeh * _uspjeh[4];

	void Unos(eNacinStudiranja nacinStudiranja, char * imePrezime) {
		int vel = strlen(imePrezime) + 1;
		_imePrezime = new char[vel];
		strcpy_s(_imePrezime, vel, imePrezime);
		_nacinStudiranja = nacinStudiranja;
		for (size_t i = 0; i < 4; i++)
			_uspjeh[i] = nullptr;
	}

	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
		for (size_t i = 0; i < 4; i++){
			_uspjeh[i]->Dealociraj();
			delete _uspjeh[i];
		}
	}
	void Ispis() {
		cout << crt << _imePrezime << " " << _nacinStudiranja;
		for (size_t i = 0; i < 4; i++){
			if (_uspjeh[i] != nullptr)
				_uspjeh[i]->Ispis();
		}
	}

	bool DodajPredmet(eRazred e,Predmet p){
		/*
		uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda. prilikom dodavanja onemoguciti:
		- istoimeni predmet se moze dodati samo dva puta, bez obzira sto se dodaje na razlicitim godinama,
		- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
		razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda 
		za I razred i sl.). Funkcija vraca neku od predefinisanih poruka u zavisnosti od (ne)uspjesnost izvrsenja
		*/
		int brojacPredmeta = 0;
		for (int i = 0; i < 4; i++)
		{
			if (_uspjeh[i] != nullptr){
				Uspjeh *razred = _uspjeh[i];
				for (int j = 0;  j < razred->_brojPredmeta;  j++)
				{
					if (strcmp(_uspjeh[i]->_predmeti[j]->_naziv, p._naziv) == 0)
						brojacPredmeta++;
				}
			}
		}
		if (brojacPredmeta >= 2)
			return false;
		for (int i = 0; i < 4; i++)
		{
			if (_uspjeh[i] != nullptr){
				if (_uspjeh[i]->_razred == e){
					Uspjeh *razred = _uspjeh[i];
					for (int j = 0; j < razred->_brojPredmeta; j++)
					{
						if (strstr(razred->_predmeti[j]->_naziv, p._naziv) != NULL)
							return false;
					}
				}
			}
		}
		if (!p._datumUnosa.DaLiJeManji(rokZaPrijavu))
			return false;
		int raz =(int)e - 1;
		if (_uspjeh[raz] == nullptr){
			_uspjeh[raz] = new Uspjeh;
			_uspjeh[raz]->Unos(e, true);
		}
		_uspjeh[raz]->UnosPredmeta(p);

		return true;

	}
};

void main(){
	Datum datum19062017, datum20062017, datum30062017, datum05072017;
	datum19062017.Unos(19, 6, 2017);
	datum20062017.Unos(20, 6, 2017);
	datum30062017.Unos(30, 6, 2017);
	datum05072017.Unos(5, 7, 2017);

	Predmet Matematika, Fizika, Hemija, Engleski;
	//2 - ocjena na predmetu; datum - datum evidentiranja uspjeha na predmetu jer postoji krajnji rok za evidentiranje
	Matematika.Unos("Matematika", 2, datum19062017);
	Fizika.Unos("Fizika", 5, datum20062017);
	Hemija.Unos("Hemija", 2, datum20062017);
	Engleski.Unos("Engleski", 5, datum05072017);

	int brojKandidata = 2;

	Kandidat * prijave2017 = new Kandidat[brojKandidata];
	prijave2017[0].Unos(DL, "Jasmin Azemovic");
	prijave2017[1].Unos(REDOVAN, "Indira Hamulic");
	/*
	uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda. prilikom dodavanja onemoguciti:
	- istoimeni predmet se moze dodati samo dva puta, bez obzira sto se dodaje na razlicitim godinama,
	- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
	razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda za I razred i sl.). Funkcija vraca neku od predefinisanih poruka u zavisnosti od (ne)uspjesnost izvrsenja
	*/
	if (prijave2017[0].DodajPredmet(DRUGI, Engleski)) //ne bi trebao dodati jer je prosao postavljeni rok za dodavanje predmeta
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(DRUGI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Fizika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;

	Matematika.PromijeniOcjenu(5);
	Hemija.PromijeniOcjenu(3);

	if (prijave2017[1].DodajPredmet(PRVI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(DRUGI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(TRECI, Matematika))//ne bi trebalo ponovo dodati Matematiku!
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(TRECI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(DRUGI, Engleski))
		cout << "Predmet uspjesno dodan!" << crt;

	/*
	koristeci Lambda izraz kreirati funkciju koja ce vratiti uspjeh kandidata koji je ostvario najveci prosjek (na nivou razreda, a ne ukupni prosjek).
	funkcija prima parametre tipa eNacinStudiranja (pretrazuje samo kandidate za Redovan ili DL nacin studiranja) i bool kojim se omogucava pretraga
	samo onih razreda na kojim su kandidati bili najbolji ucenici (ako se funkciji proslijedi vrijednost true, ona ce uzeti u obzir samo one razrede
	kada su kandidati oznaceni kao najbolji). ukoliko vise kandidata ima isti prosjek funkcija vraca uspjeh (najboljeg razreda) prvog pronadjenog 
	kandidata
	*/
	auto najboljiUspjeh = [&prijave2017,&brojKandidata](eNacinStudiranja e, bool najboljiUcenik){
		Uspjeh* rezultat = nullptr;
		float najveciProsjek = 0;
		float suma;
		for (int i = 0; i <brojKandidata ; i++)
		{
			if (prijave2017[i]._nacinStudiranja == e){
				for (int j = 0; j < 4; j++)
				{
					if (prijave2017[i]._uspjeh[j]!=nullptr && prijave2017[i]._uspjeh[j]->_najboljiUcenik == najboljiUcenik){
						Uspjeh* razred = prijave2017[i]._uspjeh[j];
						suma = 0;
						for (int k = 0; k < razred->_brojPredmeta; k++)
						{
							suma += *razred->_predmeti[k]->_ocjena;
						}
						suma /= razred->_brojPredmeta;
						if (suma > najveciProsjek){
							najveciProsjek = suma;
							rezultat = razred;
						}
					}
				}
			}
		}
		return rezultat;
	};
	Uspjeh * najbolji = najboljiUspjeh(DL, true);
	najbolji->Ispis();

	/*
	napisati rekurzivnu funkciju koja ce vratiti pokazivac na kandidata sa najvecim prosjekom u razredu koji je proslijedjen kao parametar.
	ukoliko je vise kandidata ostvarilo isti prosjek, funkcija treba da vrati posljednje pronadjenog kandidata. u slucaju da niti jedan
	kandidat nije evidentirao uspjeh u trazenom razredu, funkcija vraca nullptr. u nastavku je prikazan primjer poziva rekurzivne funkcije,
	a ostale parametre dodajte po potrebi. */
	//Kandidat * kandidatSaNajboljimProsjekom = rekNajboljiProsjek(prijave2017, brojKandidata, DRUGI);

	for (size_t i = 0; i < brojKandidata; i++)
	{
		prijave2017[i].Ispis();
		prijave2017[i].Dealociraj();
	}
	system("pause>0");
}

________________________________________________________________________

#include<iostream>
using namespace std;
#include<memory>
/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NEÆE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI ÆETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/

//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char *crt = "\n-------------------------------------------\n";

enum eNacinStudiranja { REDOVAN, DL };
enum eRazred { PRVI = 1, DRUGI, TRECI, CETVRTI };

struct Datum {
	int _dan, _mjesec, _godina;
	void Unos(int d, int m, int g) {
		_dan = d;
		_mjesec = m;
		_godina = g;
	}
	void Ispis() {
		cout << _dan << "/" << _mjesec << "/" << _godina << endl;
	}
	bool DaLiJeManji(Datum rokZaPrijavu){
		if (_godina < rokZaPrijavu._godina)
			return true;
		if (_godina == rokZaPrijavu._godina && _mjesec < rokZaPrijavu._mjesec)
			return true;
		if (_godina == rokZaPrijavu._godina && _mjesec == rokZaPrijavu._mjesec && _dan < rokZaPrijavu._dan)
			return true;;
		return false;
	}
};

const Datum rokZaPrijavu = { 5, 7, 2017 };

char * errVecDodan = "Istoimeni predmet se moze dodati najvise dva puta!";
char * errProsaoRok = "Zao nam je. Rok za prijavu je vec prosao!";
char * uspjesnoDodan = "Predmet uspjesno dodan!";

struct Predmet {
	char * _naziv;
	int * _ocjena;
	Datum _datumUnosa;
	void Unos(char * naziv, int ocjena, Datum datumUnosa) {
		int vel = strlen(naziv) + 1;
		_naziv = new char[vel];
		strcpy_s(_naziv, vel, naziv);
		_ocjena = new int(ocjena);
		_datumUnosa.Unos(datumUnosa._dan, datumUnosa._mjesec, datumUnosa._godina);
	}
	void Dealociraj() {
		delete[] _naziv; _naziv = nullptr;
		delete _ocjena; _ocjena = nullptr;
	}

	void Ispis() {
		cout << _naziv << " (" << *_ocjena << ") "; _datumUnosa.Ispis();
	}
	void PromijeniOcjenu(int ocjena) { *_ocjena = ocjena; }
};

struct Uspjeh {
	eRazred  _razred;
	bool _najboljiUcenik; // ako je kandidat u tom razredu proglasen najboljim ucenikom
	shared_ptr<Predmet> * _predmeti;
	int _brojPredmeta;
	void Unos(eRazred razred, bool najboljiUcenik) {
		_razred = razred;
		_najboljiUcenik = najboljiUcenik;
		_brojPredmeta = 0;
	}

	void UnosPredmeta(Predmet p){
		shared_ptr<Predmet> *temp = new shared_ptr<Predmet>[_brojPredmeta + 1];
		for (int i = 0; i < _brojPredmeta; i++){
			temp[i] = make_shared<Predmet>();
			temp[i]->Unos(_predmeti[i]->_naziv, *_predmeti[i]->_ocjena, _predmeti[i]->_datumUnosa);
		}
		for (int i = 0; i < _brojPredmeta; i++)
			_predmeti[i]->Dealociraj();
		temp[_brojPredmeta] = make_shared<Predmet>();
		temp[_brojPredmeta]->Unos(p._naziv, *p._ocjena, p._datumUnosa);
		_predmeti = temp;
		temp = nullptr;
		_brojPredmeta++;
	}
	void Dealociraj() {

	}
	void Ispis() {
		cout << crt << "Razred -> " << _razred << "Najbolji -> " << _najboljiUcenik << crt;
		for (size_t i = 0; i < _brojPredmeta; i++)
			_predmeti[i]->Ispis();
	}
};

struct Kandidat {
	eNacinStudiranja _nacinStudiranja;
	char * _imePrezime;
	Uspjeh * _uspjeh[4];

	void Unos(eNacinStudiranja nacinStudiranja, char * imePrezime) {
		int vel = strlen(imePrezime) + 1;
		_imePrezime = new char[vel];
		strcpy_s(_imePrezime, vel, imePrezime);
		_nacinStudiranja = nacinStudiranja;
		for (size_t i = 0; i < 4; i++)
			_uspjeh[i] = nullptr;
	}

	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
		for (size_t i = 0; i < 4; i++){
			_uspjeh[i]->Dealociraj();
			delete _uspjeh[i];
		}
	}
	void Ispis() {
		cout << crt << _imePrezime << " " << _nacinStudiranja;
		for (size_t i = 0; i < 4; i++){
			if (_uspjeh[i] != nullptr)
				_uspjeh[i]->Ispis();
		}
	}

	bool DodajPredmet(eRazred e, Predmet p){
		/*
		uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda. prilikom dodavanja onemoguciti:
		- istoimeni predmet se moze dodati samo dva puta, bez obzira sto se dodaje na razlicitim godinama,
		- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
		razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda
		za I razred i sl.). Funkcija vraca neku od predefinisanih poruka u zavisnosti od (ne)uspjesnost izvrsenja
		*/
		int brojacPredmeta = 0;
		for (int i = 0; i < 4; i++)
		{
			if (_uspjeh[i] != nullptr){
				Uspjeh *razred = _uspjeh[i];
				for (int j = 0; j < razred->_brojPredmeta; j++)
				{
					if (strcmp(_uspjeh[i]->_predmeti[j]->_naziv, p._naziv) == 0)
						brojacPredmeta++;
				}
			}
		}
		if (brojacPredmeta >= 2)
			return false;
		for (int i = 0; i < 4; i++)
		{
			if (_uspjeh[i] != nullptr){
				if (_uspjeh[i]->_razred == e){
					Uspjeh *razred = _uspjeh[i];
					for (int j = 0; j < razred->_brojPredmeta; j++)
					{
						if (strstr(razred->_predmeti[j]->_naziv, p._naziv) != NULL)
							return false;
					}
				}
			}
		}
		if (!p._datumUnosa.DaLiJeManji(rokZaPrijavu))
			return false;
		int raz = (int)e - 1;
		if (_uspjeh[raz] == nullptr){
			_uspjeh[raz] = new Uspjeh;
			_uspjeh[raz]->Unos(e, true);
		}
		_uspjeh[raz]->UnosPredmeta(p);

		return true;

	}
};

//else if (prijave2017[bKandidata]._uspjeh[bRazreda] != nullptr){
//	for (int i = 0; i < prijave2017[bKandidata]._uspjeh[bRazreda]->_brojPredmeta; i++)
//		najboljiProsjek += *prijave2017[bKandidata]._uspjeh[bRazreda]->_predmeti[bPredmeta]->_ocjena;


Kandidat *rekNajboljiProsjek(Kandidat* prijave2017, int brojKandidata, eRazred e, int bPredmeta = 0, int bKandidata = 0, int Prosjek = 0, int najboljiProsjek = 0, int bRazreda = 0){
	/*
	napisati rekurzivnu funkciju koja ce vratiti pokazivac na kandidata sa najvecim prosjekom u razredu koji je proslijedjen kao parametar.
	ukoliko je vise kandidata ostvarilo isti prosjek, funkcija treba da vrati posljednje pronadjenog kandidata. u slucaju da niti jedan
	kandidat nije evidentirao uspjeh u trazenom razredu, funkcija vraca nullptr. u nastavku je prikazan primjer poziva rekurzivne funkcije,
	a ostale parametre dodajte po potrebi. /*/
	Kandidat *k = nullptr;
	if (bKandidata > brojKandidata)
		return k;
	if (bRazreda == 4)
		rekNajboljiProsjek(prijave2017, brojKandidata, e, bPredmeta, bKandidata+1, Prosjek, najboljiProsjek, bRazreda);
	//if (bPredmeta >= prijave2017[bKandidata]._uspjeh[bRazreda]->_brojPredmeta)
	//	rekNajboljiProsjek(prijave2017, brojKandidata, e, bPredmeta, bKandidata, Prosjek, najboljiProsjek, bRazreda+1);
	
	if (prijave2017[bKandidata]._uspjeh[bRazreda] != nullptr){
		if (prijave2017[bKandidata]._uspjeh[bRazreda]->_razred == e){
			for (int i = 0; i < prijave2017[bKandidata]._uspjeh[bRazreda]->_brojPredmeta; i++)
				Prosjek += *prijave2017[bKandidata]._uspjeh[bRazreda]->_predmeti[bPredmeta]->_ocjena;
			Prosjek /= prijave2017[bKandidata]._uspjeh[bRazreda]->_brojPredmeta;
			if (Prosjek > najboljiProsjek){
				k = &prijave2017[bKandidata];
				rekNajboljiProsjek(prijave2017, brojKandidata, e, bPredmeta, bKandidata, Prosjek = 0, najboljiProsjek = Prosjek, bRazreda + 1);
			}
		}
		else
			rekNajboljiProsjek(prijave2017, brojKandidata, e, bPredmeta, bKandidata, Prosjek, najboljiProsjek, bRazreda+1);

	}
}

void main(){
	Datum datum19062017, datum20062017, datum30062017, datum05072017;
	datum19062017.Unos(19, 6, 2017);
	datum20062017.Unos(20, 6, 2017);
	datum30062017.Unos(30, 6, 2017);
	datum05072017.Unos(5, 7, 2017);

	Predmet Matematika, Fizika, Hemija, Engleski;
	//2 - ocjena na predmetu; datum - datum evidentiranja uspjeha na predmetu jer postoji krajnji rok za evidentiranje
	Matematika.Unos("Matematika", 2, datum19062017);
	Fizika.Unos("Fizika", 5, datum20062017);
	Hemija.Unos("Hemija", 2, datum20062017);
	Engleski.Unos("Engleski", 5, datum05072017);

	int brojKandidata = 2;

	Kandidat * prijave2017 = new Kandidat[brojKandidata];
	prijave2017[0].Unos(DL, "Jasmin Azemovic");
	prijave2017[1].Unos(REDOVAN, "Indira Hamulic");
	/*
	uspjeh (tokom srednjoskolskog obrazovanja) se dodaje za svaki predmet na nivou razreda. prilikom dodavanja onemoguciti:
	- istoimeni predmet se moze dodati samo dva puta, bez obzira sto se dodaje na razlicitim godinama,
	- dodavanje predmeta nakon dozvoljenog roka za prijavu (rokZaPrijavu).
	razredi (predmeti ili uspjeh) ne moraju biti dodavani sortiranim redoslijedom (npr. prvo se moze dodati uspjeh za II razred, pa onda za I razred i sl.). Funkcija vraca neku od predefinisanih poruka u zavisnosti od (ne)uspjesnost izvrsenja
	*/
	if (prijave2017[0].DodajPredmet(DRUGI, Engleski)) //ne bi trebao dodati jer je prosao postavljeni rok za dodavanje predmeta
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(DRUGI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Fizika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[0].DodajPredmet(PRVI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;

	Matematika.PromijeniOcjenu(5);
	Hemija.PromijeniOcjenu(3);

	if (prijave2017[1].DodajPredmet(PRVI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(DRUGI, Matematika))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(TRECI, Matematika))//ne bi trebalo ponovo dodati Matematiku!
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(TRECI, Hemija))
		cout << "Predmet uspjesno dodan!" << crt;
	if (prijave2017[1].DodajPredmet(DRUGI, Engleski))
		cout << "Predmet uspjesno dodan!" << crt;

	/*
	koristeci Lambda izraz kreirati funkciju koja ce vratiti uspjeh kandidata koji je ostvario najveci prosjek (na nivou razreda, a ne ukupni prosjek).
	funkcija prima parametre tipa eNacinStudiranja (pretrazuje samo kandidate za Redovan ili DL nacin studiranja) i bool kojim se omogucava pretraga
	samo onih razreda na kojim su kandidati bili najbolji ucenici (ako se funkciji proslijedi vrijednost true, ona ce uzeti u obzir samo one razrede
	kada su kandidati oznaceni kao najbolji). ukoliko vise kandidata ima isti prosjek funkcija vraca uspjeh (najboljeg razreda) prvog pronadjenog
	kandidata
	*/
	auto najboljiUspjeh = [&prijave2017, &brojKandidata](eNacinStudiranja e, bool najboljiUcenik){
		Uspjeh* rezultat = nullptr;
		float najveciProsjek = 0;
		float suma;
		for (int i = 0; i <brojKandidata; i++)
		{
			if (prijave2017[i]._nacinStudiranja == e){
				for (int j = 0; j < 4; j++)
				{
					if (prijave2017[i]._uspjeh[j] != nullptr && prijave2017[i]._uspjeh[j]->_najboljiUcenik == najboljiUcenik){
						Uspjeh* razred = prijave2017[i]._uspjeh[j];
						suma = 0;
						for (int k = 0; k < razred->_brojPredmeta; k++)
						{
							suma += *razred->_predmeti[k]->_ocjena;
						}
						suma /= razred->_brojPredmeta;
						if (suma > najveciProsjek){
							najveciProsjek = suma;
							rezultat = razred;
						}
					}
				}
			}
		}
		return rezultat;
	};
	Uspjeh * najbolji = najboljiUspjeh(DL, true);
	najbolji->Ispis();

	/*
	napisati rekurzivnu funkciju koja ce vratiti pokazivac na kandidata sa najvecim prosjekom u razredu koji je proslijedjen kao parametar.
	ukoliko je vise kandidata ostvarilo isti prosjek, funkcija treba da vrati posljednje pronadjenog kandidata. u slucaju da niti jedan
	kandidat nije evidentirao uspjeh u trazenom razredu, funkcija vraca nullptr. u nastavku je prikazan primjer poziva rekurzivne funkcije,
	a ostale parametre dodajte po potrebi. */
	Kandidat * kandidatSaNajboljimProsjekom = rekNajboljiProsjek(prijave2017, brojKandidata, DRUGI);

	for (size_t i = 0; i < brojKandidata; i++)
	{
		prijave2017[i].Ispis();
		prijave2017[i].Dealociraj();
	}
	system("pause>0");
}


________________________________________________________________________


//Izvršiti definiciju funkcija na nacin koji odgovara opisu(komentarima) datom neposredno uz pozive ili nazive funkcija.Možete dati komentar na
//bilo koju liniju code - a koju smatrate da bi trebalo unaprijediti ili da ce eventualno uzrokovati grešku prilikom kompajliranja.Takoder, 
//možete dodati dodatne funkcije koje ce vam olakšati implementaciju programa.

#include <iostream>
using namespace std;

/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/
//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char * crt = "\n-------------------------------\n";

enum Odgovori { NETACNO = -1, TACNO = 1 };
char* OdgovoriChar[] = { "NETACNO", "TACNO" };

struct Kandidat {
	char * _imePrezime;
	char _JMBG[14];
	void Unos(char * ip, char * jmbg) {
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime, strlen(ip) + 1, ip);
		strcpy_s(_JMBG, jmbg);
	}
	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
	}
	void Ispis() {
		cout << _imePrezime << " " << _JMBG << " ";
	}
};

struct Pitanje {
	char * _tekstPitanja;
	char * _odgovori[10];//maksimalno 10 odgovora
	int _tacni[10];
	/*lokacije tacnih odgovora - svako pitanje moze imati jedan ili vise tacnih odgovora, a njihove lokacije se pohranjuju u niz _tacni*/
	int _bodova;
	/*ako pitanje ima vise tacnih odgovora, onda se broj osvojenih bodova (tokom izrade testa) odredjuje na osnovu broj tacnih odgovora (npr. ako pitanje nosi 5 boda i ima 2 tacna odgovora, a student oznaci 1 tacan odgovor onda ce osvojeni broj bodova na tom pitanju iznositi 2.5. drugim rijecima, vrijednost ovog atributa je bitna zbog odredjivanja uspjeha kandidata prilikom izrade ispita)*/

	void Unos(char * tekstPitanja, int bodova) {
		_tekstPitanja = new char[strlen(tekstPitanja) + 1];
		strcpy_s(_tekstPitanja, strlen(tekstPitanja) + 1, tekstPitanja);
		/*umjesto dodavanja brojaca iskoristite defaultne vrijednosti clanova niza kako biste manipulisali njihovim vrijednostima (dodavanje, uklanjanje)*/
		for (size_t i = 0; i < 10; i++) {
			_odgovori[i] = nullptr;
			_tacni[i] = -1;
		}
		_bodova = bodova;
	}
	void Ispis(){
		cout << _tekstPitanja << endl;
		cout << "Odgovori:" << endl;
		for (int i = 0; i < 10; i++)
		{
			if (_odgovori[i] != nullptr){
				cout << i + 1 << ". " << _odgovori[i] << " --> ";
				if (_tacni[i] == 1)
					cout << OdgovoriChar[1] << endl;
				else
					cout << OdgovoriChar[0] << endl;
			}

		}

	}
	bool AddOdgovor(char* odgovor,bool tn){
		/*dodaje novi odgovor u listu ponudjenih odgovora. onemoguciti ponavljanje odgovora, te voditi racuna da vise odgovora moze biti tacno*/
		//parametri: tekstOdgovora,daLiJeTacanTajOdgovor
		int b = 0;
		while (_odgovori[b] != nullptr)
			b++;
		if (b < 10){
			for (int i = 0; i < b; i++)
			{
				if (strcmp(_odgovori[i], odgovor) == 0)
					return false;
			}
			_odgovori[b] = new char[strlen(odgovor) + 1];
			strcpy_s(_odgovori[b], strlen(odgovor) + 1, odgovor);
			if (tn)
				_tacni[b] = 1;
			return true;
		}

	}
	bool RemoveOdgovor(int pozicija){
		/*
		na osnovu primljene lokacije uklanja podatke o ponudjenom odgovoru. prilikom uklanjanja ocuvati redoslijed dodavanja odgovora.
		onemoguciti uklanjanje svih tacnih odgovora tj. osigurati da pitanje u svakom momentu posjeduje najmanje jedan tacan odgovor
		*/
		int b = 0;
		int bTacnih;
		while (_odgovori[b] != nullptr)
			b++;
		if (_tacni[pozicija] == 1){
			int bTacnih = 0;
			for (int i = 0; i < 10; i++)
			{
				if (_tacni[i] == 1)
					bTacnih++;
			}
			if (bTacnih < 2)
				return false;
		}
			for (int i = 0; i < b - 1; i++)
			{
				if (i >= pozicija)
					_odgovori[i] = _odgovori[i + 1];
			}
			delete[] _odgovori[b - 1];
			_odgovori[b - 1] = nullptr;
			return true;
		}

	void Dealociraj() {

		delete[] _tekstPitanja; _tekstPitanja = nullptr;
		for (size_t i = 0; i < 10; i++)
		{
			if (_odgovori[i] == nullptr)
				break;
			delete[] _odgovori[i]; _odgovori[i] = nullptr;
		}
	}
};
struct PrijemniIspit {
	//kandidati prijavljeni za prijemni ispit
	Kandidat * _prijavljeniKandidati[100];
	/*uspjeh ostvaren na prijemnom ispitu za svakog pojedinog kandidata(prijemnom ispitu moze pristupiti maksimalno 100 kandidata i 
	za svakog od njih se cuva ostvareni uspjeh u okviru niza _uspjehKandidata (nakon sto urade ispit tj. nakon sto odgovore na pitanja)*/
	float * _uspjehKandidata[100];
	//prag prolaznosti na prijemnom ispitu npr. 60 procenata
	float _pragProlaznosti;
	float _kazneniBodovi;
	/*vrijednost kazenog boda (npr. 0.30) se mnozi sa svakim netacnim odgovorom na pitanje i oduzima od osvojenih bodova 
	za to pitanje (npr. ako pitanje nosi 5 bodova i ima 2 tacna odgovora, a student odabere 1 tacan i 2 netacna odgovora,
	broj osvojenih bodova ce biti 1.9 (1 tacan = 2.5; 2 netacna * 0.30 kaznenih = 0.6; 2.5 - 0.6 = 1.9)*/

	void Unos(float pragProlaznosti, float kazneniBodovi) {
		_pragProlaznosti = pragProlaznosti;
		_kazneniBodovi = kazneniBodovi;
		/*umjesto dodavanja brojaca iskoristite defaultne vrijednosti clanova niza kako biste manipulisali njihovim vrijednostima
		(dodavanje, uklanjanje)*/
		for (size_t i = 0; i < 100; i++)
		{
			_prijavljeniKandidati[i] = nullptr;
			_uspjehKandidata[i] = nullptr;
		}
	}
	bool DodajKandidata(Kandidat k){
		/*dodaje novog kandidata u listu prijavljenih. onemoguciti dodavanje kandidata sa istim jmbg-om*/
		int b = 0;
		while (_prijavljeniKandidati[b] != nullptr)
			b++;
		if (b >= 100)
			return false;
		for (int i = 0; i < b; i++)
		{
			if (strcmp(k._JMBG, _prijavljeniKandidati[i]->_JMBG) == 0)
				return false;
		}
		_prijavljeniKandidati[b] = new Kandidat;
		_prijavljeniKandidati[b]->Unos(k._imePrezime, k._JMBG);
		return true;
	}
	bool PokreniIspit(char* jmbg, Pitanje* pitanja, int brojPitanja){
		/*kandidatu sa JMBG 1111111111111 pokrece ispit na nacin da mu se prikazuju pitanja, od njega zahtijevaju odgovori,
		te izracunava ostvareni uspjeh (da li je polozio ili ne, te sa kojim procentom uspjesnosti). prilikom izracuvanja uspjesnosti
		voditi racuna o kaznenim bodovima. po okoncanju ispita, uspjeh kandidata se pohranjuje u niz _uspjehKandidata. za pokretanje
		ispita kandidat prethodno mora biti dodan u listu. po vlastitoj zelji implementirajte naci oznacavanja veceg broja tacnih
		odgovoran na postavljeno pitanje (jedno pitanje moze imati vise tacnih odgovora)*/
		int b = 0;
		int uspjeh;
		int brojacVisestrukihOdgovora;
		int tacnihOdgovora;
		while (_prijavljeniKandidati[b] != nullptr)
			b++;
		for (int i = 0; i < b; i++)
		{
			uspjeh = 0;
			if (strcmp(_prijavljeniKandidati[i]->_JMBG, jmbg) == 0){
				for (int j = 0; j < brojPitanja; j++)
				{
					pitanja[j].Ispis();
					brojacVisestrukihOdgovora = 0;
					for (int k = 0; k < 10; k++)
					{
						if (pitanja[j]._tacni[k] != -1)
							brojacVisestrukihOdgovora++;
					}
					if (brojacVisestrukihOdgovora > 1)
						cout << "Pitanje ima vise tacnih odgovora" << endl;
					int temp[10];
					char slovo;
					int z;
					do
					{
						cout << "Unesite " << i + 1 << "tacan odgovor" << endl;
						cin >> temp[z];
						temp[z]--;
						z++;
						cout << "Da li zelite jos tacnih odgovora(D/N)"<<endl;
						cin >> slovo;
					} while (toupper(slovo)=='D');
					tacnihOdgovora = 0;
					for (int l = 0; l < z; l++)
					{
						if (pitanja[j]._tacni[temp[l]] != -1)
							tacnihOdgovora++;
					}
					if (tacnihOdgovora == brojacVisestrukihOdgovora)
						uspjeh+=pitanja[j]._bodova;
				}
				if (uspjeh==11)
			}
		}
	}
};
int main() {

	Kandidat jasmin, adel;
	jasmin.Unos("Jasmin Azemovic", "1111111111111");
	adel.Unos("Adel Handzic", "2222222222222");

	int brojPitanja = 3;
	Pitanje * pitanja = new Pitanje[brojPitanja];
	//parametri: tekstPitanja, brojBodova
	pitanja[0].Unos("U kojem gradu se nalazi FIT?", 4);

	/*dodaje novi odgovor u listu ponudjenih odgovora. onemoguciti ponavljanje odgovora, te voditi racuna da vise odgovora moze biti tacno*/
	//parametri: tekstOdgovora,daLiJeTacanTajOdgovor
	if (pitanja[0].AddOdgovor("Mostar", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Sarajevo", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (!pitanja[0].AddOdgovor("Sarajevo", false))//Sarajevo je vec dodano
		cout << "Odgovor nije uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Tuzla", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Fojnica", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Zenica", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	/*
	na osnovu primljene lokacije uklanja podatke o ponudjenom odgovoru. prilikom uklanjanja ocuvati redoslijed dodavanja odgovora. 
	onemoguciti uklanjanje svih tacnih odgovora tj. osigurati da pitanje u svakom momentu posjeduje najmanje jedan tacan odgovor
	*/
	if (pitanja[0].RemoveOdgovor(4))//uklanja odgovor Fojnica
		cout << "Odgovor uspjesno uklonjen!" << crt;

	/*
	-------------------------------
	1. U kojem gradu se nalazi FIT?
	-------------------------------
	1. Mostar
	2. Sarajevo
	3. Tuzla
	4. Zenica
	-------------------------------
	*/
	pitanja[0].Ispis();//prethodno je prikazan ocekivani ispis pitanja

	pitanja[1].Unos("Odaberite tacne odgovore.", 5);

	if (pitanja[1].AddOdgovor("FIT se nalazi u Mostaru", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[1].AddOdgovor("FIT je clanica UNMO-a", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[1].AddOdgovor("U Mostaru je uvijek jako vruce", false))
		cout << "Odgovor uspjesno dodan!" << crt;

	pitanja[2].Unos("Studij na FIT-u traje 4 godine?", 2);
	if (pitanja[2].AddOdgovor("Ne", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[2].AddOdgovor("Da", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	/*....*/


	PrijemniIspit prijemni2017;
	//parametri: pragProlaznosti, kazneniBodovi
	prijemni2017.Unos(55, 0.30);
	/*dodaje novog kandidata u listu prijavljenih. onemoguciti dodavanje kandidata sa istim jmbg-om*/
	if (prijemni2017.DodajKandidata(jasmin))
		cout << "Kandidat uspjesno dodan" << crt;
	if (prijemni2017.DodajKandidata(adel))
		cout << "Kandidat uspjesno dodan" << crt;

	/*kandidatu sa JMBG 1111111111111 pokrece ispit na nacin da mu se prikazuju pitanja, od njega zahtijevaju odgovori, 
	te izracunava ostvareni uspjeh (da li je polozio ili ne, te sa kojim procentom uspjesnosti). prilikom izracuvanja uspjesnosti
	voditi racuna o kaznenim bodovima. po okoncanju ispita, uspjeh kandidata se pohranjuje u niz _uspjehKandidata. za pokretanje
	ispita kandidat prethodno mora biti dodan u listu. po vlastitoj zelji implementirajte naci oznacavanja veceg broja tacnih
	odgovoran na postavljeno pitanje (jedno pitanje moze imati vise tacnih odgovora)*/
	if (prijemni2017.PokreniIspit("1111111111111", pitanja, brojPitanja))
		cout << "Ispit uspjesno okoncan!" << crt;

	jasmin.Dealociraj();
	adel.Dealociraj();
	for (size_t i = 0; i < brojPitanja; i++)
		pitanja[i].Dealociraj();
	delete[] pitanja;
	system("pause");
	return 0;
}

_______________________________________________________________________

#include <iostream>
using namespace std;
#include<fstream>

/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/
//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

/*
u nastavku je prikazan primjer ispitnog zapisnika (izvještaj o održanom ispitu) sa detaljima/stavkama

Datum ispita: 07.09.2017
Predmet: Programiranje II
IZVJESTAJ O ODRZANOM ISPITU
Br indeksa Ime prezime Komisijsko*** Ocjena
16001	A. Joldic	DA	5
15251	D. Music	NE	7 Ponisteno
16014	E. Babovic	DA	8
UKUPNO POLOZILO:	2
PROSJECNA OCJENA:	6.67
*** komisijski ispit: ako student pristupa cetvrti put i dalje (racunajuci i poništene rezultate)
*/

char * crt = "\n-------------------------------------------\n";
struct Datum {
	int _dan;
	int _mjesec;
	int _godina;
	void Unos(int d, int m, int g) {
		_dan = d;
		_mjesec = m;
		_godina = g;
	}
	void Ispis() {
		cout << _dan << "." << _mjesec << "." << _godina << " ";
	}
	char* GetDatumKaoNizKaraktera(){
		/*naziv fajla treba biti Predmet_datum.txt, npr.ProgramiranjeII_2017 - 09 - 01.txt.zapisnik se nece
		prikazati niti sacuvati u fajl ukoliko ne posjeduje niti jednu stavku ili su sve stavke ponistene */
		char dan[3];
		char mjesec[3];
		char godina[5];
		int velicina = strlen(dan) + strlen(mjesec) + strlen(godina) + 7;
		char* Dat = new char[velicina];
		itoa(_dan, dan, 10);
		itoa(_mjesec, mjesec, 10);
		itoa(_godina, godina, 10);
		strcpy_s(Dat, velicina, godina);
		strcat_s(Dat, velicina, " - ");
		strcat_s(Dat, velicina, mjesec);
		strcat_s(Dat, velicina, " - ");
		strcat_s(Dat, velicina, dan);

		return Dat;
	}
};
struct Student {
	char _imePrezime[20];
	int _brojIndeksa;
	int _polozioECTS;

	void Unos(char* naziv, float cijena) {
		strcpy_s(_imePrezime, naziv);
		_brojIndeksa = cijena;
		_polozioECTS = 0;
	}
	void DodajECTS(float ects) {
		_polozioECTS += ects;
	}
	void UmanjiECTS(float ects) {
		_polozioECTS += ects;
	}
	void Ispis() {
		cout << _imePrezime << ", Indeks: " << _brojIndeksa << ", ECTS: " << _polozioECTS << " " << endl;
	}
};

struct ZapisnikStavka {
	int _ocjena;
	Student* _student; //ZapisnikStavka ce pokazivati na objekat tipa student koji se nalazi u instanci tipa Fakultet, pa nije potrebno vršiti nove alokacije
	bool _ponisteno;
	bool _komisijskoPolaganje;

	void Unos(Student* proizvod, int ocjena, bool komisijskoPolaganje) {
		_ocjena = ocjena;
		_student = proizvod;
		_komisijskoPolaganje = komisijskoPolaganje;
		_ponisteno = false;
	}

	void Ispis() {
		cout << _student->_imePrezime << "\t" << _ocjena << "\t" << _student->_brojIndeksa << "\t";
		if (_ponisteno)
			cout << " Ponisteno";
		cout << endl;
	}
};
struct IspitniZapisnik {
	Datum _datum;
	ZapisnikStavka ** _stavke;//svaki put se dodaje po jedna stavka
	int _brojStavki;
	int _ects;
	char _predmet[20];
	void Unos(Datum datum, char* predmet, int ects) {
		_datum = datum;
		_brojStavki = 0;
		_stavke = nullptr;
		_ects = ects;
		strcpy_s(_predmet, predmet);
	}
	void Ispis(){
		cout << "Datum ispita : ";
		_datum.Ispis();
		cout << endl;
		cout << "Predmet : " << _predmet << endl;
		cout << "IZVJESTAJ O ODRZANOM ISPITU" << endl;
		cout << "Br indeksa" << "\t" << "Ime prezime" << "\t" << "Komisijsko***" << "\t" << "Ocjena" << endl;
		int UkupnoPolozilo = 0;
		for (int i = 0; i < _brojStavki; i++)
		{
			cout << _stavke[i]->_student->_brojIndeksa << "\t" << "\t" << _stavke[i]->_student->_imePrezime << "\t";
			if (_stavke[i]->_komisijskoPolaganje == true)
				cout << "DA" << "\t" << "\t" << _stavke[i]->_ocjena << "\t";
			else
				cout << "NE" << "\t" << _stavke[i]->_ocjena << "\t";
			if (_stavke[i]->_ponisteno)
				cout << "Ponisteno" << endl;
			if (_stavke[i]->_ocjena > 5)
				UkupnoPolozilo++;
			cout << endl;
		}
		cout << "UKUPNO POLOZILO: " << UkupnoPolozilo << endl;
		cout << "PROSJECNA OCJENA: " << GetProsjecnaOcjena() << endl;

	}
	void dodajStavku(Student* s, int ocjena, bool komisijskoPolaganje){
		ZapisnikStavka **temp = new ZapisnikStavka*[_brojStavki + 1];
		for (int i = 0; i <_brojStavki; i++)
		{
			temp[i] = new ZapisnikStavka;
			temp[i]->Unos(_stavke[i]->_student, _stavke[i]->_ocjena, _stavke[i]->_komisijskoPolaganje);
		}
		if (_stavke != nullptr)
			delete _stavke;
		temp[_brojStavki] = new ZapisnikStavka;
		temp[_brojStavki]->Unos(s, ocjena, komisijskoPolaganje);
		_stavke = temp;
		temp = nullptr;
		_brojStavki++;
	}

	/*Prosjecnu ocjenu izracunati koristeci lambda funkciju koja se poziva koristeci objekat
	tipa auto. u prosjek racunati i poništene rezultate (stavke)*/
	float GetProsjecnaOcjena() {
		auto ProsjecnaOcjena = [this]()->float{
			float Suma = 0;
			for (int i = 0; i < _brojStavki; i++){
				Suma += _stavke[i]->_ocjena;
			}
			Suma /=(float) _brojStavki;
			return Suma;
		};
		return ProsjecnaOcjena();
	}
};
const int Max = 100;

/*unutar objekta tipa Fakultet ce se cuvati podaci o svim studentima i ispitnim zapisnicima, a dodaju se pomocu globalnih funkcija*/
struct Fakultet {
	//umjesto brojaca koristiti default.ne vrijednosti
	Student* Studenti[Max];
	IspitniZapisnik* Zapisnici[Max];
	void Unos(){
		for (int i = 0; i < 100; i++)
		{
			Studenti[i] = NULL;
			Zapisnici[i] = NULL;
		}
	}

	void Dealociraj() {
		for (size_t i = 0; i < Max; i++) {
			delete Studenti[i]; Studenti[i] = NULL;
		}
		for (size_t i = 0; i < Max; i++) {
			delete Zapisnici[i]; Zapisnici[i] = NULL;
		}
	}
};

void dodaj_student(Fakultet& f, char* ime, int brojindeksa){
	bool Ispravan = true;
	int b = 0;
	while (f.Studenti[b] != NULL)
		b++;
	for (int i = 0; i < b; i++)
	{
		if (f.Studenti[i]->_brojIndeksa == brojindeksa)
			Ispravan = false;
	}
	f.Studenti[b] = new Student;
	f.Studenti[b]->Unos(ime, brojindeksa);
}
void kreiraj_zapisnik(Fakultet& f, int d, int m, int g, char* nazivPredmeta, int etcs){
	Datum* datum = new Datum;
	datum->_dan = d;
	datum->_mjesec = m;
	datum->_godina = g;
	bool Ispravan = true;
	int b = 0;
	while (f.Zapisnici[b] != NULL)
		b++;
	f.Zapisnici[b] = new IspitniZapisnik;
	f.Zapisnici[b]->Unos(*datum, nazivPredmeta, etcs);
}
bool dodaj_stavku_na_zapisnik(Fakultet& f, int brojindeksa, int ocjena){
	Student* trazeniStudent = nullptr;
	for (int i = 0; i < 100; i++)
	{
		if (f.Studenti[i]->_brojIndeksa == brojindeksa){
			trazeniStudent = f.Studenti[i];
			break;
		}
	}
	int b = 0;
	while (f.Zapisnici[b] != NULL)
		b++;
	b--;
	if (trazeniStudent != nullptr){
		for (int i = 0; i < f.Zapisnici[b]->_brojStavki; i++)
		{
			if (f.Zapisnici[b]->_stavke[i]->_student->_brojIndeksa == brojindeksa){
				f.Zapisnici[b]->_stavke[i]->_ocjena = ocjena;
				if (ocjena > 5)
					trazeniStudent->DodajECTS(f.Zapisnici[b]->_ects);
				return false;

			}
		}
		f.Zapisnici[b]->dodajStavku(trazeniStudent, ocjena, true);
		if (ocjena > 5)
			trazeniStudent->DodajECTS(f.Zapisnici[b]->_ects);
		return true;
	}
	return false;
}

bool ponisti_stavku_rezultat(Fakultet& f, int brojindexa){
	/*u posljednjem zapisniku stavku za studenta 16001 ponistiti, a studentu umanjiti ects bodove.
	funkcija vraca false u slucaju da se student ne nalazi na posljednjem zapisniku*/
	int b = 0;
	while (f.Zapisnici[b] != NULL)
		b++;
	b--;
	for (int i = 0; i <f.Zapisnici[b]->_brojStavki; i++)
	{
		if (f.Zapisnici[b]->_stavke[i]->_student->_brojIndeksa == brojindexa){
			f.Zapisnici[b]->_stavke[i]->_ponisteno = true;
			f.Zapisnici[b]->_stavke[i]->_student->UmanjiECTS(f.Zapisnici[b]->_ects);
			return true;
		}
	}
	return false;
}

bool printaj(Fakultet f){

	int b = 0;
	while (f.Zapisnici[b] != NULL)
		b++;
	b-=2;
	if (f.Zapisnici[b]->_stavke == nullptr)
		return false;
	int brojacPonistenih = 0;
	for (int i = 0; i <f.Zapisnici[b]->_brojStavki ; i++)
	{
		if (f.Zapisnici[b]->_stavke[i]->_ponisteno)
			brojacPonistenih++;
	}
	if (brojacPonistenih == f.Zapisnici[b]->_brojStavki)
		return false;
	
	char* datum = f.Zapisnici[b]->_datum.GetDatumKaoNizKaraktera();
	int velicina = strlen(f.Zapisnici[b]->_predmet) + strlen(datum) + 7;
	char* nazivFajla = new char[velicina];
	strcpy_s(nazivFajla, velicina, f.Zapisnici[b]->_predmet);
	strcat_s(nazivFajla, velicina, "_");
	strcat_s(nazivFajla, velicina, datum);
	strcat_s(nazivFajla, velicina, ".txt.");

	ofstream unos(nazivFajla);
	if (!unos.fail()){
		unos << "Datum ispita : ";
		unos << f.Zapisnici[b]->_datum.GetDatumKaoNizKaraktera();
		unos << endl;
		unos << "Predmet : " << f.Zapisnici[b]->_predmet << endl;
		unos << "IZVJESTAJ O ODRZANOM ISPITU" << endl;
		unos << "Br indeksa" << "\t" << "Ime prezime" << "\t" << "Komisijsko***" << "\t" << "Ocjena" << endl;
		int UkupnoPolozilo = 0;
		for (int i = 0; i < f.Zapisnici[b]->_brojStavki; i++)
		{
			unos << f.Zapisnici[b]->_stavke[i]->_student->_brojIndeksa << "\t"<< f.Zapisnici[b]->_stavke[i]->_student->_imePrezime << "\t";
			if (f.Zapisnici[b]->_stavke[i]->_komisijskoPolaganje == true)
				unos << "DA" << "\t"<<"\t"<< f.Zapisnici[b]->_stavke[i]->_ocjena << "\t";
			else
				unos << "NE" << "\t" << f.Zapisnici[b]->_stavke[i]->_ocjena << "\t";
			if (f.Zapisnici[b]->_stavke[i]->_ponisteno)
				unos << "Ponisteno" << endl;
			if (f.Zapisnici[b]->_stavke[i]->_ocjena > 5)
				UkupnoPolozilo++;
			unos << endl;
		}
		unos << "UKUPNO POLOZILO: " << UkupnoPolozilo << endl;
		unos << "PROSJECNA OCJENA: " << f.Zapisnici[b]->GetProsjecnaOcjena() << endl;
		unos.close();
	}
	else
		cout << "Greska pri otvaranju fajla" << endl;

	f.Zapisnici[b]->Ispis();
	return true;
}

void main() {
	Fakultet fakultet;
	fakultet.Unos();

	/*dodaje podatke o novom studentu u fakultet */
	//fakultet, imePrezime, broj indeksa
	dodaj_student(fakultet, "A. Joldic", 16001);
	dodaj_student(fakultet, "D. Music", 15251);
	dodaj_student(fakultet, "E. Babovic	", 16014);
	dodaj_student(fakultet, "E. Junuz", 16015);
	dodaj_student(fakultet, "J. Azemovic", 16014);//ne dodaje studenta jer je broj indeksa zauzet
	/*kraira novi zapisnik*/
	//fakultet, datum, predmet, ects krediti
	kreiraj_zapisnik(fakultet, 6, 9, 2017, "Programiranje 2", 7);

	/*dodaje stavku na posljednji kreiran zapisnik, a ects studenta uveca ako je student položio ispit. */

	if (dodaj_stavku_na_zapisnik(fakultet, 16001, 5))
		cout << "Stavka (rezultat) uspjesno dodata!" << endl;

	/*ako je student vec dodat u zapisnik, onda se vrsi samo modifikacija njegove ocjene*/
	if (!dodaj_stavku_na_zapisnik(fakultet, 16001, 6))
		cout << "Student vec dodat na zapisnik. Ocjena je ispravljena!" << endl;

	dodaj_stavku_na_zapisnik(fakultet, 15251, 5);
	dodaj_stavku_na_zapisnik(fakultet, 16015, 6);
	dodaj_stavku_na_zapisnik(fakultet, 16014, 8);

	kreiraj_zapisnik(fakultet, 7, 9, 2017, "Racunarske mreze", 5);
	//naredne stavke se dodaju na novi zapisnik
	dodaj_stavku_na_zapisnik(fakultet, 16015, 5);
	dodaj_stavku_na_zapisnik(fakultet, 16014, 10);


	/*u posljednjem zapisniku stavku za studenta 16001 ponistiti, a studentu umanjiti ects bodove.
	funkcija vraca false u slucaju da se student ne nalazi na posljednjem zapisniku*/

	if (ponisti_stavku_rezultat(fakultet, 16001))
		cout << "Stavka (rezultat) uspjesno ponisten!" << endl;

	if (!ponisti_stavku_rezultat(fakultet, 19001))
		cout << "Student nije pronadjen!" << endl;

	/* funkcija printaj prikazuje posljednji ispitni zapisnik u formatu prikazanom na pocetku zadatka.
	* pored prikazivanja, identican sadrzaj ispitnog zapisnika je potrebno je pasiti u tekstualni fajl.
	* naziv fajla treba biti Predmet_datum.txt, npr. ProgramiranjeII_2017-09-01.txt. zapisnik se nece
	prikazati niti sacuvati u fajl ukoliko ne posjeduje niti jednu stavku ili su sve stavke ponistene*/
	if (printaj(fakultet))
		cout << "Ispitni zapisnik uspjesno prikazan i spasen u fajl!" << endl;
	fakultet.Dealociraj();

	system("pause");
}
___________________________________________________________________


#include <iostream>
#include <fstream> 
using namespace std;  

char * crt = "\n==================================================\n";

struct Student{
	int brojIndexa;
	char imePrezime[30]; 
};
//funkcije za unos i ispis vrijednosti atributa objekata tipa Student 
void Unos(Student & student){
	cout<<crt<<"Uneiste ime i prezime studenta: ";
	cin.getline(student.imePrezime,30);
	cout<<"Uneiste broj indexa: "; 
	cin>>student.brojIndexa;  cin.ignore();
} 
void Ispis(const Student & student){
	cout<<crt<<"Ime i prezime: "<<student.imePrezime<<endl;
	cout<<"Broj indexa: "<<student.brojIndexa<<crt;
}
void main(){
	const int brojStudenata = 5;
	const int max = 20;
	char nazivFajla[max];  //objekat cije vrijednosti atributa upisujemo u fajl
	Student student1[brojStudenata];  //objekat cije vrijednosti atributa inicijalizujemo na osnovu sadržaja fajla 
	Student student2[brojStudenata]; 

	cout<<crt<<"\t\t::STUDENT 1::";
	for (int i = 0; i < brojStudenata; i++)
	{
		Unos(student1[i]);
	}
	cout<<crt<<"Unesite ime fajla: "; 
	cin.getline(nazivFajla, max);    //otvaramo fajl za upis u binarnom formatu - ios::binary mod

	ofstream objekatUnos(nazivFajla,ios::out | ios::binary);
	cout<<crt<<"Objekat STUDENT1 upisujem u fajl: "<<nazivFajla<<crt;  //koristeci funkciju write() objekat student1 upisujemo u fajl 
	if (objekatUnos.is_open()){
		for (int i = 0; i < brojStudenata; i++)
			objekatUnos.write((char*)(&student1[i]), sizeof(student1[i]));
	}
	objekatUnos.close();  

	cout << crt << "Sadrzajem fajla " << nazivFajla << " inicijalizujem objekat STUDENT2" << crt;  //otvaramo fajl za ispis binarnog sadržaja 

	ifstream objekatIspis(nazivFajla,ios::in | ios::binary);  //sadržajem fajla, koristeci funkciju read(), inicijalizujemo atribute 
	//objekta student2  
	if (objekatIspis.is_open()){
		for (int i = 0; i < brojStudenata; i++)
			objekatIspis.read((char*)(&student2[i]), sizeof(student2[i]));
	}
	objekatIspis.close();
	cout<<crt<<"\t\t::STUDENTI 2::";
	for (int i = 0; i < brojStudenata; i++)
	{
		Ispis(student2[i]);
	}

	system("pause");
}  

_______________________________________________________________


//Izvršiti definiciju funkcija na nacin koji odgovara opisu(komentarima) datom neposredno uz pozive ili nazive funkcija.Možete dati komentar na bilo koju liniju code - a koju smatrate da bi trebalo unaprijediti ili da ce eventualno uzrokovati grešku prilikom kompajliranja.Takoder, možete dodati dodatne funkcije koje ce vam olakšati implementaciju programa.

#include <iostream>
using namespace std;

/*
1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB160061.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/
//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char * crt = "\n-------------------------------\n";

struct Kandidat {
	char * _imePrezime;
	char _JMBG[14];
	void Unos(char * ip, char * jmbg) {
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime, strlen(ip) + 1, ip);
		strcpy_s(_JMBG, jmbg);
	}
	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
	}
	void Ispis() {
		cout << _imePrezime << " " << _JMBG << " ";
	}
};

struct Pitanje {
	char * _tekstPitanja;
	char * _odgovori[10];//maksimalno 10 odgovora
	int _tacni[10];
	/*lokacije tacnih odgovora - svako pitanje moze imati jedan ili vise tacnih odgovora, a njihove lokacije se pohranjuju u niz _tacni*/
	int _bodova;
	/*ako pitanje ima vise tacnih odgovora, onda se broj osvojenih bodova (tokom izrade testa) odredjuje na osnovu broj tacnih odgovora (npr. ako pitanje nosi 5 boda i ima 2 tacna odgovora, a student oznaci 1 tacan odgovor onda ce osvojeni broj bodova na tom pitanju iznositi 2.5. drugim rijecima, vrijednost ovog atributa je bitna zbog odredjivanja uspjeha kandidata prilikom izrade ispita)*/

	void Unos(char * tekstPitanja, int bodova) {
		_tekstPitanja = new char[strlen(tekstPitanja) + 1];
		strcpy_s(_tekstPitanja, strlen(tekstPitanja) + 1, tekstPitanja);
		/*umjesto dodavanja brojaca iskoristite defaultne vrijednosti clanova niza kako biste manipulisali njihovim vrijednostima (dodavanje, uklanjanje)*/
		for (size_t i = 0; i < 10; i++) {
			_odgovori[i] = nullptr;
			_tacni[i] = -1;
		}
		_bodova = bodova;
	}
	void Dealociraj() {

		delete[] _tekstPitanja; _tekstPitanja = nullptr;
		for (size_t i = 0; i < 10; i++)
		{
			if (_odgovori[i] == nullptr)
				break;
			delete[] _odgovori[i]; _odgovori[i] = nullptr;
		}
	}
	bool AddOdgovor(char* odgovor,bool tacan){
		int b = 0;
		while (_odgovori[b] != nullptr)
			b++;
		if (b >= 10)
			return false;
		for (int i = 0; i < b; i++)
		{
			if (strcmp(_odgovori[i], odgovor) == 0)
				return false;
		}
		_odgovori[b] = new char[strlen(odgovor) + 1];
		strcpy_s(_odgovori[b], strlen(odgovor) + 1, odgovor);
		if (tacan == true)
			_tacni[b] = 1;
		return true;
	}
	bool RemoveOdgovor(int lokacija){
		lokacija--;
		int b = 0;
		while (_odgovori[b] != nullptr)
			b++;
		int brojacTacnih = 0;
		for (int i = 0; i < 10; i++)
		{
			if (_tacni[i] != -1)
				brojacTacnih++;
		}
		if (brojacTacnih < 2){
			if (_tacni[lokacija]!=-1)
				return false;
		}
		for (int i = 0; i < b-1; i++)
		{
			if (i >= lokacija)
				_odgovori[i] = _odgovori[i + 1];
		}
		/*delete _odgovori[--b]; */
		_odgovori[--b] = nullptr;
		for (int i = 0; i < 9; i++)
		{
			if (i >= lokacija)
				_tacni[i] = _tacni[i + 1];
		}
		_tacni[b] = -1;
		return true;
	}

	void Ispis(){
		cout << crt;
		cout << _tekstPitanja << endl;
		cout << crt;
		int b = 0;
		while (_odgovori[b] != nullptr)
			b++;
		for (int i = 0; i < b; i++)
		{
			cout << i + 1 << ". " << _odgovori[i] << endl;
		}
		cout << crt;
	}
};
struct PrijemniIspit {
	//kandidati prijavljeni za prijemni ispit
	Kandidat * _prijavljeniKandidati[100];
	/*uspjeh ostvaren na prijemnom ispitu za svakog pojedinog kandidata(prijemnom ispitu moze pristupiti maksimalno 100 kandidata i za svakog od njih se cuva ostvareni uspjeh u okviru niza _uspjehKandidata (nakon sto urade ispit tj. nakon sto odgovore na pitanja)*/
	float * _uspjehKandidata[100];
	//prag prolaznosti na prijemnom ispitu npr. 60 procenata
	float _pragProlaznosti;
	float _kazneniBodovi;
	/*vrijednost kazenog boda (npr. 0.30) se mnozi sa svakim netacnim odgovorom na pitanje i oduzima od osvojenih bodova za to pitanje (npr. ako pitanje nosi 5 bodova i ima 2 tacna odgovora, a student odabere 1 tacan i 2 netacna odgovora, broj osvojenih bodova ce biti 1.9 (1 tacan = 2.5; 2 netacna * 0.30 kaznenih = 0.6; 2.5 - 0.6 = 1.9)*/

	void Unos(float pragProlaznosti, float kazneniBodovi) {
		_pragProlaznosti = pragProlaznosti;
		_kazneniBodovi = kazneniBodovi;
		/*umjesto dodavanja brojaca iskoristite defaultne vrijednosti clanova niza kako biste manipulisali njihovim vrijednostima (dodavanje, uklanjanje)*/
		for (size_t i = 0; i < 100; i++)
		{
			_prijavljeniKandidati[i] = nullptr;
			_uspjehKandidata[i] = nullptr;
		}
	}
	bool DodajKandidata(Kandidat& k){
		/*dodaje novog kandidata u listu prijavljenih. onemoguciti dodavanje kandidata sa istim jmbg-om*/
		int b = 0;
		while (_prijavljeniKandidati[b] != nullptr)
			b++;
		for (int i = 0; i < b; i++)
		{
			if (strcmp(_prijavljeniKandidati[i]->_JMBG, k._JMBG)==0)
				return false;
		}
		_prijavljeniKandidati[b] = new Kandidat;
		_prijavljeniKandidati[b]->Unos(k._imePrezime, k._JMBG);
		return true;
	}
	bool PokreniIspit(char* jmbg, Pitanje* pitanja, int brojPitanja){
		/*kandidatu sa JMBG 1111111111111 pokrece ispit na nacin da mu se prikazuju pitanja, od njega zahtijevaju odgovori, te izracunava
		ostvareni uspjeh (da li je polozio ili ne, te sa kojim procentom uspjesnosti). prilikom izracuvanja uspjesnosti voditi racuna o kaznenim 
		bodovima. po okoncanju ispita, uspjeh kandidata se pohranjuje u niz _uspjehKandidata. za pokretanje ispita kandidat prethodno mora biti
		dodan u listu. po vlastitoj zelji implementirajte naci oznacavanja veceg broja tacnih odgovoran na postavljeno pitanje
		(jedno pitanje moze imati vise tacnih odgovora)*/
		int b = 0;
		while (_prijavljeniKandidati[b] != nullptr)
			b++;
		Kandidat* k = nullptr;
		int pozicija = 0;
		for (int i = 0; i < b; i++)
		{
			if (strcmp(_prijavljeniKandidati[i]->_JMBG, jmbg) == 0){
				k = _prijavljeniKandidati[i];
				pozicija = i;
				break;
			}
		}
		if (k == nullptr)
			return false;

		int brojacTacnih;
		int tacni[10];
		int tacnihPitanja = 0;
		for (int i = 0; i < brojPitanja; i++)
		{
			pitanja[i].Ispis();
			brojacTacnih = 0;
			
			for (int j = 0; j < 10; j++)
			{
				if (pitanja[i]._tacni[j] != -1)
					brojacTacnih++;
			}
			if (brojacTacnih > 1)
				cout << "imate vise tacnih ogovora za ovo pitanje" << endl;
			int* odg = new int[brojacTacnih];
			for (int k = 0; k < brojacTacnih; k++)
			{
				cout << "Unesite " << k + 1 << "tacan odgovor" << endl;
				cin >> odg[k];
				odg[k]--;
			}
			int provjeraTacnih = 0;
			for (int l = 0; l < brojacTacnih; l++)
			{
				if (-1 != pitanja[i]._tacni[odg[l]])
					provjeraTacnih++;
			}
			if (provjeraTacnih == brojacTacnih)
				tacnihPitanja++;
		}
		float* procenatUspjeh = new float;
		*procenatUspjeh = tacnihPitanja / (float)brojPitanja * 100;
		cout <<"Kandidat "<<k->_imePrezime<<" je imao: "<< *procenatUspjeh <<"% uspjeha na ispitu"<< endl;
		_uspjehKandidata[pozicija] = procenatUspjeh;
		return true;
	}
};
int main() {

	Kandidat jasmin, adel;
	jasmin.Unos("Jasmin Azemovic", "1111111111111");
	adel.Unos("Adel Handzic", "2222222222222");

	int brojPitanja = 3;
	Pitanje * pitanja = new Pitanje[brojPitanja];
	//parametri: tekstPitanja, brojBodova
	pitanja[0].Unos("U kojem gradu se nalazi FIT?", 4);

	/*dodaje novi odgovor u listu ponudjenih odgovora. onemoguciti ponavljanje odgovora, te voditi racuna da vise odgovora moze biti tacno*/
	//parametri: tekstOdgovora,daLiJeTacanTajOdgovor
	if (pitanja[0].AddOdgovor("Mostar", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Sarajevo", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (!pitanja[0].AddOdgovor("Sarajevo", false))//Sarajevo je vec dodano
		cout << "Odgovor nije uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Tuzla", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Fojnica", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[0].AddOdgovor("Zenica", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	/*
	na osnovu primljene lokacije uklanja podatke o ponudjenom odgovoru. prilikom uklanjanja ocuvati redoslijed dodavanja odgovora. onemoguciti uklanjanje svih tacnih odgovora tj. osigurati da pitanje u svakom momentu posjeduje najmanje jedan tacan odgovor
	*/
	if (pitanja[0].RemoveOdgovor(4))//uklanja odgovor Fojnica
		cout << "Odgovor uspjesno uklonjen!" << crt;

	/*
	-------------------------------
	1. U kojem gradu se nalazi FIT?
	-------------------------------
	1. Mostar
	2. Sarajevo
	3. Tuzla
	4. Zenica
	-------------------------------
	*/
	pitanja[0].Ispis();//prethodno je prikazan ocekivani ispis pitanja

	pitanja[1].Unos("Odaberite tacne odgovore.", 5);

	if (pitanja[1].AddOdgovor("FIT se nalazi u Mostaru", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[1].AddOdgovor("FIT je clanica UNMO-a", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[1].AddOdgovor("U Mostaru je uvijek jako vruce", false))
		cout << "Odgovor uspjesno dodan!" << crt;

	pitanja[2].Unos("Studij na FIT-u traje 4 godine?", 2);
	if (pitanja[2].AddOdgovor("Ne", true))
		cout << "Odgovor uspjesno dodan!" << crt;
	if (pitanja[2].AddOdgovor("Da", false))
		cout << "Odgovor uspjesno dodan!" << crt;
	/*....*/


	PrijemniIspit prijemni2017;
	//parametri: pragProlaznosti, kazneniBodovi
	prijemni2017.Unos(55, 0.30);
	/*dodaje novog kandidata u listu prijavljenih. onemoguciti dodavanje kandidata sa istim jmbg-om*/
	if (prijemni2017.DodajKandidata(jasmin))
		cout << "Kandidat uspjesno dodan" << crt;
	if (prijemni2017.DodajKandidata(adel))
		cout << "Kandidat uspjesno dodan" << crt;

	/*kandidatu sa JMBG 1111111111111 pokrece ispit na nacin da mu se prikazuju pitanja, od njega zahtijevaju odgovori, te izracunava ostvareni uspjeh (da li je polozio ili ne, te sa kojim procentom uspjesnosti). prilikom izracuvanja uspjesnosti voditi racuna o kaznenim bodovima. po okoncanju ispita, uspjeh kandidata se pohranjuje u niz _uspjehKandidata. za pokretanje ispita kandidat prethodno mora biti dodan u listu. po vlastitoj zelji implementirajte naci oznacavanja veceg broja tacnih odgovoran na postavljeno pitanje (jedno pitanje moze imati vise tacnih odgovora)*/
	if (prijemni2017.PokreniIspit("1111111111111", pitanja, brojPitanja))
		cout << "Ispit uspjesno okoncan!" << crt;

	jasmin.Dealociraj();
	adel.Dealociraj();
	for (size_t i = 0; i < brojPitanja; i++)
		pitanja[i].Dealociraj();
	delete[] pitanja;
	return 0;
}

___________________________________________________________________________

/*
1. ZADATAK

Izvršiti definiciju funkcija na nacin koji odgovara opisu (komentarima) datom neposredno uz pozive ili nazive funkcija. Možete dati komentar na bilo koju liniju code-a koju smatrate da bi trebalo unaprijediti ili da ce eventualno uzrokovati grešku prilikom kompajliranja. Takoder, možete dodati dodatne funkcije koje ce vam olakšati implementaciju programa.


1. BROJ I VRSTA PARAMETARA MORAJU BITI IDENTICNI KAO U PRIMJERIMA. U SUPROTNOM SE RAD NECE BODOVATI
2. STAVITE KOMENTAR NA DIJELOVE CODE-A KOJE NE BUDETE IMPLEMENTIRALI
3. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB130030.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA. NE PREDAVATI .TXT ILI .CPP FAJLOVE
4. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
5. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
6. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
*/

#include<iostream>
using namespace std;

//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)

char *crt = "\n-------------------------------------------\n";

enum vrstaDokumenta { PDF, DOC, TXT, HTML };
enum prioritet { VISOK, SREDNJI, NIZAK };
struct DatumVrijeme {
	int *_dan, *_mjesec, *_godina, *_sati, *_minuti;
	void Unos(int dan = 1, int mjesec = 1, int godina = 2000, int sati = 0, int minuti = 0) {
		_dan = new int(dan);
		_mjesec = new int(mjesec);
		_godina = new int(godina);
		_sati = new int(sati);
		_minuti = new int(minuti);
	}
	void Dealociraj() {
		delete _dan; _dan = nullptr;
		delete _mjesec; _mjesec = nullptr;
		delete _godina; _godina = nullptr;
		delete _sati; _sati = nullptr;
		delete _minuti; _minuti = nullptr;

	}
	void Ispis() {
		cout << *_dan << "." << *_mjesec << "." << *_godina << " " << *_sati << ":" << *_minuti << endl;
	}
	bool DaLiSuIsti(DatumVrijeme datumDokumenta){
		if (*_godina == *datumDokumenta._godina &&
			*_mjesec == *datumDokumenta._mjesec &&
			*_dan == *datumDokumenta._dan &&
			*_sati == *datumDokumenta._sati &&
			*_minuti == *datumDokumenta._minuti)
			return true;
		return false;
	}
};

struct Filter {
	char * _sadrzaj;
	prioritet _prioritet;
	void Unos(char * sadrzaj, prioritet prioritet) {
		int vel = strlen(sadrzaj) + 1;
		_sadrzaj = new char[vel];
		strcpy_s(_sadrzaj, vel, sadrzaj);
		_prioritet = prioritet;
	}
	void Dealociraj() {
		delete[] _sadrzaj; _sadrzaj = nullptr;
	}
	void Ispis() { cout << _sadrzaj << " (" << _prioritet << ")" << endl; }
};

struct Dokument {
	vrstaDokumenta _vrsta;
	char * _naziv;
	char * _sadrzaj;
	DatumVrijeme _kreiran;
	int _brojStranica;
	int _brojac = 0;

	void Unos(vrstaDokumenta vrsta, char * naziv, DatumVrijeme kreiran) {
		int vel = strlen(naziv) + 1;
		_naziv = new char[vel];
		strcpy_s(_naziv, vel, naziv);
		_sadrzaj = nullptr;
		_vrsta = vrsta;
		_kreiran.Unos(*kreiran._dan, *kreiran._mjesec, *kreiran._godina, *kreiran._sati, *kreiran._minuti);
		_brojStranica = 0;//broj stranica se odredjuje prilikom dodavanja svakog novog sadrzaja dokumentu
	}
	void Kopiraj(vrstaDokumenta vrsta, char * naziv,char* sadrzaj, DatumVrijeme kreiran,int brojstranica,int brojac) {
		int vel = strlen(naziv) + 1;
		_naziv = new char[vel];
		strcpy_s(_naziv, vel, naziv);
		_sadrzaj = new char[strlen(sadrzaj) + 1];
		strcpy_s(_sadrzaj, strlen(sadrzaj) + 1, sadrzaj);
		_vrsta = vrsta;
		_kreiran.Unos(*kreiran._dan, *kreiran._mjesec, *kreiran._godina, *kreiran._sati, *kreiran._minuti);
		_brojStranica = brojstranica;
		_brojac = brojac;
	}
	void Dealociraj() {
		delete[] _naziv; _naziv = nullptr;
		delete[] _sadrzaj; _sadrzaj = nullptr;
		_kreiran.Dealociraj();
	}

	void Ispis() {
		cout << crt << _naziv << " " << _vrsta << " kreiran ";
		_kreiran.Ispis();
		cout << crt << _sadrzaj << crt << " br.stranica (" << _brojStranica << ")" << crt;
	}
	void DodajSadrzaj(char* sadrzaj){
		int velicina;
		if (_sadrzaj != nullptr){
			velicina = strlen(_sadrzaj) + strlen(sadrzaj) + 1;
			char* temp = new char[velicina];
			strcpy_s(temp, velicina, _sadrzaj);
			strcat_s(temp, velicina, sadrzaj);
			delete[] _sadrzaj;
			_sadrzaj = nullptr;
			_sadrzaj = temp;
			temp = nullptr;
		}
		else{
			velicina = strlen(sadrzaj) + 1;
			char* temp = new char[velicina];
			strcpy_s(temp,velicina, sadrzaj);
			_sadrzaj = temp;
			temp = nullptr;
		}
		char znak;
		int vel = strlen(sadrzaj);
		for (int i = 0; i < vel; i++)
		{
			znak = _sadrzaj[i];
			_brojac++;
			if (_brojac >= 30){
				_brojStranica++;
				_brojac = 0;
			}
		}
	}
};
struct Printer {
	char * _proizvodjac;
	char * _model;
	Dokument * _dokumenti;
	int _trenutnoDokumenata;
	Filter * _filteri;
	int _trenutnoFiltera;

	void Ispis(){
		//PORED VRIJEDNOSTI SVIH OSTALIH ATRIBUTA, ISPISUJE SAMO ONE DOKUMENTE KOJI ZADOVOLJAVAJU SVA PRETHODNO DEFINISANA PRAVILA 
		cout << _proizvodjac << endl;
		cout << _model << endl;
		for (int i = 0; i < _trenutnoDokumenata; i++)
			_dokumenti[i].Ispis();

	}

	void Unos(char * proizvodjac, char * model) {
		int vel = strlen(proizvodjac) + 1;
		_proizvodjac = new char[vel];
		strcpy_s(_proizvodjac, vel, proizvodjac);
		vel = strlen(model) + 1;
		_model = new char[vel];
		strcpy_s(_model, vel, model);
		_trenutnoDokumenata = 0;
		_trenutnoFiltera = 0;
		_filteri = nullptr;
		_dokumenti = nullptr;
	}

	void Dealociraj() {
		delete[] _proizvodjac; _proizvodjac = nullptr;
		delete[] _model; _model = nullptr;
		for (size_t i = 0; i < _trenutnoDokumenata; i++)
			_dokumenti[i].Dealociraj();
		delete[]_dokumenti; _dokumenti = nullptr;
		for (size_t i = 0; i < _trenutnoFiltera; i++)
			_filteri[i].Dealociraj();
		delete[]_filteri; _filteri = nullptr;
	}
	bool DodajFilter(char* sadrzajFiltera, prioritet p){
		
		if (_filteri != nullptr){
			for (int i = 0; i < _trenutnoFiltera; i++)
			{
				if (strcmp(_filteri[i]._sadrzaj, sadrzajFiltera) == 0)
					return false;
			}
		}

		Filter* temp = new Filter[_trenutnoFiltera + 1];
		for (int i = 0; i < _trenutnoFiltera; i++)
		{
			temp[i].Unos(_filteri[i]._sadrzaj, _filteri[i]._prioritet);
			_filteri[i].Dealociraj();
		}
		_filteri = nullptr;
		temp[_trenutnoFiltera].Unos(sadrzajFiltera, p);
		_filteri = temp;
		temp = nullptr;
		_trenutnoFiltera++;
		return true;
	}
	void DodajDokument(Dokument& dokument){
		Dokument* temp = new Dokument[_trenutnoDokumenata + 1];
		for (int i = 0; i < _trenutnoDokumenata; i++)
		{
			temp[i].Kopiraj(_dokumenti[i]._vrsta, _dokumenti[i]._naziv, _dokumenti[i]._sadrzaj, _dokumenti[i]._kreiran, _dokumenti[i]._brojStranica, _dokumenti[i]._brojac);
			_dokumenti[i].Dealociraj();
		}
		_dokumenti = nullptr;
		temp[_trenutnoDokumenata].Kopiraj(dokument._vrsta,dokument._naziv,dokument._sadrzaj,dokument._kreiran,dokument._brojStranica,dokument._brojac);
		_dokumenti = temp;
		temp = nullptr;
		_trenutnoDokumenata++;
	}
	bool ZadovoljavaUslove(Dokument& dokument){
		bool zadovoljavaExtenzija = true;
		bool zadovoljavaNaziv = true;
		bool zadovoljavaSadrzaj = true;
		if (dokument._vrsta != PDF && dokument._vrsta != DOC && dokument._vrsta != TXT && dokument._vrsta != HTML)
			zadovoljavaExtenzija = false;
		int velicinaNaziva = strlen(dokument._naziv + 1);
		int b = 0;
		char znak;
		while (b<velicinaNaziva)
		{
			znak = dokument._naziv[b];
			if (isalpha(znak) || ispunct(znak)){
				b++;
				continue;
			}
			else{
				zadovoljavaNaziv = false;
				break;
			}
		}
		for (int i = 0; i <_trenutnoFiltera; i++)
		{
			if (dokument._sadrzaj != NULL){
				if (strstr(dokument._sadrzaj, _filteri[i]._sadrzaj) != NULL){
					if (_filteri[i]._prioritet != NIZAK)
						zadovoljavaSadrzaj = false;
				}
			}
		}
		if (zadovoljavaExtenzija && zadovoljavaNaziv && zadovoljavaSadrzaj)
			return true;
		return false;
	}
	void Printaj(Dokument dokument){

		if (dokument._sadrzaj != nullptr){
			if (ZadovoljavaUslove(dokument)){
				DodajDokument(dokument);
				for (int i = 0; i <= dokument._brojStranica; i++)
				{
					char niz[31];
					char* znak = &dokument._sadrzaj[i * 30];
					strncpy(niz, znak, 30);
					niz[30] = '\0';
					cout << niz << endl;
					cout << crt;
				}
			}
			else{
				DodajDokument(dokument);
			}
		}
	}
	float GetProsjecanBrojStranicaPoDatumuIVrsti(DatumVrijeme datum1,DatumVrijeme datum2,vrstaDokumenta vrstadok){
		//PROSJECAN BROJ STRANICA = UKUPAN BROJ STRANICA / BROJ PRINTANIH DOKUMENATA
		//Prosjecan broj printanih stranica je -> 
		float ProsjecanBrojStranica = 0;
		int UkupanBrojStranica = 0;
		int BrojPrintanihDokumenata = 0;
		for (int i = 0; i < _trenutnoDokumenata; i++)
		{
			if (datum1.DaLiSuIsti(_dokumenti[i]._kreiran) || datum2.DaLiSuIsti(_dokumenti[i]._kreiran) && vrstadok == _dokumenti[i]._vrsta &&
				ZadovoljavaUslove(_dokumenti[i])){
				BrojPrintanihDokumenata++;
				UkupanBrojStranica += _dokumenti[i]._brojStranica;
			}
		}
		ProsjecanBrojStranica = (float)UkupanBrojStranica / (float)BrojPrintanihDokumenata;
		return ProsjecanBrojStranica;
	}
	Filter* GetNajkoristenijiFilter(){
		//VRACA FILTER KOJI SE NAJCEŠCE KORISTIO U DOKUMENTIMA
		Filter* f = nullptr;
		int* niz = new int[_trenutnoFiltera];
		for (int i = 0; i < _trenutnoFiltera; i++)
			niz[i] = 0;
		
		for (int i = 0; i < _trenutnoDokumenata; i++)
		{
			for (int j = 0; j < _trenutnoFiltera; j++)
			{
				if (strstr(_dokumenti[i]._sadrzaj, _filteri[j]._sadrzaj) != NULL)
					niz[j]++;
			}
		}
		int najveci = 0;
		int pozicija = 0;
		for (int i = 0; i < _trenutnoFiltera; i++)
		{
			if (niz[i]>najveci){
				najveci = niz[i];
				pozicija = i;
			}
		}
		f = &_filteri[pozicija];
		return f;
	}
};
void ZamijeniIPrintaj(Printer p,char znak){
	/*MIJENJA ZNAKOVE ZABRANJENOG SADRŽAJA DOKUMENTA SA POSLANIM KARAKTEROM
	(BEZ OBZIRA NA PRIORITET) I NAKON TOGA PRINTA SADRŽAJ DOKUMENATA; npr.
	UBITI POSTAJE -----.
	RIJEŠITI REKURZIJOM*/
	char* pok = nullptr;
	for (int i = 0; i < p._trenutnoDokumenata; i++)
	{
		for (int j = 0; j < p._trenutnoFiltera; j++)
		{
			pok = strstr(p._dokumenti[i]._sadrzaj, p._filteri[j]._sadrzaj);
			if (pok != NULL){
				int velicinaFiltera = strlen(p._filteri[j]._sadrzaj);
				for (int k = 0; k < velicinaFiltera; k++)
				{
					pok[k] = znak;
				}
			}
				
		}
		p.Printaj(p._dokumenti[i]);
	}
}


void main() {
	DatumVrijeme prije3Dana; prije3Dana.Unos(3, 2, 2017, 10, 15);
	DatumVrijeme danas1; danas1.Unos(6, 2, 2017, 10, 15);
	DatumVrijeme danas2; danas2.Unos(6, 2, 2017, 10, 16);
	DatumVrijeme za10Dana; za10Dana.Unos(16, 2, 2017, 10, 15);

	Dokument ispitPRII, ispitMAT, ispitUIT, ispitUITDrugiRok;
	ispitPRII.Unos(DOC, "ispitPRII.doc", prije3Dana);
	ispitMAT.Unos(DOC, "ispitMAT.doc", danas1);
	ispitUIT.Unos(DOC, "ispitUIT.doc", danas2);
	ispitUITDrugiRok.Unos(PDF, "ispitUITDrugiRok.pdf", za10Dana);

	/*BROJ STRANICA DOKUMENTA SE AUTOMATSKI ODREÐUJE PRILIKOM DODAVANJA SADRŽAJA. ZA POTREBE ISPITA PRETPOSTAVLJAMO DA NA JEDNU
	STRANICU MOŽE STATI 30 ZNAKOVA UKLJUCUJUCI I RAZMAKE*/
	ispitPRII.DodajSadrzaj("Programiranje ili racunarsko programiranje (engl. programming) jeste vještina pomocu koje ");
	ispitPRII.DodajSadrzaj("korisnik stvara i izvršava algoritme koristeci odredene programske jezike da bi ... ");
	cout << "Broj stranica -> " << ispitPRII._brojStranica << endl;

	ispitPRII.Ispis();//ISPISUJE SVE PODATKE O DOKUMENTU

	ispitMAT.DodajSadrzaj("matematika se razvila iz potrebe da se obavljaju proracuni u trgovini, vrše mjerenja zemljišta i predvidaju ");
	ispitMAT.DodajSadrzaj("astronomski dogadaji, i ove tri primjene se mogu dovesti u vezu sa grubom podjelom matematike na RAT i ");

	Printer hp3200; hp3200.Unos("HP", "3200");
	/*PRINTER NECE DOZVOLITI PRINTANJE DOKUMENATA U CIJEM SADRŽAJU SE NALAZI NEKA OD ZABRANJENIH RIJECI DEFINISANIH FILTERIMA*/
	if (hp3200.DodajFilter("RE", NIZAK)) //VISOK :)
		cout << "Filter dodan!" << endl;
	if (hp3200.DodajFilter("RAT", VISOK))
		cout << "Filter dodan!" << endl;
	if (hp3200.DodajFilter("UBITI", VISOK))
		cout << "Filter dodan!" << endl;
	if (hp3200.DodajFilter("MRZITI", SREDNJI))
		cout << "Filter dodan!" << endl;
	if (hp3200.DodajFilter("RE", SREDNJI))/* ONEMOGUCITI PONAVLJANJE FILTERA, BEZ OBZIRA STO SU RAZLICITOG PRIORITETA*/
		cout << "Filter dodan!" << endl;

	/*
	DA BI PRINTER ISPRINTAO NEKI DOKUMENT MORAJU BITI ZADOVOLJENA SLJEDECA PRAVILA:
	1. NAZIV DOKUMENTA MOŽE SADRŽAVATI SAMO SLOVA, A EKSTENZIJA MOŽE BITI SAMO NEKA OD OZNACENIH SA vrstaDokumenta
	2. SADRŽAJ DOKUMENTA U SEBI NE SMIJE POSJEDOVATI ZABRANJENE RIJEC DEFINISANE FILTERIMA OSIM AKO SU ONE OZNACENE SA NISKIM PRIORITETOM 
	(PRIRITET NIZAK)

	UKOLIKO NEKI OD NAVEDENIH USLOVA NIJE ZADOVOLJEN FUNKCIJA PRINTAJ DOKUMENT TREBA SACUVATI U NIZ _dokumenti, ALI TAJ DOKUMENT NE TREBA PRINTATI.
	UKOLIKO DOKUMENT ISPUNJAVA SVE USLOVE ZA PRINTANJE POTREBNO JE NA KONZOLU ISPISATI SADRŽAJ DOKUMENTA KOJI SE PRINTA, A SA CRT LINIJOM ODVAJATI 
	STRANICE DOKUMENTA
	*/
	hp3200.Printaj(ispitPRII);
	hp3200.Printaj(ispitMAT);
	hp3200.Printaj(ispitUIT);
	hp3200.Printaj(ispitUITDrugiRok);

	//PROSJECAN BROJ STRANICA = UKUPAN BROJ STRANICA / BROJ PRINTANIH DOKUMENATA
	cout << "Prosjecan broj printanih stranica je -> " << hp3200.GetProsjecanBrojStranicaPoDatumuIVrsti(prije3Dana, danas2, DOC) << crt;
	//VRACA FILTER KOJI SE NAJCEŠCE KORISTIO U DOKUMENTIMA
	Filter * f = hp3200.GetNajkoristenijiFilter();
	cout << "Najcesce koristeni sadrzaj filtera je -> " << f->_sadrzaj << crt;
	//PORED VRIJEDNOSTI SVIH OSTALIH ATRIBUTA, ISPISUJE SAMO ONE DOKUMENTE KOJI ZADOVOLJAVAJU SVA PRETHODNO DEFINISANA PRAVILA 
	hp3200.Ispis();
	/*MIJENJA ZNAKOVE ZABRANJENOG SADRŽAJA DOKUMENTA SA POSLANIM KARAKTEROM
	(BEZ OBZIRA NA PRIORITET) I NAKON TOGA PRINTA SADRŽAJ DOKUMENATA; npr.
	UBITI POSTAJE -----.
	RIJEŠITI REKURZIJOM*/
	ZamijeniIPrintaj(hp3200, '-'); //OSTALE PARAMETRE DODAJTE PO POTREBI

	prije3Dana.Dealociraj(); danas1.Dealociraj(); danas2.Dealociraj(); za10Dana.Dealociraj();
	ispitMAT.Dealociraj(); ispitPRII.Dealociraj(); ispitUIT.Dealociraj(); ispitUITDrugiRok.Dealociraj();

	hp3200.Dealociraj();
	system("pause");
}

_____________________________________________________________________________


//narednu liniju code-a ignorisite, osim u slucaju da vam bude predstavljala smetnje u radu
#pragma warning(disable:4996)
#include<iostream>
using namespace std;

enum enumKursevi { HtmlCSSJavaScript, SoftwareEngeneeringFundamentals, MasteringSQL, WindowsSecurity };
char *crt = "\n--------------------------------------------\n";

struct Datum {
	int * _dan, *_mjesec, *_godina;
	void Unos(int d, int m, int g) {
		_dan = new int(d);
		_mjesec = new int(m);
		_godina = new int(g);
	}
	void Ispis() { cout << *_dan << "/" << *_mjesec << "/" << *_godina; }
	void Dealociraj() { delete _dan; delete _mjesec; delete _godina; }
};
int PretvoriUDane(Datum d){
	int dani = *d._godina * 365 + *d._mjesec * 30 + *d._dan;
	return dani;
}

struct Kurs {
	enumKursevi _kurs;
	Datum * _pocetak;
	Datum * _kraj;
	char * _imePredavaca;
	float _cijenaKursa;

	void Unos(enumKursevi kurs, Datum pocetak, Datum kraj, char * imePredavaca, float cijenaKursa) {
		_kurs = kurs;
		_pocetak = new Datum;
		_pocetak->Unos(*pocetak._dan, *pocetak._mjesec, *pocetak._godina);
		_kraj = new Datum;
		_kraj->Unos(*kraj._dan, *kraj._mjesec, *kraj._godina);
		int size = strlen(imePredavaca) + 1;
		_imePredavaca = new char[size];
		strcpy_s(_imePredavaca, size, imePredavaca);
		_cijenaKursa = cijenaKursa;
	}
	void Ispis() {
		cout << _kurs << " " << _imePredavaca << " " << _cijenaKursa << " (";
		_pocetak->Ispis(); cout << " - "; _kraj->Ispis(); cout << ")";
	}
	void Dealociraj() {
		delete[] _imePredavaca; _imePredavaca = nullptr;
		_pocetak->Dealociraj();
		_kraj->Dealociraj();
		delete _pocetak; _pocetak = nullptr;
		delete _kraj; _kraj = nullptr;
	}
};
struct Polaznik {
	char * _imePrezime;
	Datum * _datumRodjenja;
	void Unos(char * imePrezime, Datum datumRodjenja) {
		int size = strlen(imePrezime) + 1;
		_imePrezime = new char[size];
		strcpy_s(_imePrezime, size, imePrezime);
		_datumRodjenja = new Datum;
		_datumRodjenja->Unos(*datumRodjenja._dan, *datumRodjenja._mjesec, *datumRodjenja._godina);
	}
	void Dealociraj() {
		delete[] _imePrezime; _imePrezime = nullptr;
		delete _datumRodjenja; _datumRodjenja = nullptr;
	}
	void Ispis() { cout << _imePrezime << "("; _datumRodjenja->Ispis(); cout << ")"; }
};
struct Prijava {
	Polaznik * _polaznik; //prijava moze biti pojedinacna ili grupna
	float * _uplaceniIznos;
	//za svakog polaznika ce se cuvati podatak o iznosu uplate. uplaceni iznos svakog pojedinog polaznika treba biti jednak punoj cijeni 
	//kursa osim u sljedecim slucajevima:
	//1. prijave 2 ili 3 polaznika dobijaju 10% popusta na ukupnu cijenu kursa
	//2. prijave za vise od 3 polaznika dobijaju 15% na ukupnu cijenu kursa
	int _trenutnoPolaznika;
	Kurs * _kurs; //prijava treba cuvati adresu (pokazivati) na postojeci kurs, a ne kreirati novi
	void Dealociraj(){
		delete _polaznik;
		_polaznik = nullptr;
		_kurs = nullptr;
	}
	void Ispis(){
		_polaznik->Ispis();
		cout << "Uplaceni iznos: " << *_uplaceniIznos << endl;
		_kurs->Ispis();
	}

	void Unos(Kurs* k){
		_kurs = k;
		_polaznik = nullptr;
		_uplaceniIznos = nullptr;
		_trenutnoPolaznika = 0;
	}
	void Kopiraj(Polaznik p, float uplaceniiznos, int trenutnopolaznika, Kurs* k){
		_polaznik = new Polaznik;
		_polaznik->Unos(p._imePrezime, *p._datumRodjenja);
		_uplaceniIznos = new float;
		*_uplaceniIznos = uplaceniiznos;
		_trenutnoPolaznika = trenutnopolaznika;
		_kurs = k;
	}
	void DodajPolaznikaIUplatu(Polaznik& p,float uplata){
		Polaznik* temp = new Polaznik[_trenutnoPolaznika + 1];
		for (int i = 0; i < _trenutnoPolaznika; i++)
		{
			temp[i].Unos(_polaznik[i]._imePrezime, *_polaznik[i]._datumRodjenja);
			_polaznik[i].Dealociraj();
		}
		temp[_trenutnoPolaznika].Unos(p._imePrezime, *p._datumRodjenja);
		_polaznik = temp;
		temp = nullptr;

		float* temp2 = new float[_trenutnoPolaznika + 1];
		for (int i = 0; i < _trenutnoPolaznika; i++)
			temp2[i] = _uplaceniIznos[i];
		delete[] _uplaceniIznos; _uplaceniIznos = nullptr;
		temp2[_trenutnoPolaznika] = uplata;
		_uplaceniIznos = temp2;
		temp2 = nullptr;
		_trenutnoPolaznika++;
	}
	bool DodajPolaznika(Polaznik& p, float uplata){
		//700 predstavlja uplatu polaznika koji se prijavljuje na kurs
		//tokom prijave polaznika nije potrebno uplatiti kompletan iznos, ali on mora biti veci od 50% iznosa kojeg je u tom momentu
		//potrebno platiti (u zavisnosti od broja prijavljenih tj. ostvarenog popusta)
		//onemoguciti dupliranje polaznika na istoj prijavi
		for (int i = 0; i < _trenutnoPolaznika; i++)
		{
			if (strcmp(_polaznik[i]._imePrezime, p._imePrezime) == 0)
				return false;
		}
		if (_trenutnoPolaznika < 1){
			if (_kurs->_cijenaKursa / 2 > uplata)
				return false;
			DodajPolaznikaIUplatu(p,uplata);
			return true;
		}
		if (_trenutnoPolaznika >= 1 && _trenutnoPolaznika <= 2){
			_kurs->_cijenaKursa = _kurs->_cijenaKursa*0.9;
			if (_kurs->_cijenaKursa / 2 > uplata)
				return false;
			DodajPolaznikaIUplatu(p, uplata);
			return true;
		}
		_kurs->_cijenaKursa = _kurs->_cijenaKursa*0.85;
		if (_kurs->_cijenaKursa / 2 > uplata)
			return false;
		DodajPolaznikaIUplatu(p, uplata);
		return true;
	}
	bool DodajUplatu(Polaznik p,float uplata){
		for (int i = 0; i < _trenutnoPolaznika; i++)
		{
			if (strcmp(_polaznik[i]._imePrezime, p._imePrezime) == 0){
				_uplaceniIznos[i] += uplata;
				return true;
			}
				
		}
		return false;
	}
	float StatusUplate(Polaznik p){
		//ako polaznik duguje novca funkcija vraca negativan iznos potrebne uplate
		float dug = 0;
		for (int i = 0; i < _trenutnoPolaznika; i++)
		{
			if (strcmp(_polaznik[i]._imePrezime, p._imePrezime) == 0){
				dug = _kurs->_cijenaKursa - _uplaceniIznos[i];
			}
		}
		return dug;
	}
};

struct SkillsCentar {
	char * _nazivCentra;
	Kurs * _kursevi[50];//JEDAN EDUKACIJSKI CENTAR MOZE NUDITI NAJVISE 50 KURSEVA
	int _trenutnoKurseva;
	Prijava * _prijave;
	int _trenutnoPrijava;

	void Unos(char* nazivcentra){
		_nazivCentra = new char[strlen(nazivcentra) + 1];
		strcpy_s(_nazivCentra, strlen(nazivcentra) + 1, nazivcentra);
		_trenutnoKurseva = 0;
		_prijave = nullptr;
		_trenutnoPrijava = 0;
	}
	bool DodajKurs(Kurs& k){
		if (_trenutnoKurseva >= 50)
			return false;
		for (int i = 0; i < _trenutnoKurseva; i++)
		{
			if (k._kurs == _kursevi[i]->_kurs){
				if (PretvoriUDane(*k._pocetak) - PretvoriUDane(*_kursevi[i]->_kraj) < 15)
					return false;
			}
		}
		_kursevi[_trenutnoKurseva] = new Kurs;
		_kursevi[_trenutnoKurseva++]->Unos(k._kurs, *k._pocetak, *k._kraj, k._imePredavaca, k._cijenaKursa);
		return true;
	}
	void DodajPrijavu2(Prijava& p){
		Prijava* temp = new Prijava[_trenutnoPrijava + 1];
		for (int i = 0; i < _trenutnoPrijava; i++)
		{
			temp[i].Kopiraj(*_prijave[i]._polaznik, *_prijave[i]._uplaceniIznos, _prijave[i]._trenutnoPolaznika, _prijave[i]._kurs);
			_prijave[i].Dealociraj();
		}
		temp[_trenutnoPrijava].Kopiraj(*p._polaznik, *p._uplaceniIznos, p._trenutnoPolaznika, p._kurs);
		_prijave = temp;
		temp = nullptr;
		_trenutnoPrijava++;
	}
	bool DodajPrijavu(Prijava& p){
		//nije moguce dodati prijavu onog kursa koji nije evidentiran (registrovan, ponudjen) u tom edukacijskom centru
		//moguce je dodati samo one prijave koje kod kojih ukupna uplata iznosi vise od 80% cijene kursa (za prijavljeni broj polaznika) 
		for (int i = 0; i < _trenutnoKurseva; i++)
		{
			if (_kursevi[i]->_kurs == p._kurs->_kurs){
				int procenat = 80;
				if ((procenat / 100 * _kursevi[i]->_cijenaKursa) > *p._uplaceniIznos)
					return false;
				DodajPrijavu2(p);
				return true;
			}
		}
		return false;
	}
};

void main() {

	/*
	1. BROJ I TIPOVI PARAMETARA MORAJU BITI IDENTICNI ONIMA U TESTNOM CODE-U (OSIM UKOLIKO IMATE OPRAVDANU POTREBU ZA MODIFIKACIJOM). U SUPROTNOM SE RAD NECE BODOVATI
	2. KREIRAJTE .DOC FAJL SA VAŠIM BROJEM INDEKSA ( NPR. IB130030.DOC BEZ IMENA I PREZIMENA), TE NA KRAJU ISPITA U NJEGA KOPIRAJTE RJEŠENJA VAŠIH ZADATAKA.
	NE PREDAVATI .TXT ILI .CPP FAJLOVE. TAKOÐER, UKLONITE SVE DIJELOVE CODE-A KOJI NISU IMPLEMENTIRANI
	3. TOKOM IZRADE ISPITA NIJE DOZVOLJENO KORIŠTENJE HELP-A
	4. TOKOM IZRADE ISPITA MOGU BITI POKRENUTA SAMO TRI PROGRAMA: PDF READER (ISPITNI ZADACI), MS VISUAL STUDIO, MS WORD (U KOJI CETE KOPIRATI VAŠA RJEŠENJA)
	5. BEZ OBZIRA NA TO DA LI SU ISPITNI ZADACI URAÐENI, SVI STUDENTI KOJI SU PRISTUPILI ISPITU MORAJU PREDATI SVOJ RAD
	*/

	Datum datum1, datum2, datum3, datum4, datum5, datum6, rodjendan;
	datum1.Unos(26, 11, 2015);
	datum2.Unos(29, 5, 2016);
	datum3.Unos(5, 6, 2016);
	datum4.Unos(15, 8, 2016);
	datum5.Unos(13, 7, 2016);
	datum6.Unos(22, 9, 2016);
	rodjendan.Unos(15, 6, 1995);

	Kurs softverski, html, sql, security;
	softverski.Unos(SoftwareEngeneeringFundamentals, datum1, datum2, "Emina Junuz", 1800);
	html.Unos(HtmlCSSJavaScript, datum2, datum3, "Larisa Tipura", 1000);
	sql.Unos(MasteringSQL, datum3, datum4, "Jasmin Azemovic", 2230);
	security.Unos(WindowsSecurity, datum3, datum4, "Adel Handzic", 4000);

	Polaznik denis, zanin, indira, dubravka;
	denis.Unos("Denis Music", rodjendan);
	zanin.Unos("Zanin Vejzovic", rodjendan);
	indira.Unos("Indira Hamulic", rodjendan);
	dubravka.Unos("Dubravka Plosko", rodjendan);


	Prijava denisZaninDubravkaHtml, zaninIndiraHtml, indiraSql;
	denisZaninDubravkaHtml.Unos(&html);
	//700 predstavlja uplatu polaznika koji se prijavljuje na kurs
	if (denisZaninDubravkaHtml.DodajPolaznika(denis, 700))//tokom prijave polaznika nije potrebno uplatiti kompletan iznos, ali on mora biti veci od 50% iznosa kojeg je u tom momentu potrebno platiti (u zavisnosti od broja prijavljenih tj. ostvarenog popusta)
		cout << "Polaznik uspjesno dodan!" << endl;
	if (denisZaninDubravkaHtml.DodajPolaznika(zanin, 650))
		cout << "Polaznik uspjesno dodan!" << endl;
	if (denisZaninDubravkaHtml.DodajPolaznika(zanin, 650))//onemoguciti dupliranje polaznika na istoj prijavi
		cout << "Polaznik uspjesno dodan!" << endl;
	if (denisZaninDubravkaHtml.DodajPolaznika(dubravka, 430))//uplata ne zadovoljava kriterije
		cout << "Polaznik uspjesno dodan!" << endl;

	if (denisZaninDubravkaHtml.DodajUplatu(zanin, 200))//polaznik mora biti prethodno dodan prijavi da bi mogao dodati novu uplatu
		cout << "Uplata uspjesno dodana" << endl;

	zaninIndiraHtml.Unos(&html);
	if (zaninIndiraHtml.DodajPolaznika(zanin, 800))
		cout << "Polaznik uspjesno dodan!" << endl;
	if (zaninIndiraHtml.DodajPolaznika(indira, 750))
		cout << "Polaznik uspjesno dodan!" << endl;

	float stanjeUplate = denisZaninDubravkaHtml.StatusUplate(zanin);//ako polaznik duguje novca funkcija vraca negativan iznos potrebne uplate
	cout << "Polaznik "; zanin.Ispis();
	if (stanjeUplate > 0)
		cout << " je u pretplati " << stanjeUplate << " KM" << endl;
	else
		cout << " je duzan uplatiti " << stanjeUplate * -1 << " KM" << endl;

	SkillsCentar mostar;
	mostar.Unos("Skills Center Mostar");
	//jedan edukacijski centar moze moze nuditi vise istih kurseva (npr. MasteringSQL), ali novi kurs moze poceti tek 15 dana nakon zavrsetka prethodnog kursa npr. 
	//ako prethodni kurs MasteringSQL traje 01.03.2016 - 01.04.2016, onda se novi kurs MasteringSQL moze poceti nakon 15.04.2016
	if (mostar.DodajKurs(html)) {
		cout << crt << "KURS USPJESNO REGISTROVAN" << crt;
		html.Ispis();
		cout << crt;
	}
	//nije moguce dodati prijavu onog kursa koji nije evidentiran (registrovan, ponudjen) u tom edukacijskom centru
	//moguce je dodati samo one prijave koje kod kojih ukupna uplata iznosi vise od 80% cijene kursa (za prijavljeni broj polaznika) 
	if (mostar.DodajPrijavu(denisZaninDubravkaHtml)) {
		cout << crt << "PRIJAVA EVIDENTIRANA" << crt;
		denisZaninDubravkaHtml.Ispis();
	}
	if (mostar.DodajPrijavu(zaninIndiraHtml)) {
		cout << crt << "PRIJAVA EVIDENTIRANA" << crt;
		zaninIndiraHtml.Ispis();
	}
	//int brojPolaznika = 0;
	////vraca niz polaznika koji nisu izmirili uplate
	//Polaznik * polazniciDugovanja = mostar.PolazniciDugovanja(brojPolaznika);

	//cout << "Pronadjeno " << brojPolaznika << " polaznika koji nisu kompletirali svoje uplate --->>> ";
	//for (size_t i = 0; i < brojPolaznika; i++)
	//	polazniciDugovanja[i].Ispis();

	////PretragaRekurzivno - rekurzivna funkcija pronalazi najveci iznos duga ostvarenog u odredjenom edukacijskom centru
	//cout << "Najveci dug iznosi " << PretragaRekurzivno(/*potrebni parametri*/) << endl;
	////ispisuje sve informacije o edukacijskom centru. prije ispisa sortirati sve prijave po visini dugovanja njenih polaznika
	//mostar.Ispis();

	//izvrsiti potrebne dealokacije
	system("pause");
}

__________________________________________________________________________


#include<iostream>
#include<fstream>
using namespace std;
#pragma warning(disable:4996)

char * crt = "\n----------------------------------------------------\n";
struct Datum {
	int * _dan, *_mjesec, *_godina;
	void Unos(int d, int m, int g) {
		_dan = new int(d);
		_mjesec = new int(m);
		_godina = new int(g);
	}
	void Ispis() { cout << *_dan << "/" << *_mjesec << "/" << *_godina << endl; }
	void Dealociraj() {
		delete _dan; delete _mjesec; delete _godina;
		_dan = _mjesec = _godina = nullptr;
	}
	bool Isti(Datum datum){
		if (datum._dan == _dan && datum._mjesec == _mjesec && datum._godina == _godina)
			return true;
		return false;
	}
};
struct Izostanak {
	char * _razlogIzostanka;
	Datum _datumIzostanka;
	int _brojSati;
	bool _opravdano;//pravdanje zahtijeva da se evidentira i razlog izostanka	
	void Unos(Datum datumIzostanka, int brojSati) {
		_datumIzostanka.Unos(*datumIzostanka._dan, *datumIzostanka._mjesec, *datumIzostanka._godina);
		_brojSati = brojSati;
		_opravdano = false;
		_razlogIzostanka = new char;
		_razlogIzostanka[0] = '\0';
	}
	void Kopiraj(char*razlog,Datum datumIzostanka, int brojSati,bool opravdano) {
		_razlogIzostanka = new char[strlen(razlog) + 1];
		strcpy_s(_razlogIzostanka, strlen(razlog) + 1, razlog);
		_datumIzostanka.Unos(*datumIzostanka._dan, *datumIzostanka._mjesec, *datumIzostanka._godina);
		_brojSati = brojSati;
		_opravdano = opravdano;
	}
	void Dealociraj() { delete[]_razlogIzostanka; _razlogIzostanka = nullptr; }
	void Ispis() { _datumIzostanka.Ispis(); cout << _razlogIzostanka << " " << _razlogIzostanka; }
	void Opravdaj(char * razlogIzostanka) {
		if (_razlogIzostanka != nullptr)
			delete _razlogIzostanka;
		int vel = strlen(razlogIzostanka) + 1;
		_razlogIzostanka = new char[vel];
		strcpy_s(_razlogIzostanka, vel, razlogIzostanka);
		_opravdano = true;
	}
};
struct Student{
	//format broja indeksa: IB150051
	//osigurati automatsko generisanje broja indeksa pocevsi od IB150001
	char _brojIndeksa[9];
	char * _imePrezime;
	Izostanak * _izostanci;
	int _brojIzostanaka;
		
	void Ispis(){
		//4. Ispis - ispisuje izostanke u formatu prikazanom na slici (nije obavezno da ispis bude identican, ali je svakako pozeljno). 
		//Prilikom svakog ispisa, izostanke je potrebno spasiti u tekstualni fajl sa istim nazivom kao i broj indeksa.
		char* nazivfajla = _brojIndeksa;
		ofstream upis(nazivfajla, ios::app,ios::binary);
		if (upis.is_open()){
			for (int i = 0; i < _brojIzostanaka; i++)
			{
				_izostanci[i].Ispis();
				upis.write((char*)(&_izostanci[i]), sizeof(_izostanci[i]));
			}
			upis.close();
		}
	}
	void Unos(char* indeks,char* ip){
		strcpy_s(_brojIndeksa, 9, indeks);
		_imePrezime = new char[strlen(ip) + 1];
		strcpy_s(_imePrezime, strlen(ip) + 1, ip);
		_izostanci = nullptr;
		_brojIzostanaka = 0;
	}


	//2. Dealociraj
	void DodajIzostanak(Izostanak iz){
		/*3. DodajIzostanak - dodaje novi izostanak u listu izostanaka.	Onemoguciti ponavljanje izostanaka na nacin da se uvecava samo broj sati ukoliko
		korisnik (profesor) vise puta pokusa dodati izostanak na isti dan.*/
		for (int i = 0; i < _brojIzostanaka; i++)
		{
			if (_izostanci[i]._datumIzostanka.Isti(iz._datumIzostanka)){
				_izostanci[i]._brojSati += iz._brojSati;
				return;
			}
		}
		Izostanak* temp = new Izostanak[_brojIzostanaka + 1];
		for (int i = 0; i < _brojIzostanaka; i++)
		{
			temp[i].Kopiraj(_izostanci[i]._razlogIzostanka, _izostanci[i]._datumIzostanka, _izostanci[i]._brojSati, _izostanci[i]._opravdano);
			_izostanci[i].Dealociraj();
		}
		temp[_brojIzostanaka].Kopiraj(iz._razlogIzostanka, iz._datumIzostanka, iz._brojSati, iz._opravdano);
		_izostanci = temp;
		temp = nullptr;
		_brojIzostanaka++;
	}
	//4. Ispis - ispisuje izostanke u formatu prikazanom na slici (nije obavezno da ispis bude identican, ali je svakako pozeljno). Prilikom svakog ispisa, izostanke je potrebno spasiti u tekstualni fajl sa istim nazivom kao i broj indeksa.
	//5. BinarnaPretraga - koristeci binarnu pretragu, na osnovu datuma, pronalazi i vraca pokazivac na izostanak. Ukoliko trazeni izostanak ne postoji funkcija vraca nullptr.
};
//1. PronadjiNajveciNeopravdaniIzostanak - rekurzivna funkcija koja vraca pokazivac na neopravdani izostanak koji ima najveci broj sati
Izostanak* PronadjiNajveciNeopravdaniIzostanak(Student s,int brojac=0,int najveci=0,Izostanak* izostanak=nullptr){
	if (brojac > s._brojIzostanaka)
		return izostanak;
	if (s._izostanci[brojac]._brojSati > najveci)
		return PronadjiNajveciNeopravdaniIzostanak(s, brojac+1, najveci = s._izostanci[brojac]._brojSati, izostanak = &s._izostanci[brojac]);
	else
		return PronadjiNajveciNeopravdaniIzostanak(s, brojac+1, najveci, izostanak);
}
//2. GenerisiSljedeciBrojIndeksa - generise i vraca naredni broj indeksa
int sljedecibroj = 160001;
char* GenerisiSljedeciBrojIndeksa(){
	char niz[3] = { "IB" };
	char* niz2 = new char[7];
	itoa(sljedecibroj, niz2, 10);
	int velicina = strlen(niz2) + strlen(niz) + 1;
	char*brindeksa = new char[velicina];
	strcpy_s(brindeksa, velicina, niz);
	strcat_s(brindeksa, velicina, niz2);
	sljedecibroj++;
	return brindeksa;
}

void main() {
	Datum jucer, prije5Dana, prije10Dana;
	jucer.Unos(12, 6, 2016);
	prije5Dana.Unos(8, 6, 2016);
	prije10Dana.Unos(3, 6, 2016);

	Student denis;
	denis.Unos(GenerisiSljedeciBrojIndeksa(), "Denis Music");

	Izostanak izostanakJucer, izostanakPrije5Dana, izostanakPrije10Dana;

	izostanakJucer.Unos(jucer, 5);
	denis.DodajIzostanak(izostanakJucer);

	izostanakPrije5Dana.Unos(prije5Dana, 3);
	izostanakPrije5Dana.Opravdaj("Odsutan zbog bolesti - gripa");
	denis.DodajIzostanak(izostanakPrije5Dana);
	izostanakPrije5Dana.Unos(prije5Dana, 2);
	denis.DodajIzostanak(izostanakPrije5Dana);

	izostanakPrije10Dana.Unos(prije10Dana, 1);
	denis.DodajIzostanak(izostanakPrije10Dana);
	izostanakPrije10Dana.Unos(prije10Dana, 1);
	denis.DodajIzostanak(izostanakPrije10Dana);

	//denis.Ispis();
	//Izostanak * p = denis.BinarnaPretraga(jucer);
	//cout << "Binarnom pretragom pronadjen izostanak -> ";
	//p->Ispis();
	//denis.Ispis();
	Izostanak * p2 = PronadjiNajveciNeopravdaniIzostanak(denis );
	cout << "Rekurzivno pronadjen najveci neopravdani izostanak -> ";
	p2->Ispis();
	cout << endl;
	////dealocirati zauzetu memoriju
}

______________________________________________________________________




